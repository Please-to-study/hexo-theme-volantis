---
title: C++ Primer 第9章 顺序容器
seo_title: C++ Primer 第9章 顺序容器
toc: true
indent: true
comments: true
archive: true
cover: true
mathjax: false
pin: false
top_meta: true
bottom_meta: true
sidebar:
  - toc
icons: []
references:
  - title: C++ Primer
    url: https://github.com/Please-to-study/C-Study/blob/master/C++primer.md
date: 2021-12-18 23:19:07
updated: 2021-12-18 23:19:07
categories:
- C++基础知识
keywords: 顺序容器
description: C++中的顺序容器
headimg: https://cdn.pkubailu.cn/img/第9章封面.png
thumbnail:
tags:
- C++基础
---

{% note info:: 第 9 章 顺序容器 %}

# 第9章 顺序容器

一个容器就是一些特定类型对象的集合。**顺序容器**为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

## 9.1 顺序容器概述

所有顺序容器都提供了快速顺序访问元素的能力。

![](https://cdn.pkubailu.cn/img/9.1.png)

除了固定大小的array外，其他容器都提供高校、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策略对容器操作的效率有着固有的，有时是重大的影响。在某些情况下，存储策略还会影响特定容器是否支持特定操作。

> 新标准库的容器比旧版本快得多。现代C++程序应该使用标准库容器，而不是更原始的数据结构。

## 9.2 容器库概览

容器均定义为模板类。例如对vector，我们必须提供额外信息来生成特定的容器类型。对大多数，但不是所有容器，我们还需要额外提供元素类型信息。

```C++
list<Sales_data> // 保存 Sales_data对象的list
deque<double> // 保存double的deque
```

### 9.2.0 对容器可以保存的元素类型的限制

顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另一个容器。

> 较旧的的编译器可能需要在两个尖括号之间键入空格。

虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。

例如，顺序容器构造函数的一个版本接收容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数。

```C++
// 假定noDefault是一个没有默认构造函数的类型
vector<noDefault> v1(10, init); // 正确：提供了元素初始化器
vector<noDefault> v2(10); // 错误： 必须提供一个元素初始化器
```

![](https://cdn.pkubailu.cn/img/9.2.png)

### 9.2.1 迭代器

forward_list 迭代器不支持递减运算符。

算术运算只能应用于string、vector、deque、array的迭代器。我们不能将它们用于其他任何容器类型的迭代器。

一个**迭代器范围**由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置。这两个迭代器通常被称为begin和end，他们标记了容器中元素的一个范围。

迭代器范围中的元素包含begin所表示的元素以及从begin开始直至end（但不包含end）之间的所有元素。

这种元素范围被称为**左闭合区间**。

迭代器begin和end必须指向相同的容器。end可以与begin指向相同的位置，但不能指向begin之前的位置。

>如果满足如下条件，两个迭代器begin和end构成一个迭代器范围：
>
>- 他们指向同一个容器中的元素，或者是容器最后一个元素之后的位置。
>- 我们可以通过反复递增begin来到达end。换句话说，end不在begin之前。

#### 使用左闭合范围蕴含的编程假定

标准库使用左闭合范围是因为这种范围有三种方便的性质。

- 如果begin与end相等，则范围为空。
- 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素。
- 我们可以对begin递增若干次，使得begin==end

### 9.2.2 容器类型成员

通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。

为了使用这些类型，我们必须显示使用其类名：

```c++
// iter是通过list<string>定义的一个迭代器类型
list<string>::iterator iter;
// count是通过vector<int>定义的一个difference_type类型
vector<int>::difference_type count;
```

#### 9.2.3 begin 和 end 成员

begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围。

实际上有两个名为begin的成员。一个是const成员，返回容器的const_iterator类型。另一个是非常量成员，返回容器的iterator类型。

用c开头的版本是C++新标准库引入的，用以支持auto与begin和end函数结合使用。

```C++
// 显示指定类型
list<string>::iterator it5 = a.begin();
list<string>::const_iterator it6 = a.cbegin();
// 是iterator还是const_iterator依赖于a的类型
auto it7 = a.begin(); // 仅当a是const时，it7是const_iterator
auto it8 = a.cbegin(); // it8是const_iterator
```

当auto与begin和end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代毫不相干。但c开头的版本还是可以获得const_iterator的，而不管容器的类型是什么。

#### 9.2.4 容器定义和初始化

每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。

![](https://cdn.pkubailu.cn/img/9.3.png)

#### 将一个容器初始化为另一个容器的拷贝

将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，或者拷贝由一个迭代器对指定的元素范围。

为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器得元素类型即可。

```C++
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
list<string> list2(authors); // 正确：类型匹配
deque<string> authList(authors); // 错误：容器类型不匹配
vector<string> words(articles); // 错误：容器元素类型不匹配
// 正确： 可以将const char*元素转换为string
forward_list<string> words(articles.begin(), articles.end());
```

> 当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。

当两个迭代器表示一个范围时，我们可以使用这种构造函数来拷贝一个容器中的子序列。

#### 列表初始化

在新标准中，我们可以对一个容器进行列表初始化

```C++
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
```

当这样做时，我们就显示的指定了容器中每个元素的值。对于除array之外的容器类型，初始化列表还隐含的指定了容器的大小：容器将包含与初始值一样多的元素。

#### 与顺序容器大小相关的构造函数

除了与关联容器相同的构造函数外，顺序容器（array除外）还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器：

```C++
vector<int> ivec(10, -1); // 10个int元素，每个都初始化为-1
list<string> svec(10, "hi!"); // 10个string，每个都初始化为"hi!"
forward_list<int> ivec(10); // 10个int元素，每个都初始化为0
deque<string> svec(10); // 10个元素，每个都初始化为空string
```

如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显示的元素初始值。

> 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。

#### 标准库 array具有固定大小

与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小：

```C++
array<int, 42> // 类型为：保存42个int的数组
array<string, 10> // 类型为：保存10个string的数组
```

为了使用array类型，我们必须同时指定元素类型和大小：

```C++
array<int, 10>::size_type i; // 数组类型包括元素类型和大小
array<int>::size_type j; // 错误：array<int>不是一个类型
```

与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化，就像一个内置数组一样。如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行：

```C++
array<int, 10> ia1; // 10个默认初始化的int
array<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9}; // 列表初始化
array<int, 10> ia3 = {42}; // ia3[0]为42，剩余元素为0
```

值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制：

```C++
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs; // 错误：内置数组不支持拷贝或赋值
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> copy = digits; // 正确：只要数组类型匹配即合法
```

与其他容器一样，array也要求初始值的类型必须与要创建的容器类型相同。此外，array还要求元素类型和大小也都一样，因为大小是array类型的一部分。

### 9.2.5 赋值和swap

赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。

如果两个容器原来大小不同，赋值运算后两者的大小都与右边容器的原大小相同。

与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型。

由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持assign，也不允许用花括号包围的值列表进行赋值。

![](https://cdn.pkubailu.cn/img/9.4.png)

#### 使用assign（仅顺序容器）

赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元素拷贝到左边运算对象中。顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。

```C++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle; // 错误：容器类型不匹配
// 正确： 可以将const char*转换为string
names.assign(oldstyle.cbegin(), oldstyle.cend());
```

这段代码中对assign的调用将names中的元素替换为迭代器所指定的范围中的元素的拷贝。

> 由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器。

#### 使用swap

swap操作交换两个相同类型容器的内容。

```C++
vector<string> svec1(10); // 10个元素的vector
vector<string> svec2(24); // 24个元素的vector
swap(svec1, svec2);
```

调用swap后，svec1将包含24个string元素，svec2将包含10个string。除array外，交换两个容器内容的操作保证会很快—元素本身并未交换，swap只是交换了两个容器的内部数据结构。

> 除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。

元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。例如，假定iter在swap之前指向svec1[3]的string，那么在swap之后它指向svec2[3]的元素。与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。

与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。

因此，对于array，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。

### 9.2.6 容器大小操作

每个容器类型都有三个与大小相关的操作。成员函数size返回容器中元素的数目；empty当size为0时返回布尔值true，否则返回false；max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。forward_list支持max_size和empty，但不支持size。

### 9.2.7 关系运算符

每个容器类型都支持（==和!=）；除了无序关联容器外的所有容器都支持关系运算符(>,>=,<,<=)。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。

比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似。

#### 容器的关系运算符使用元素的关系运算符完成比较

> 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。

容器的相等运算符实际上是使用元素的==运算符实现比较的，而其他关系运算符是使用元素的<运算符。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。

## 9.3 顺序容器操作

### 9.3.1 向顺序容器添加元素

除array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态的添加或删除元素来改变容器大小。

![](https://cdn.pkubailu.cn/img/9.5.png)

#### 使用push_back

除了array和forward_list之外，每个顺序容器（包括string）都支持push_back。

> Note! 当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值得一个拷贝，而不是对象本身。

#### 使用push_front

list、forward_list和deque容器支持名为push_front的操作。

deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首尾进行插入和删除元素的操作都只花费常数时间。与vector一样，在deque首位之外的位置插入元素会很耗时。

#### 在容器中的特定位置添加元素

vector、deque、list、string支持insert成员。

虽然某些容器不支持push_front操作，但它们对于insert操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置。

#### 插入范围内元素

```C++
// 运行时错误： 迭代器表示要拷贝的范围，不能指向与目的位置相同的容器
slist.insert(slist.begin(), slist.begin(), slist.end());
```

在新标准下，接受元素个数或范围的insert版本返回指向第一个新加入元素的迭代器。如果范围为空，不插入任何元素，insert操作会将第一个参数返回。

#### 使用insert的返回值

通过使用insert的返回值，可以在容器中一个特定位置反复插入元素：

```C++
list<string> lst;
auto iter = lst.begin();
while (cin >> word)
  iter = lst.insert(iter, word); // 等价于调用push_front
```

#### 使用emplace操作

当调用push或insert成员函数时，我们将元素类型的对象传递给他们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。

```C++
// 在C的末尾构造一个Sales_data对象
// 使用三个参数的Sales_data构造函数
c.emplace("978-059232323", 25, 15.99);
// 错误： 没有接受三个参数的push_back版本
c.push_back("978-059232323", 25, 15.99);
// 正确： 创建一个临时的Sales_data对象传递给push_back
c.push_back(Sales_data("978-059232323", 25, 15.99));
```

其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对象。在调用emplace_back时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。

> emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。

### 9.3.2 访问元素

![](https://cdn.pkubailu.cn/img/9.6.png)

包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数。

```C++
// 在解引用一个迭代器或调用front或back之前检查是否有元素
if(!c.empty()) {
  auto va1 = *c.begin(), va2 = c.front();
  auto last = c.end();
  auto va3 = *(--last);
  auto va4 = c.back();
}
```

> 对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误。

#### 访问成员函数返回的是引用

在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用。

```C++
if (!c.empty()) {
  c.front = 42; // 将42赋值给第一个元素
  auto &v = c.back(); // 获得指向最后一个元素的值
  v = 1024; // 改变了c中元素的值
  auto v2 = c.back(); // v2 不是一个引用，它是c.back()的一个拷贝
  v2 = 0; // 未改变c中的元素
}
```

与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。

#### 下标操作和安全的随机访问

如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常：

```C++
vector<string> svec; // 空vector
cout << svec[0]; // 运行时错误：svec中没有元素
cout << svec.at(0); //抛出一个out_of_range异常
```

### 9.3.3 删除元素

![](https://cdn.pkubailu.cn/img/9.7.png)

> 删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它们是存在的。

与元素访问成员函数类似，不能对一个空容器执行弹出操作。

```C++
// 删除两个迭代器表示的范围内的元素
// 返回指向最后一个被删元素之后位置的迭代器
elem1 = slist.erase(elem1, elem2); // 调用后，elem1 == elem2
```

迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置。

### 9.3.4 特殊的forward_list操作

![](https://cdn.pkubailu.cn/img/9.8.png)

### 9.3.5 改变容器大小

我们可以用resize来增大或缩小容器，与往常一样，array不支持resize。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部：

```C++
list<int> ilist(10, 42); // 10个int：每个的值都是42
ilist.resize(15); // 将5个只为0的元素添加到ilist的末尾
ilist.resize(25, -1); // 将10个值为-1的元素添加到ilist的末尾
ilist.resize(5); // 从ilist末尾删除20个元素
```

![](https://cdn.pkubailu.cn/img/9.9.png)

### 9.3.6 容器操作可能使迭代器失效

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题。

在向容器添加元素后：

- 如果容器是vector和string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。
- 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
- 对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，当我们删除一个元素后：

- 对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。
- 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。
- 对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。
- 注意：当我们删除元素时，尾后迭代器总是会失效。

> 由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。

#### 编写改变容器的循环程序

添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步都更新迭代器、引用和指针。

#### 不要保存end返回的迭代器

当我们添加/删除vector或string的元素后，或在deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总是会失效。因此，添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代器，一直当做容器末尾使用。

```C++
// 灾难：次循环的行为是未定义的
auto begin = v.begin(), end = v.end();
while(begin != end) {
  // 做一些处理
  // 插入新值，对begin重新赋值，否则的话它就会失效
  ++begin;
  begin = v.insert(begin, 42); // 插入新值
  ++begin; // 向前移动begin跳过我们刚刚加入的元素
}
```

此代码的行为是未定义的。在很多标准库实现上，此代码会导致无限循环。问题在于我们将end操作返回的迭代器保存在一个名为end的局部变量中。在循环体中，我们向容器中添加了一个元素，这个操作使保存在end中的迭代器失效了。

## 9.4 vector对象是如何增长的

当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。

### 9.4.1 管理容量的成员函数

![](https://cdn.pkubailu.cn/img/9.10.png)

> reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。

只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）

如果需求大小小于或者等于当前容量，reserve什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用reserve之后，capacity将会大于或等于传递给reserve的参数。

调用reserve永远也不会减少容器占用的内存空间。类似的，resize成员函数只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。

在新标准库中，我们可以调用shrink_to_fit来要求deque、vector、string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。

#### capacity和size

理解capacity和size的区别非常重要。容器的size是指他已经保存的元素的数量：而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。

实际上，只要没有操作需求超出vector的容量，vector就不能重新分配内存空间。

> Note! 每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只有当迫不得已时才可以分配新的内存空间。

## 9.5 额外的string操作

### 9.5.1 构造string的其他方法

![](https://cdn.pkubailu.cn/img/9.11.png)

这些构造函数接受一个string或一个const char*参数，还接受（可选的）指定拷贝多少个字符的参数。当我们传递给他们的是一个string时，还可以给定一个下标来指出从哪里开始拷贝。

![](https://cdn.pkubailu.cn/img/9.11-1.png)

通常当我们从一个const char*创建string时，指针指向的数据必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。如果我们未传递计数值且数组也未必以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。

#### substr操作

![](https://cdn.pkubailu.cn/img/9.12.png)

### 9.5.2 改变string的其他方法

除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本。下标指出了开始删除的位置，或是insert到给定值之前的位置：

```C++
s.insert(s.size(), 5, '!'); // 在s末尾插入5个感叹号
s.erase(s.size() - 5, 5); // 从s删除最后5个字符
```

标准库string类型还提供了接受C风格字符数组的insert和assign版本。例如，我们可以将以空字符结尾的字符数组insert到或assign给一个string：

```C++
const char *cp = "Stately, plump Buck";
s.assign(cp, 7); // s == "Stately"
s.insert(s.size(), cp + 7); // s == "Stately, plump Buck"
```

我们也可以指定将来自其他string或子字符串的字符插入到当前string中或赋予当前string：

```C++
string s = "Some string", s2 = "Some other string";
s.insert(0, s2); // 在s中位置0之前插入s2的拷贝
// 在s[0]之前插入s2中s2[0]开始的s2.size()个字符
s.insert(0, s2, 0, s2.size());
```

#### append 和 replace 函数

![](https://cdn.pkubailu.cn/img/9.13-0.png)

![](https://cdn.pkubailu.cn/img/9.13-1.png)

![](https://cdn.pkubailu.cn/img/9.13-2.png)

#### 改变string的多种重载函数

assign和append函数无需指定要替换string中哪个部分：assign总是替换string中的所有内容，append总是将新字符追加到string末尾。

### 9.5.3 string搜索操作

这些搜索成员函数及其参数。每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为string::npos的static成员。标准库将npos定义为一个const string::size_type类型，并初始化为值-1。

![](https://cdn.pkubailu.cn/img/9.14-0.png)

![](https://cdn.pkubailu.cn/img/9.14-1.png)

![](https://cdn.pkubailu.cn/img/9.14-2.png)

#### 9.5.4 compare函数

![](https://cdn.pkubailu.cn/img/9.15.png)

### 9.5.5 数值转换

![](https://cdn.pkubailu.cn/img/9.16.png)

## 9.6 容器适配器

除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue、priorty_queue。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。

![](https://cdn.pkubailu.cn/img/9.17.png)

### 9.6.1 定义一个适配器

每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。

```C++
stack<int> stk(deq); // 从deq拷贝元素到stk
```

默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。

```C++
// 在vector上实现的空栈
stack<string, vector<string>> str_stk;
// str_stk2 在
stack<string, vector<string>> str_stk2(svec);
```

对于一个给定的适配器，可以使用哪些容器是有限制的。所有的适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在array之上。类似的，我们也不能用forward_list来构造适配器，因为所有的适配器都要求容器具有添加、删除以及访问尾元素的能力。

### 9.6.2 栈适配器

![](https://cdn.pkubailu.cn/img/9.18.png)

每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作，而不能使用底层容器类型的操作。

### 9.6.3 队列适配器

![](https://cdn.pkubailu.cn/img/9.19-1.png)

![](https://cdn.pkubailu.cn/img/9.19-2.png)

## 9.7 总结

1. **顺序容器**为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。
2. 虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了
3. forward_list 迭代器不支持递减运算符。
4. 算术运算只能应用于string、vector、deque、array的迭代器。我们不能将它们用于其他任何容器类型的迭代器。
5. 迭代器begin和end必须指向相同的容器。end可以与begin指向相同的位置，但不能指向begin之前的位置。
6. 当auto与begin和end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代毫不相干。但c开头的版本还是可以获得const_iterator的，而不管容器的类型是什么。
7. 当创建一个容器为另一个容器的拷贝时，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器得元素类型即可。
8. 只有顺序容器（array除外）的构造函数才接受大小参数，关联容器并不支持
9. 与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小
10. 值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制，但要求两边类型相同
11. 赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。
12. 如果两个容器原来大小不同，赋值运算后两者的大小都与右边容器的原大小相同。
13. 顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值
14. 除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效
15. forward_list支持max_size和empty，但不支持size
16. 每个容器类型都支持（==和!=）；除了无序关联容器外的所有容器都支持关系运算符(>,>=,<,<=)
17. 容器的关系运算符使用元素的关系运算符完成比较
18. 由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。
19. 添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步都更新迭代器、引用和指针。
20. 要保存end返回的迭代器
21. 容器的size是指他已经保存的元素的数量：而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。
22. 当我们从一个const char*创建string时，指针指向的数据必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。
23. 标准库还定义了三个顺序容器适配器：stack、queue、priorty_queue
24. 本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。
25. 默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。
26. 我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型

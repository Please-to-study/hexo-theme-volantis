---
title: C++ Primer 第2章 变量和基本类型
seo_title: C++ Primer 第2章 变量和基本类型
toc: true
indent: true
comments: true
archive: true
cover: true
mathjax: false
pin: false
top_meta: true
bottom_meta: true
sidebar:
  - toc
icons: []
references:
  - title: C++ Primer
date: 2021-11-6 14:55:53
updated: 2022-11-6 14:55:53
categories:
- C++基础知识
keywords: 变量和基本类型
description: C++语言的变量和基本类型
headimg: https://cdn.pkubailu.cn/img/C++第2章封面.png
thumbnail:
tags:
- C++基础
---

{% note info:: 第2章 变量和基本类型 %}

# 第2章 变量和基本类型

## 2.1 基本内置类型

C++定义了一套包括**算术类型和空类型**在内的基本数据类型。

算术类型： 字符、整型数、布尔值、浮点数。

空类型不对应具体的值。

### 2.1.1 算术类型

算术类型分为两类：整型（包括字符和布尔类型在内）和浮点型。

![](https://cdn.pkubailu.cn/img/2.1.png)

### 2.1.2 类型转换

**切勿混用带符号类型和无符号类型**

> Note! 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号类型数。

### 2.1.3 字面值常量

一个形如42的值被称作**字面值常量**，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

#### 整型和浮点型字面值

整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数。十进制字面值的类型是int、long和long long中尺寸最小的那个。

默认的，浮点型字面值是一个double。

#### 字符和字符串字面值

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

字符串字面值的类型实际上是由常量字符构成的数组。

## 2.2 变量

### 2.2.1 变量初始化

#### 列表初始化

```C++
// 初始化方式
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：

```C++
long double ld = 3.1415926;
int a{ld}, b = {ld}; // 错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld; // 正确：转换执行，且确实丢失了部分值
```

#### 默认初始化

如果是内置类型的变量未被显示初始化，他的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

类的对象如果没有显示的初始化，则其值由类决定。

### 2.2.2 变量的声明和定义的关系

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示的初始化变量：

```C++
extern int i; // 声明i而非定义i
int j; // 声明并定义j
```

任何包含了显示初始化的声明即成为定义。

```C++
extern double pi = 3.1416; // 定义
```

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

## 2.3 复合类型

### 2.3.1 引用

1. 程序把引用和它的初始值绑定到一起，而不是将初始值拷贝给引用。一但初始化完成，引用将和它的初始值对象一直绑定到一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
2. 引用并非对象，相反的它只是为一个已经存在的对象所起的另外一个名字。
3. 引用的类型都要和与之绑定的对象严格匹配。（但有两种例外情况）
4. 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定到一起。

### 2.3.2 指针

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须在定义的时候赋初值。和其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

3. 指针的类型都要和它所指向的对象严格匹配。（但有两种例外情况）

#### 空指针

空指针不指向任何对象。

```c++
# 生成空指针的方法
int *p = nullptr;
int *p = 0;
//需要首先#include cstdlib
int *p = NULL;
```

#### void* 指针

void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址追踪到底是个什么类型的对象并不了解。

利用void* 指针能做的事比较有限：拿他和别的指针比较、作为函数的输入输出、或者赋值给另外一个void\*指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

### 2.3.3 理解复合类型的声明

#### 指向指针的指针

通过*的个数可以区分指针的级别。也就是说，\*\*表示指向指针的指针，\*\*\*表示指向指针的指针的指针，以此类推：

```C++
int ival = 1024;
int *pi = &ival; // pi指向一个int型的数
int **ppi = &pi; // ppi指向一个int型的指针
```

解引用int型指针会得到一个int型的数，同样，解引用指向指针的指针会得到一个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用。

#### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```C++
int i = 42;
int *p = 0; // p是一个int型指针
int *&r = p; // r是对指针p的引用

r = &i; // 给r赋值&i就是让p指向i
*r = 0; // 解引用r得到i,也就是p指向的对象，将i的值改为0
```

### 2.4 const限定符

**如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字**

#### 2.4.1 const的引用

1. 把引用绑定到const对象上，我们称之为**对常量的引用**。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```c++
const int ci = 1024;
const int &r1 = ci;
r1 = 0;  // 错误：ri是对常量的引用，常量无法被修改。
int &r2 = ci; // 错误：试图让一个非常量引用指向一个常量对象。他们的类型不一致！
```

**引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况是：在初始化常量引用的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式**

```c++
int i = 42;
const int &r1 = i; // 允许将const int&绑定到一个普通int对象上;
const int &r2 = 42; // 正确：r2是一个常量引用;
const int &r3 = r1 * 2; // 正确： r3是一个常量引用;
int &r4 = r1 * 2;  // 错误：r4是一个普通的非常量引用;
```

**对const的引用可能引用一个并非const的对象**

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i = 42;
int &r1 = i; // 引用r1绑定对象i
const int &r2 = i; // r2也绑定对象i,但是不允许通过r2来修改i的值;
r1 = 0; // r1并非常量,i的值修改为0;
r2 = 0; // 错误：r2是一个常量引用，不可以做修改操作;
```

### 2.4.2 指针和const

与引用一样，也可以令指针指向常量或非常量。类似于常量引用，**指向常量的指针**不能用于改变其所指对象的值。

指针的类型必须与其所指向对象的类型一致，但是有两个例外。第一种例外的情况是允许令一个指向常量的指针指向一个非常量对象。

```c++
const double pi = 3.14; //pi是一个常量，他的值不能改变;
double *ptr = &pi; // 错误：ptr 是一个普通指针;
const double *cptr = &pi; // 正确：cptr可以指向一个双精度常量;
*cptr = 42; // 错误：cptr指向的是一个常量，不能给cptr赋值;
double dval = 3.14;
cptr = &dval; // 正确：但是不能通过cptr改变dval的值;
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量，所为指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

> 所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以觉得不去改变所指对象的值。

### 2.4.3 顶层const

**顶层const：**表示指针本身是个常量。

**底层const：**表示指针所指对象是一个常量。

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显，其中顶层const不受什么影响。顶层const只是标注了变量本身是const不允许改变，而底层const表示了变量所指的对象的类型，在拷贝时要求拷贝对象和被拷贝对象类型一致！

### 2.4.4 constexpr 和常量表达式

**常量表达式**是指值不会改变并且在编译过程中就能得到计算结果的表达式。

一个对象或表达式是不是常量表达式由他的数据类型和初始值共同决定。

#### 字面值类型

常量表达式的值需要在编译时就得到计算，因此对声明 constexptr 时用到的类型必须有所限制，因为这些类型一般比较简单，值也显而易见、容易得到，就称之为“字面值类型” 算术类型、引用和指针都属于字面值类型。

一个 constexpr 指针的初始值必须是 nullptr 或者0，或者是存储在某个固定地址中的对象。

函数体外的对象其地址固定不变，能用来初始化constexpr指针。

函数体内定义的变量一般来说并非存放在固定地址中，不能初始化 constexpr 指针，但是函数体内也可以定义一类有效范围超出函数本身的变量，这类变量也有固定地址。

```c++
const int *p = nullptr; //p是一个指向整型常量的指针;
constexpr int *q = nullptr; // q是一个指向整型的常量指针
```

## 2.5 处理类型

### 2.5.1 类型别名

有两种方法可用于定义类型别名：

```c++
// 1.传统方法typedef:
typedef double wages; // wages是double的同义词
// 2.别名声明:
using SI = Sales_item; // SI是Sales_item的同义词
```

#### 指针、常量和类型别名

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。

```C++
typedef char *pstring; // pstring 是类型 char* 的别名
const pstring cstr = 0; // cstr 是指向char的常量指针
const pstring *ps; // ps 是一个指针，它的对象是指向char的常量指针
```

遇到一条使用了类型别名的声明语句时，人们往往会错误的尝试把类型别名替换成它本来的样子，以理解该语句的含义：

```C++
const char *cstr = 0; // 是对 const pstring cstr 的错误理解
```

**这种理解是错误的！**声明语句中用到pstring时，其基本数据类型是指针。可是用char\*重写了声明语句后，数据类型就变成了char，*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

### 2.5.2 auto类型说明符

auto类型说明符能让编译器通过初始值来推算变量的类型，显然auto定义的变量必须有初始值。

auto一般会忽略掉顶层const，同时底层const则会保留下来。变量b、c是案例。

设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留！变量g是案例。

例子：

```c++
	 int i = 0, &r = i;
   auto a = r;   // auto = int a是整数
   const int ci = i, &cr = ci;
   auto b = ci; // auto = int b是整数
   auto c = cr; // auto = int c是整数
   auto d = &i; // auto = int d是i的地址值
   auto e = &ci; // auto = int e是i的地址值
   auto &g = ci; // auto = const int  g是整型常量引用 绑定到ci上
```

### 2.5.3 decltype 类型指示符

**decltype**：它的作用是选择并返回操作数的数据类型。

decltype处理顶层const和引用的方式与auto有些不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&, y绑定到变量x
decltype(cj) z; // 错误：z是一个引用，必须初始化
```

**需要指出的是，引用从来都是作为其所指对象的同义词出现，只有用在decltype处是一个例外**

#### decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。

r是个引用，所以decltype(r)的结果是引用类型，如果想让结果类型是r所指对象的类型，可以把r作为表达式的一部分，例如r+0.

如果表达式的内容是解引用操作，则decltype将得到引用类型.

```c++
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; // 正确：加法的结果是int,因此b是一个（未初始化的）int
decltype(*p) c; // 错误：c是int&,必须初始化
```

如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式，decltype就会得到引用类型：

```c++
decltype((i)) d; //错误： d是int&,必须初始化
decltype(i) e; // 正确：e是一个（未初始化的）int
```

> !切记：decltype((variable))（注意是双层括号）的结果永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用时才是引用。

## 2.6 自定义数据结构

### 2.6.3 编写自己的头文件

#### 预处理器概述

预处理变量有两种状态：已定义和未定义。

**#define**指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef**当且仅当变量已定义时为真，**ifndef**当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到**#endif**指令为止。

> 预处理变量无视C++语言中关于作用域的规则。

> 头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符

## 2.7 总结

1. 基本数据类型：

   算术类型：字符、整型数、布尔值、浮点数

   空类型：不对应具体的值

2. 切勿混用带符号类型和无符号类型：

   如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号类型数。

3. 一个形如42的值被称作**字面值常量**，这样的值一望而知。

4. 由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

5. 如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错

6. 如果是内置类型的变量未被显示初始化，他的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化。

7. 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

8. 任何包含了显示初始化的声明即成为定义。

9. 引用：

   1. 一但初始化完成，引用将和它的初始值对象一直绑定到一起。引用必须初始化。
   2. 引用并非对象。
   3. 引用的类型都要和与之绑定的对象严格匹配。（但有两种例外情况）
   4. 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定到一起。

10. 指针：

    1. 指针本身就是一个对象，允许对指针赋值和拷贝。
    2. 指针无须在定义的时候赋初值。
    3. 指针的类型都要和它所指向的对象严格匹配。（但有两种例外情况）

11. void* 是一种特殊的指针类型，可用于存放任意对象的地址。

12. 利用void* 指针能做的事比较有限：拿他和别的指针比较、作为函数的输入输出、或者赋值给另外一个void\*指针。不能直接操作void*指针所指的对象。

13. 引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用

14. 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字

15. 引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况是：在初始化常量引用的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式

16. 对const的引用可能引用一个并非const的对象

17. 与引用一样，也可以令指针指向常量或非常量。类似于常量引用，**指向常量的指针**不能用于改变其所指对象的值。

18. 指针的类型必须与其所指向对象的类型一致，但是有两个例外。第一种例外的情况是允许令一个指向常量的指针指向一个非常量对象。

19. **顶层const：** 表示指针本身是个常量。

    **底层const：**表示指针所指对象是一个常量。

20. **常量表达式**是指值不会改变并且在编译过程中就能得到计算结果的表达式。

21. 有两种方法可用于定义类型别名：

    ```c++
    // 1.传统方法typedef:
    typedef double wages; // wages是double的同义词
    // 2.别名声明:
    using SI = Sales_item; // SI是Sales_item的同义词
    ```

22. auto 和 decltype 类型说明符

23. **#define**指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef**当且仅当变量已定义时为真，**ifndef**当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到**#endif**指令为止。

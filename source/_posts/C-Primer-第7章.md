---
title: C++ Primer 第7章 类
seo_title: C++ Primer 第7章 类
toc: true
indent: true
comments: true
archive: true
cover: true
mathjax: false
pin: false
top_meta: true
bottom_meta: true
sidebar:
  - toc
icons: []
references:
  - title: C++ Primer
    url: https://github.com/Please-to-study/C-Study/blob/master/C++primer.md
date: 2021-12-04 17:13:17
updated: 2021-12-04 17:13:17
categories:
- C++基础知识
keywords: 类
description: C++中的类
headimg: https://cdn.pkubailu.cn/img/第7章封面.png
thumbnail:
tags:
- C++基础
---

{% note info:: 第 7 章 类 %}

# 第7章 类

## 7.1 定义抽象数据类型

### 7.1.2 定义改进的 Sales_data 类

定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，例如add、read和print等，它们的定义和声明都在类的外部。

```C++
// 改进的Sales_data类如下所示
struct Sales_data {
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
// Sales_data的非成员接口函数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
```

> 定义在类内部的函数是隐式的inline函数

#### 定义成员函数

尽管所有成员都必须在类的内部声明，但是成员函数可以定义在类内也可以定义在类外。对于Sales_data类来说，isbn函数定义在了类内，而combine和avg_price定义在了类外。

```C++
std::string isbn() const { return bookNo; }
```

isbn函数是如何获得bookNo成员所依赖的对象的呢？

#### 引入this

```C++
// 调用isbn函数
total.isbn()
```

当我们调用成员函数时，实际上是在替某个对象调用它。如果isbn指向Sales_data的成员(例如bookNo)，则它隐式地指向调用该函数的对象的成员。

成员函数通过一个名为**this**的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。

```C++
total.isbn()
// 编译器负责把total的地址传递给isbn的隐士形参this，可以认为编译器将该调用重写成了如下的形式
Sales_data::isbn(&total)
```

任何对类成员的直接访问都被看作this的隐式调用，也就是说，当isbn使用bookNo时，它隐式的使用this指向的成员，就像我们书写了this->bookNo一样。

对于我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或变量的行为都是非法的。我们可以在成员函数体内部使用this，因此尽管没有必要，但我们还是能把isbn定义成如下的形式：

```C++
std::string isbn() const { return this->bookNo; }
```

因为this的目的总是指向“这个”对象，所以this是一个常量指针，我们不允许改变this中保存的地址。

#### 引入const 成员函数

isbn函数的另一个关键之处是紧随参数列表之后的const关键字，这里，const的作用是修改隐式this指针的类型。

默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales_data成员函数中，this的类型是Sales_data *const。尽管this是隐士地，但它仍然需要遵循初始化规则，意味着（在默认情况下）我们不能把this绑定到一个常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。

如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data *const。毕竟，在isbn的函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。

所以，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称为**常量成员函数**。

因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，isbn可以读取调用它的对象的数据成员，但是不能写入新值。

#### 类作用域和成员函数

编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体内可以随意使用类中的其他成员而无须在意这些成员出现的次序。

#### 在类的外部定义成员函数

如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员名字必须包含它所属的类名。

#### 定义一个返回this对象的函数

```C++
Sales_data& Sales_data::combine(const Sales_data &rhs){
  units_sold += rhs.units_sold; // 把rhs成员加到this对象的成员上
  revenue += rhs.revenue;
  return *this; // 返回调用该函数的对象
  // return语句解引用this指针以获得执行该函数的对象，换句话说，上面的这个调用返回total的引用
}
```

### 7.1.3 定义类相关的非成员函数

类的作者常常需要定义一些辅助函数，比如add、read、和print等。尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。

我们定义非成员函数的方式与定义其它函数一样，通常把函数的声明和定义分离开来。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。

### 7.1.4 构造函数

每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

构造函数的名字和类名相同。和其他函数不一样的是，**构造函数没有返回类型**；类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。

不同于其他成员函数，**构造函数不能被声明成const的**。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。

#### 合成的默认构造函数

类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做**默认构造函数**。默认构造函数无须任何实参。

如果我们的类没有显式的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。

编译器创建的构造函数又被称为**合成的默认构造函数**。其初始化类的数据成员的规则如下：

- 如果存在类内的初始值，用它来初始化成员。
- 否则，默认初始化该成员。

因为Sales_data为units_sold和revenue提供了初始值，所以合成的默认构造函数将使用这些值来初始化对应的成员；同时，它把bookNo默认初始化成一个空字符串。

#### 某些类不能依赖于合成的默认构造函数

合成的默认构造函数只适合非常简单的类，对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：

1. 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。
2. 对于某些类来说，合成的默认构造函数可能执行错误的操作。回忆我们之前介绍过的，如果定义在块中的内置类型或复合类型的对象被默认初始化，则他们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。
3. 有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。

#### 定义Sales_data的构造函数

```C++
struct Sales_data {
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) {}
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  Sales_data(std::istream &);
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
```

#### =default的含义

```C++
Sales_data() = default;
```

因为该构造函数不接受任何实参，所以它是一个默认构造函数。我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。我们希望这个函数的作用完全等同于之前使用的合成默认构造函数。

#### 构造函数初始值列表

```C++
Sales_data(const std::string &s): bookNo(s) {}
Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
```

花括号定义了（空的）函数体。

冒号和花括号之间的部分称为**构造函数初始值列表**，它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。

只有一个string类型参数的构造函数使用这个string对象初始化bookNo，对于units_sold和revenue则没有显示的初始化。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。在此例中，这样的成员使用类内初始值初始化。等价于

```C++
Sales_data(const std::string &s): bookNo(s), units_sold(0), revenue(0) {}
```

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显示的初始化每个内置类型的成员。

#### 在类的外部定义构造函数

```C++
Sales_data::Sales_data(std::istream &is) {
  read(is, *this); // 从is中读取一条交易记录然后存入this对象中
}
```

没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。

### 7.1.5 拷贝、赋值和析构

除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。

如果我们不主动定义这些操作，则编译器将替我们合成他们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。

#### 某些类不能依赖于合成的版本

对于某些类来说，合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。管理动态内存的类通常不能依赖与上述操作的合成版本。

## 7.2 访问控制与封装

### 7.2.0 封装

目前为止，我们的类还没有封装。在C++语言中，我们使用**访问说明符**加强类的封装性：

- 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。
- 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装（即隐藏了）类的实现细节。

````C++
// 再一次定义Sales_data类，其新形式如下所示：
class Sales_data {
public:
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) {}
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  Sales_data(std::istream &);
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
private:
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
````

一个类包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。

#### 使用class或struct关键字

使用class和struct定义类的唯一区别是，struct和class的默认访问权限不太一样。

类可以在他的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。

> 使用class和struct定义类唯一的区别就是默认的访问权限。

### 7.2.1 友元

既然Sales_data的数据成员是private的，我们的read、print和add函数也就无法正常编译了，这是因为尽管这几个函数是类的接口的一部分，但他们不是类的成员。

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的**友元**。如果类想把一个函数成为它的友元，只需要增加一条friend关键字开始的函数声明语句即可：

```C++
class Sales_data{
  friend Sales_data add(const Sales_data&， const Sales_data&);
  friend std::istream &read(std::istream&, Sales_data&);
  ...
}
```

友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。

#### 友元的声明

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。

为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中。

> 许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。

最好为友元函数提供一个独立的函数声明，这样即使更换了一个有强制要求的编译器，也不必改编代码。

## 7.3 类的其他特性

### 7.3.1 类成员再探

#### 定义一个类型成员

除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种：

```C++
class Screen {
public:
  typedef std::string::size_type pos;
private:
  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;
}
```

Screen 的用户不应该知道 Screen 使用了一个string对象来存放它的数据，因此通过把pos定义成public成员可以隐藏Screen实现细节。

**用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别**。因此，类型成员通常出现在类开始的地方。

#### Screen类的成员函数

```C++
class Screen {
public:
  typedef std::string::size_type pos;
  Screen() = default;
  Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht*wd, c) {}
  char get() const { return contents[cursor]; } // 读取光标处的字符 隐士内联函数
  inline char get(pos ht, pos wd) const; // 显式内联
  Screen &move(pos r, pos c); // 能在之后被设为内联
private:
  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;
}
```

第二个构造函数（接收三个参数）为cursor成员隐式地使用了类内初始值。如果类中不存在cursor的初始值，我们就需要像其他成员一样显示的初始化cursor了。

#### 令成员作为内联函数

定义在类内部的成员函数是自动inline的。因此，Screen的构造函数和返回光标所指字符的get函数默认是inline函数。

我们可以在类的内部把inline作为声明的一部分显式的声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：

```C++
inline
Screen &Screen::move (pos r, pos c) {
  pos row = r * width;
  cursor = row + c;
  return *this;
}
```

#### 重载成员函数

和非成员函数一样，成员函数也可以被重载，只要在函数之间的参数的数量或类型上有所区别就行。

#### 可变数据成员

有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。

一个**可变数据成员**永远不会是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值。举个例子：

```C++
class Screen {
public:
  void some_member() const;
private:
	mutable size_t access_ctr; // 即使在一个const对象内也能被修改
};
void Screen::some_member() const {
  ++access_ctr;
}
```

尽管some_member是一个const成员函数，它仍然能够改变access_ctr的值。该成员是个可变成员，因此任何成员函数，包括const函数在内都能改变它的值。

#### 类数据成员的初始值

定义好Screen类之后，我们将继续定义一个窗口类并用它表示显示器上的一组Screen。

```C++
class Window_mgr {
private:
  // 这个Window_mgr追踪的Screen
  // 默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen
  std::vector<Screen> screens{Screen(24,80,'')};
}
```

当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。在此例中，我们使用一个单独的元素值对vector成员执行了列表初始化。

如我们之前所知的，类内初始值必须使用=的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。

> 当我们提供一个类内初始值时，必须以符号=或者花括号表示。

### 7.3.2 返回*this的成员函数

接下来我们继续添加一些函数，他们负责设置光标所在位置的字符或者其他任一给定位置的字符：

```C++
class Screen {
public:
  Screen &set(char);
  Screen &set(pos, pos, char);
}
inline Scrren &Scrren::set(char c) {
  contents[cursor] = c; // 设置当前光标所在位置的新值
  return *this; // 将this对象作为左值返回
}
inline Scrren &Scrren::set(pos r, pos c, char c) {
  contents[r*width + col] = c; // 设置当前光标所在位置的新值
  return *this; // 将this对象作为左值返回
}
```

set成员的返回值是调用set的对象的引用。返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。

如果我们令move和set返回Screen而非Screen&，则下述语句的行为将大不相同。

```C++
// 如果move返回Screen而非Screen&
Screen temp = myScreen.move(4,0); // 对返回值进行拷贝
temp.set('#'); // 不会改变myScreen的contents
```

假如我们定义的返回类型不是引用，则move的返回值将是*this的副本，因此调用set只能改变临时副本，而不能改变myScreen的值。

#### 从const成员函数返回*this

从逻辑上来说，显示一个Screen并不需要改变它的内容，因此我们令display为一个const成员，此时，this将是一个指向const的指针而*this是const对象。由此推断，display的返回类型应该是const Sales_data&。然而，如果真的令display返回一个const的引用，则我们将不能把display嵌入到一组动作序列中去：

```C++
Screen myScreen;
// 如果display 返回常量引用，则调用set将引发错误
myScreen.display(cout).set('#');
```

即使myScreen是个非常量对象，对set的调用也无法通过编译。问题在于display的const版本返回的是常量引用，而我们显然无权set一个常量对象。

> 一个const成员函数如果以引用的形式返回*this，那么他的返回类型将是常量引用。

#### 基于const的重载

通过区分成员函数是否是const的，我们可以对其进行重载。

因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。

```C++
class Screen {
public:
  // 根据对象是否是const 重载了display函数
  Screen &display(std::ostream &os)
  { do_display(os); return *this; }
  const Screen &display(std::ostream &os) const
  { do_display(os); return *this; }
private:
  // 该函数负责显示Screen的内容
  void do_display(std::ostream &os) const
  { os << contents; }
};
```

当do_display完成后，display函数各自返回解引用this所得的对象。在非常量版本中，this指向一个非常量对象，因此display返回一个普通的（非常量）引用；而const成员则返回一个常量引用。

当我们在某个对象上调用display时，该对象是否是const决定了应该调用display的哪个版本。

### 7.3.3 类类型

每个类定义了唯一的类型。对于两个类来说，即使他们的成员完全一样，这两个类也是两个不同的类型。

我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class或struct后面：

```C++
Sales_data item1;
class Sales_data item1;
// 两条声明完全等价
```

#### 类的声明

就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它。

这种声明被称为**前向声明**，他向程序中引入了类的名字（Screen）并且指明Screen是一种类类型，对于类型Screen来说，在它声明之后定义之前是一个**不完全类型**。

不完全类型只能在非常有限的情境下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。

### 7.3.4 友元再探

类可以把普通的非成员函数定义成友元。类还可以把其他的类定义成友元，也可以把其他类的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。

#### 类之间的友元关系

我们的Window_mgr类的某些成员可能需要访问它管理的Screen类的内部数据。例如：Window_mgr类中的函数clear需要访问Screen的私有成员；要想令这种访问合法，Screen需要把Window_mgr指定成它的友元：

```C++
class Screen {
  // Window_mgr 的成员可以访问Screen类的私有部分
  friend class Window_mgr;
}
```

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

```C++
class Window_mgr {
public:
  using ScreenIndex = std::vector<Screen>::size_type;
  void clear(ScreenIndex);
private:
  std::vector<Screen> screens{Screen(24, 80 ,'')};
}
void Window_mgr::clear(ScreenIndex) {
  Screen &s = screens[ScreenIndex];
  s.contents = string(s.ht * s.wd, '');
}
```

如果clear不是Screen的友元，上面的代码将无法通过编译，因为此时clear将不能访问Screen的成员。

必须要注意的一点是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元不能理所当然地具有访问Screen的特权。

#### 令成员函数作为友元

除了令整个Window_mgr作为友元之外，Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类：

```C++
class Screen {
  // Windoew_mgr::clear 必须在Screen类之前被声明
  friend void Windoew_mgr::clear(ScreenIndex);
  ....
}
```

要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序：

- 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。
- 接下来定义Screen，包括对于clear的友元声明。
- 最后定义clear，此时它才可以使用Screen的成员。

#### 函数重载和友元

尽管重载函数的名字相同，但它们仍然是不同的函数，因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。

#### 友元声明和作用域

类和非成员函数的声明不是必须在他们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。

甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的：

```C++
struct X {
  friend void f() {/* 友元函数可以定义在类的内部 */}
  X() { f(); } // 错误：f还没有被声明
  void g();
  void h();
};
void X::g() {return f();} // 错误：f还没有被声明
void f(); // 声明那个定义在X中的函数
void X::h() { return f(); } // 正确：现在f的声明在作用域中了
```

关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。

## 7.4 类的作用域

每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。

### 7.4.0 作用域和定义在类外部的成员

一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无须再次授权了。

另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。

```C++
// 例如
class Window_mgr {
public:
  // 向窗口添加一个Screen,返回它的编号
  ScreenIndex addScreen(const Screen&);
};
// 首先处理返回类型，之后我们才进入Window_mgr的作用域
Window_mgr::ScreenIndex
Window_mgr::addScreen(const Screen& s) {
  screens.push_back(s);
  return screens.size() - 1;
}
```

因为返回类型出现在类名之前，所以事实上它是位于Window_mgr类的作用域之外的。

### 7.4.1 名字查找与类的作用域

在目前为止，我们编写的程序中，**名字查找**（寻找与所用名字最匹配的声明的过程）的过程比较直截了当：

- 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。
- 如果没找到，继续查找外层作用域。
- 如果最终没有找到匹配的声明，则程序报错。

对于定义在类内部的成员函数来说，解析其中的名字的方式与上述的查找规则有所区别。类的定义分两步处理：

- 首先，编译成员的声明。
- 直到类全部可见后才编译函数体。

> 编译器处理完类中的全部声明后才会处理成员函数的定义。

#### 用于类成员声明的名字查找

这种两阶段的处理方式只适用于成员函数体中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。

```C++
typedef double Money;
string bal;
class Account {
public:
  Money balance() { return bal; }
private:
  Money bal;
  // .....
};
```

当编译器看到balance函数的声明语句时，他将在Account类的范围内寻找对Money的声明。编译器只考虑Account中在使用Money前出现的声明，因为没找到匹配的成员，所以编译器会接着到Account的外层作用域中查找。另一方面，balance函数体在整个类可见后才被处理，因此，该函数的return语句返回名为bal的成员，而非外层作用域的string对象。

#### 类型名要特殊处理

一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字：

```C++
typedef double Money;
class Account {
public:
  Money balance() { return bal; } // 使用外层作用域中的名字
private:
  typedef double Money; // 错误：不能重新定义Money
  Money bal;
  // .....
};
```

需要特别注意的是，即使Account中定义的Money类型与外层作用域一致，上述代码仍然是错误的。

> 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

#### 成员定义中的普通块作用域的名字查找

成员函数中使用的名字按照如下方式解析：

- 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。
- 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。
- 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。

一般来说不建议使用其他成员的名字作为某个成员函数的参数。

```C++
// 通常情况下不建议为参数和成员使用同样的名字
int height;
class Screen {
public:
  typedef std::string::size_type pos;
  void dummy_fcn(pos height) {
    cursor = width * height; // 哪个height?
  }
private:
  pos cursor = 0;
  pos height = 0, width = 0;
};
```

当编译器处理dummy_fcn中的乘法表达式时，他首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此dummy_fcn函数体内用到的名字height指的是参数声明。

在上述代码中，height参数隐藏了同名的成员。如果想绕开上面的查找规则应该将代码变为：

```C++
void Screen::dummy_fcn(pos height) {
  cursor = width * this->height; // 成员height
  cursor = width * Screen::height; // 成员height
}
```

> 尽管类的成员被隐藏了，但我们仍然可通过加上类的名字或显示的使用this指针来强制访问成员。

#### 类作用域之后，在外围的作用域中查找

如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。

如果，我们需要的是外层作用域中的名字，可以显示的通过作用域运算符来进行请求：

```C++
void Screen::dummy_fcn(pos height) {
  cursor = width * ::height // 哪个height?是那个全局的
}
```

#### 在文件中名字的出现处对其进行解析

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。

```C++
int height;
class Screen {
public:
  typedef std::string::size_type pos;
  void setHeight(pos);
  pos height = 0; // 隐藏了外层作用域中的height
};
Screen::pos verify(Screen::pos);
void Screen::setHeight(pos var) {
  // var: 参数
  // height: 类的成员
  // verify: 全局函数
  height = verify(var);
}
```

注意：全局函数verify的声明在Screen类的定义之前是不可见的。然后，名字查找的第三步包括了成员函数出现之前的全局作用域。

## 7.5 构造函数再探

### 7.5.1 构造函数初始值列表

如果没有在构造函数的初始值列表中显示的初始化成员，则该成员将在构造函数体之前执行默认初始化。

```C++
Sales_data::Sales_data(const string &s, unsigned cnt, double price) {
  bookNo = s;
  units_sold = cnt;
  revenue = cnt * price;
}
```

原来的版本（构造函数初始化版本）初始化了它的数据成员，而这个版本是对数据成员执行了赋值操作。

#### 构造函数的初始值有时必不可少

有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

```C++
class ConstRef {
public:
  ConstRef(int ii);
private:
  int i;
  const int ci;
  int &ri;
};
```

和其他常量对象或者引用一样，成员ci和ri都必须初始化。

```C++
ConstRef::constRef(int ii){
  i = ii; // 正确
  ci = ii; // 错误： 不能给const赋值
  ri = i; // 错误：ri没被初始化
}
```

随着构造函数体一开始执行，初始化就完成了。我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此构造函数的正确形式应该是：

```C++
// 正确：显示的初始化引用和const成员
ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) {}
```

> Note! 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。

#### 成员初始化的顺序

构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。

成员的初始化顺序与他们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。

> 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。

如果可能的话，最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是我们可以不必考虑成员的初始化顺序。

#### 默认实参和构造函数

```C++
class Sales_data {
public:
  Sales_data(std::string s = ""): bookNo(s) {}
  // ...
}
```

在上面这段程序中，当没有给定实参，或者给定了一个string实参时，两个版本的类创建了相同的对象。因为我们不提供实参也能调用上述的构造函数，所以该构造函数实际上为我们的类提供了默认构造函数。

> 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

### 7.5.2 委托构造函数

C++新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的**委托构造函数**。一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其它构造函数。

在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。

```C++
class Sales_data {
public:
  // 非委托构造函数
  Sales_data(std::string s, unsigned cnt, double price): bookNo(s), units_sold(cnt), revenue(cnt*price) {}
  // 其余构造函数全部委托给另一个构造函数
  Sales_data(): Sales_data("", 0, 0) {}
  Sales_data(std::string s): Sales_data(s, 0, 0) {}
  Sales_data(std::istream &is): Sales_data() { read(is, *this); }
}
```

除了第一个，其他三个构造函数全部委托第一个构造函数完成初始化。

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，执行完后控制权才会交还给委托者的函数体。

### 7.5.3 默认构造函数的作用

当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生：

- 当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时。
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时。
- 当类类型的成员没有在构造函数初始值列表中显示的初始化时。

值初始化在以下情况下发生：

- 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。
- 当我们不使用初始值定义一个局部静态变量时。
- 当我们通过书写形如T()的表达式显示的请求值初始化时，其中T()是类型名（vector的一个构造函数只接受一个实参用于说明vector大小，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。

类必须包含一个默认构造函数以便在上述情况下使用。

> 在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。

### 7.5.4 隐式的类类型转换

我们也能为类定义隐式转换规则。如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐士转换机制，有时我们把这种构造函数称作**转换构造函数**。

> 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。

在Sales_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这两种类型向Sales_data隐式转换的规则。也就是说，在需要使用Sales_data的地方，我们可以使用string或者istream作为替代：

```C++
string null_book = "9-999-9999-9";
// 构造一个临时的Sales_data对象
// 该对象的units_sold和revenue等于0,bookNo等于null_book
item.combine(null_book);
```

这里我们用一个string实参调用了Sales_data的combine成员。该调用是合法的，编译器用给定的string自动创建了一个Sales_data对象。新生成的这个（临时）Sales_data对象被传递给combine。因为combine的参数是一个常量引用，所以我们可以给该参数传递一个临时变量。

#### 只允许一步类类型转换

编译器只会自动的执行一步类类型转换。

```C++
// 因为下面的代码隐式的使用了两种转换规则，所以他是错误的
item.combine("9-99-999");
```

#### 抑制构造函数定义的隐式转换

在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为**explicit**加以阻止：

```C++
class Sales_data {
public:
  Sales_data() = default;
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  explicit Sales_data(const std::string &s): bookNo(s) {}
  explicit Sales_data(std::istream&);
};
```

此时，没有任何构造函数能用于隐式地创建Sales_data对象，之前的两种用法都无法通过编译。

```C++
item.combine(null_book); // 错误：string构造函数是explicit的
item.combine(cin); // 错误：istream构造函数是explicit的
```

关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复：

```C++
explicit Sales_data::Sales_data(istream &is) {
  read(is, *this);
}
```

#### explicit 构造函数只能用于直接初始化

发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=）此时，我们只能使用直接初始化而不能使用explicit构造函数：

```C++
Sales_data item1(null_book); // 正确：直接初始化
// 错误：不能将explicit构造函数用于拷贝形式的初始化过程
Sales_data item2 = null_book;
```

> 当我们使用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。

#### 为转换显示地使用构造函数

尽管编译器不会将explicit的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显示的强制进行转换：

```C++
// 正确： 实参是一个显示构造的Sales_data对象
item.combine(Sales_data(null_book));
// 正确： static_cast可以使用explicit的构造函数
item.combine(static_cast<Sales_data>(cin));
```

#### 标准库中含有显示构造函数的类

我们用过的一些标准库中的类含有单参数的构造函数：

- 接受一个单参数的const char*的string构造函数不是explicit的。
- 接受一个容量参数的vector构造函数是explicit的。

### 7.5.5 聚合类

**聚合类**使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：

- 所有成员都是public的。
- 没有定义任何构造函数。
- 没有类内初始值。
- 没有基类，也没有virtual函数。

```C++
// 这是一个聚合类
struct Data {
  int ival;
  string s;
};
```

我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员：

```c++
// val1.ival = 0; val1.s = string("Anna")
Data val1 = {0, "Anna"};
```

初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推。

与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。

值得注意的是，显示的初始化类的对象的成员存在三个明显的缺点：

- 要求类的所有成员都是public的
- 将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。
- 添加或删除一个成员之后，所有的初始化语句都需要更新。

### 7.5.6 字面值常量类

constexpr 函数的参数和返回值必须是字面值类型。和其他类不同，字面值类型的类可能含有constexpr函数成员。

数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合以下要求，则它也是一个字面值常量类：

- 数据成员都必须是字面值类型。
- 类必须至少含有一个constexpr构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

#### constexpr 构造函数

尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。

constexpr构造函数可以声明成=default的形式。否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句）。综合这两点可知，constexpr构造函数体一般来说应该是空的。

```C++
class Debug {
public:
  constexpr Debug(bool b = true): hw(b), io(b), other(b) {}
  constexpr Debug(bool h, bool i, bool o): hw(h), io(i), other(o) {}
  constexpr bool any() { return hw || io || other; }
  void set_io(bool b) { io = b; }
  void set_hw(bool b) { hw = b; }
  void set_other(bool b) { other = b; }

private:
  bool hw;
  bool io;
  bool other;
};
```

constexpr 构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。

constexpr 构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型。

## 7.6 类的静态成员

有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。

### 7.6.1 静态成员概述

#### 声明静态成员

我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态成员的类型可以是常量、引用、指针、类类型等。

```C++
class Account {
public:
  void calculate() { amount += amount * interestRate; }
  static double rate() { return interestRate; }
  static void rate(double);
private:
  std::string owner;
  double amount;
  static double interestRate;
  static double initRate();
};
```

类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。

类似的，静态成员函数也不与任何对象绑定在一起，他们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。这一限制既适用于this的显示使用，也对调用非静态成员的隐式使用有效。

#### 使用类的静态成员

我们使用作用域运算符直接访问静态成员：

```C++
double r;
r = Account::rate();
```

虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员：

```C++
Account ac1;
Account *ac2 = &ac1;
r = ac1.rate();
r = ac2->rate();
```

成员函数不用通过作用域运算符就能直接使用静态成员：

```C++
class Account {
public:
  void calculate() { amount += amount * interestRate; }
private:
  static double interestRate;
}
```

#### 定义静态成员

和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句：

> 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。

因为静态数据成员不属于类的任何一个对象，所以他们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。

类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。

我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字：

```C++
double Account::interestRate = initRate();
```

这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以访问类Account中的所有成员。

#### 静态成员的类内初始化

通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以他们能用在所有适合于常量表达式的地方。

```C++
class Account {
public:
  static double rate() { return interestRate; }
  static void rate(double);
private:
  static constexpr int period = 30;
  double daily_tbl[period];
};
```

如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr static不需要分别定义。相反，如果我们将它用于值不能替换的场景中，则该成员必须有一条定义语句。

例如：如果period的唯一用途就是定义daily_tbl的维度，则不需要在Account外面专门定义period。此时，如果我们忽略了这条定义，那么对程序非常微小的改动也可能造成编译错误，因为程序找不到该成员的定义语句。举个例子，当需要把Account::period传递给一个接受const int&的函数时，必须定义period。

如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了：

```C++
constexpr int Account::period; // 初始值在类的定义内提供
```

> 即使一个常量静态数据成员在类的内部被初始化了，通常情况下也应该在类的外部定义一下该成员。

####  静态成员能用于某些场景，而普通成员不能

某些非静态数据成员可能非法的场合，静态成员却可以正常使用。

静态数据成员可以是不完全类型。特别的，静态数据成员的类型可以就是他所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用：

```C++
class Bar {
public:
  // ...
private:
  static Bar mem1; // 正确： 静态成员可以是不完全类型
  Bar *mem2; // 正确： 指针成员可以是不完全类型
  Bar mem3;  // 错误：数据成员必须是完全类型
}
```

静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参：

```C++
class Screen {
public:
  // bkground 表示一个在类中稍后定义的静态成员
  Screen& clear(char = bkground);
private:
  static const char bkground;
};
```

非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。

## 7.7 总结

1. 成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部。

2. 定义在类内部的函数是隐式的inline函数

3. 成员函数通过一个名为**this**的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。

   ```C++
   total.isbn()
   // 编译器负责把total的地址传递给isbn的隐士形参this，可以认为编译器将该调用重写成了如下的形式
   Sales_data::isbn(&total)
   ```

4. 任何对类成员的直接访问都被看作this的隐式调用

5. 对于我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或变量的行为都是非法的

6. 紧随参数列表之后的const关键字的作用是修改隐式this指针的类型。

7. 默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales_data成员函数中，this的类型是Sales_data *const。这意味着（在默认情况下）我们不能把this绑定到一个常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。

8. 如果我们把this声明成const Sales_data *const，则可以提高函数的灵活性。

9. 所以，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称为**常量成员函数**。

10. 因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容

11. 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体内可以随意使用类中的其他成员而无须在意这些成员出现的次序。

12. 如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员名字必须包含它所属的类名。

13. 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数

14. 构造函数没有返回类型，类可以包含多个构造函数。

15. 构造函数不能被声明成const的，当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。

16. 类通过默认构造函数控制默认初始化过程。默认构造函数无须任何实参。

17. 如果我们的类没有显式的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数

18. 默认构造函数初始化类的数据成员的规则如下：

    - 如果存在类内的初始值，用它来初始化成员。
    - 否则，默认初始化该成员。

19. 某些类不能依赖于合成的默认构造函数

20. 定义默认构造函数： = default

21. 冒号和花括号之间的部分称为**构造函数初始值列表**，它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。

22. 在C++语言中，我们使用**访问说明符**加强类的封装性

23. 一个类包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。

24. 使用class和struct定义类的唯一区别是，struct和class的默认访问权限不太一样

25. 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的**友元**

26. 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限

27. 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。

28. 除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名

29. 用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别。因此，类型成员通常出现在类开始的地方

30. 我们可以在类的内部把inline作为声明的一部分显式的声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义

31. 和非成员函数一样，成员函数也可以被重载，只要在函数之间的参数的数量或类型上有所区别就行

32. 有时我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点

33. 一个**可变数据成员**永远不会是const，即使它是const对象的成员

34. 若某个成员是个可变成员，则任何成员函数，包括const函数在内都能改变它的值。

35. 当我们提供一个类内初始值时，必须以符号=或者花括号表示。

36. 一个const成员函数如果以引用的形式返回*this，那么他的返回类型将是常量引用

37. 通过区分成员函数是否是const的，我们可以对其进行重载

38. 每个类定义了唯一的类型。对于两个类来说，即使他们的成员完全一样，这两个类也是两个不同的类型

39. 对于类型Screen来说，在它声明之后定义之前是一个不完全类型

40. 不完全类型只能在非常有限的情境下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。

41. 必须要注意的一点是，友元关系不存在传递性

42. 要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系

43. 如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明

44. 即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的。类内的友元声明并非普通意义上的声明，还需要在类外进行声明。

45. 一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体

46. 另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外

47. 声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见

48. 然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字

49. 成员函数中使用的名字按照如下方式解析：

    - 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。
    - 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。
    - 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。

50. 如果没有在构造函数的初始值列表中显示的初始化成员，则该成员将在构造函数体之前执行默认初始化

51. 有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样，构造函数的初始值有时必不可少

52.  如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。

53. 随着构造函数体一开始执行，初始化就完成了，常量对象便具有了“常量属性”。

54. 成员的初始化顺序与他们在类定义中的出现顺序一致，构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序

55. 如果可能的话，最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是我们可以不必考虑成员的初始化顺序。

56. 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数

57. 委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程

58. 通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则

59. 编译器只会自动的执行一步类类型转换

60. 在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为**explicit**加以阻止

61. 只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复

62. explicit 构造函数只能用于直接初始化，而不能用于拷贝初始化

63. 我们通过在成员的声明之前加上关键字static使得其与类关联在一起

64. 静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针

65. 成员函数不用通过作用域运算符就能直接使用静态成员

66. 我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句

67. 通常我们不在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。

68. 即使一个常量静态数据成员在类的内部被初始化了，通常情况下也应该在类的外部定义一下该成员

69. 静态数据成员可以是不完全类型。特别的，静态数据成员的类型可以就是他所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用

70. 静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参

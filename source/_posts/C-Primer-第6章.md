---
title: C++ Primer 第6章 函数
seo_title: C++ Primer 第6章 函数
toc: true
indent: true
comments: true
archive: true
cover: true
mathjax: false
pin: false
top_meta: true
bottom_meta: true
sidebar:
  - toc
icons: []
references:
  - title: C++ Primer
date: 2021-11-27 23:23:11
updated: 2021-11-27 23:23:11
categories:
- C++基础知识
keywords: 函数
description: C++语言的函数
headimg: https://cdn.pkubailu.cn/img/第6章封面.png
thumbnail:
tags:
- C++基础
---

{% note info:: 第 6 章 函数 %}

# 第6章 函数

## 6.1 函数基础

### 6.1.0 形参列表与返回类型

函数有几个形参，我们就必须提供相同数量的实参。

#### 函数的形参列表

```C++
void f1(){} // 隐式地定义空形参列表
void f2(void) {} // 显式的定义空形参列表
```

#### 函数返回类型

函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。

### 6.1.1 局部对象

#### 自动对象

我们把只存在于块执行期间的对象称为自动对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

#### 局部静态对象

可以将局部变量定义成static类型从而获得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对他有影响。

如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。

### 6.1.2 函数声明

函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称为**函数原型**

> Note! 含有函数声明的头文件应该被包含到定义函数的原文件中。

## 6.2 参数传递

### 6.2.3 const形参和实参

和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。

调用fcn函数时，既可以传入const int也可以传入int。忽略掉形参的顶层const可能产生意想不到的结果:

```C++
void fcn(const int i) { // fcn 能够读取i，但是不能向i写值 }
void fcn(int i) {} // 错误：重复定义了fcn(int)
```

当重载函数fcn时发生错误，因为顶层const被忽略掉了，所以在上面的代码中传入两个fcn函数的参数可以完全一样，所以第二个fcn是错误的。

#### 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

### 6.2.4 数组形参

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：

1. 不允许拷贝数组
2. 使用数组时（通常）会将其转换成指针

尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：

```C++
// 尽管形式不同，但这三个print函数是等价的
// 每个函数都有一个const int*类型的形参
void print(const int*);
void print(const int[]); // 可以看出来，函数的意图是作用于一个数组
void print(const int[10]); // 这里的维度表示我们期望数组含有多少元素，实际不一定
```

> Warning! 和其他使用数组的代码一样，以数组为形参的函数也必须确保使用数组时不会越界。

#### 使用标记指定数组长度

管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。

```C++
void print(const char *cp) {
  if(cp){  // 若cp不是一个空指针
    while(*cp){ // 只要指针所指的字符不是空字符
      cout << *cp++;
    }
  }
}
```

#### 使用标准库规范

管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库的启发。

```C++
void print (const int *beg, const int *end) {
  while(beg != end) {
    cout << *beg++;
  }
}
```

#### 显示传递一个表示数组大小的形参

第三种管理数组实参的方法是专门定义一个表示数组大小的形参。

```C++
// const int ia[] 等价于const int *ia
// size 表示数组的大小
void print(const int ia[],size_t size) {
  for (size_t i = 0; i < size; ++i) {
    cout << ia[i];
  }
}
```

#### 数组形参和const

三个print函数都把数组形参定义成了指向const的指针。当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。

#### 数组引用形参

形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上。

```C++
// 正确： 形参是数组的引用，维度是类型的一部分
void print(int (&arr)[10]) {
  for (auto elem : arr)
    cout << elem;
}
```

> **&arr 两端的括号必不可少**
>
> **f(int &arr[10])  // 错误： 将arr声明成了引用的数组**
>
> **f(int (&arr)[10])  //正确： arr是具有10个整数的整型数组的引用**

但是，这一用法也无形中限制了print函数的可用性，我们只能将函数作用于大小为10的数组。

#### 传递多维数组

```C++
void print(int (*matrix)[10], int rowSize) {}
// 上述语句将 matrix 声明成指向含有10个整数的数组的指针
```

> Note!
>
> **\*matrix 两端的括号必不可少：**
>
> **int *matrix[10]; // 10个指针构成的数组**
>
> **int (*matrix)[10]; // 指向含有10个整数的数组的指针**

```C++
void print(int matrix[][10], int rowSize) {}
```

matrix 的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。

### 6.2.5 main: 处理命令行选项

```C++
int main(int argc, char *argv[]) {}
```

第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。

当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

```C++
// 当命令行输入
prog -d -o ofile data0
// argv 应该包含如下的C风格字符串：
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

**当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入。**

#### 6.2.6 含有可变形参的函数

#### initializer_list 形参

如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。

![](https://cdn.pkubailu.cn/img/6.1.png)

和vector一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型：

```C++
initializer_list<string> ls; // initializer_list 的元素类型是string
initializer_list<int> li; // initializer_list的元素类型是int
```

和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法修改其中的值。

```C++
void error_msg(initializer_list<string> ls) {
  for (auto beg = ls.begin(); beg != ls.end(); ++beg)
    cout << *beg << endl;
}
// 想向initializer_list形参中传递一个值序列，则必须把序列放在一对花括号内
// expected和actual是string对象
if (expected != actual)
  error_msg({"functionX", expected, actual});
else
  error_msg({"functionX", "okay"})
```

#### 省略符形参

**省略符形参应该仅仅用于C和C++通用的类型。特别注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝**

省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：

```C++
void foo(parm_list,...);
void foo(...);
```

第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参所对应的实参无需类型检查。

## 6.3 返回类型和 return 语句

### 6.3.2 有返回值函数

#### 不要返回局部对象的引用或指针

函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域：

```C++
const string &manip() {
  string ret;
  if (!ret.empty())
    return ret;  // 错误：返回局部对象的引用！
  else
    return "Empty"; // 错误： "Empty"是一个局部临时变量
}
```

第一条return 语句来说，显然它返回的是局部对象的引用。

第二条return 语句中，字符串字面值转换成一个局部临时string对象，该对象和ret一样都是局部的。

### 6.3.3 返回数组指针

#### 声明一个返回数组指针的函数

```C++
int arr[10]; //arr 是一个含有10个整数的数组
int *p1[10]; // p1是一个含有10个指针的数组
int (*p1)[10]; // p2 是一个指针，它指向含有10个整数的数组
```

和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：

```c++
Type (*function(parameter_list))[dimension]
// (*function(parameter_list))两端的括号必须存在。
```

具体的例子：

```C++
int (*func(int i))[10];
```

可以按照以下的顺序来逐层理解该声明的含义：

- func(int i) 表示调用func函数时需要一个int类型的实参。
- (*func(int i)) 意味着我们可以对函数调用的结果执行解引用操作
- (*func(int i))[10] 表示解引用func的调用将得到一个大小为10的数组
- int (*func(int i))[10] 表示数组中的元素是int类型

#### 使用尾置返回类型

简化上述func声明的方法，还可以使用**尾置返回类型**。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto:

```C++
// func 接受一个int 类型的实参，返回一个指针，该指针指向含有10个整数的数组
auto func(int i) -> int(*)[10];
```

因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。

#### 使用 decltype

如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。

```C++
int odd[] = {1,3,5,7,9};
int event[] = {0,2,4,6,8};
// 返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i){
  return (i % 2) ? &odd : &even; //返回一个指向数组的指针
}
```

因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个*符号。

## 6.4 函数重载

如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为**重载函数**。

### 6.4.0 重载基础

#### 定义重载函数

对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外其他所有的要素都相同。

#### 判断两个形参的类型是否相异

有时候两个形参列表看起来不一样，但实际上是相同的：

```C++
// 声明的是同一个函数
Record lookup(const Account &acct);
Record lookup(const Account &);  // 省略了形参的名字
```

#### 重载和const形参

顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：

```C++
Record lookup(Phone);
Record lookup(const Phone);

Record lookup(Phone*);
Record lookup(Phone* const);
```

另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：

```C++
// 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同
// 定义了4个独立的重载函数
Record lookup(Account &); // 函数作用于Account的引用
Record lookup(const Account &); // 新函数，作用于常量引用

Record lookup(Account *); // 新函数，作用于指向Account的指针
Record lookup(const Account *); // 新函数，作用于指向常量的指针
```

#### const_cast 和重载

const_cast 在重载函数的情景中最有用。举个例子：

```C++
// 比较两个string对象的长度，返回较短的那个引用
const string &shorterString(const string &s1, const string &s2){
  return s1.size() <= s2.size() ? s1 : s2;
}
```

这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string 的引用。因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点：

```C++
string &shorterString(string &s1, string &s2){
  auto &r = shorterString(const_cast<const string&>(s1),const_cast<const string&>(s2));
  return const_cast<string&>r;
}
```

在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的string&，这显然是安全的。

#### 调用重载的函数

调用重载函数时有三种可能的结果：

- 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。
- 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。
- 有多余一个函数可以匹配，但是每一个都不是最明显的最佳选择。此时也将发生错误，成为二义性调用。

### 6.4.1 重载与作用域

重载对作用域的一般性质并没有什么改变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。

> Note! 在C++语言中，名字查找发生在类型检查之前。

## 6.5 特殊用途语言特性

### 6.5.1 默认实参

我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，他后面的所有形参都必须有默认值。

```C++
typedef string::size_type sz;
string screen(sz ht = 24, sz wid = 80, char background = ' ');
```

函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参，例如：要想覆盖background的默认值，必须为ht和wid提供实参：

```C++
window = screen(,,'?'); // 错误：只能省略尾部的实参
window = screen('?'); // 调用screen('?',80,' ')
```

当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。

#### 默认实参声明

一个函数通常只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值得形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

```C++
string screen(sz,sz,char = '');
string screen(sz,sz,char = '*'); // 错误：重复声明
// 但是可以按照如下形式添加默认实参：
string screen(sz = 24, sz = 80, char); //正确：添加默认实参
```

#### 默认实参初始值

局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：

```C++
// wd、def、ht的声明必须出现在函数之外
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);
string window = screen(); //调用 screen(ht(),80,' ')
```

用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：

```C++
void f2(){
  def = '*'; // 改变默认实参的值
  sz wd = 100; // 隐藏了外层定义的wd，但是没有改变默认值
  window = screen(); // 调用了screen(ht(),80,'*');
}
```

### 6.5.2 内联函数和 constexpr 函数

#### 内联函数可避免函数调用的开销

将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。

假设我们把shorterString函数定义成内联函数，则如下调用

```C++
cout << shorterString(s1,s2) << endl;
```

将在编译过程中展开成类似下面的形式

```C++
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
```

从而消除了shorterString函数的运行时开销。

在shorterString函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了:

```C++
inline const string &
shorterString(const string &s1, const string &s2){
  return s1.size() < s2.size() ? s1 : s2;
}
```

一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。

#### constexpr 函数

constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：

```C++
constexpr int new_sz() {return 42;}
constexpr int foo = new_sz(); // 正确： foo是一个常量表达式
```

执行该初始化任务时，编译器把对constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐士地指定为内联函数。

我们允许constexpr函数的返回值并非一个常量：

```C++
// 如果arg是常量表达式，则scale(arg)也是常量表达式
constexpr size_t scale(size_t cnt) {return new_sze() * cnt; }
// 当scale的实参是常量表达式时，它的返回值也是常量表达式：反之则不然：
int arr[scale(2)]; // 正确： scale(2)是常量表达式
int i = 2; // i 不是常量表达式
int a2[scale(i)] // 错误：scale(i)不是常量表达式
```

> Note! constexpr 函数不一定返回常量表达式

#### 把内联函数和constexpr 函数放在头文件内

对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。

### 6.5.3 调试帮助

#### assert 预处理宏

assert是一种预处理宏。所谓预处理宏其实是一个预处理变量，他的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：

```C++
assert(expr);
```

首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。

和预处理变量一样，宏名字在程序内必须唯一。含有cassert头文件的程序不能再定义名为assert的变量、函数或者其他实体。在实际编译过程中，即使我们没有包含cassert头文件，也最好不要为了其他目的使用assert。很多头文件都包含了cassert，这就意味着即使你没有直接包含cassert，它也很有可能通过其他途径包含在你的程序中。

```C++
// assert宏常用于检查“不能发生”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时，程序可以包含一条如下所示的语句：
assert(word.size() > threshold)；
```

#### NDEBUG预处理变量

assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。

我们可以使用一个#define 语句定义NDEBUG，从而关闭调试状态。

除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码：如果定义了NDEBUG，这些代码将被忽略。

## 6.6 函数匹配

### 6.6.0 寻找匹配方法

#### 确定候选函数和可行函数

1. 选定本次调用对应的重载函数集。
2. 考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数。
3. 从候选函数中选择与本次调用最匹配的函数。

#### 寻找最佳匹配（如果有的话）

基本思想是：实参类型与形参类型越接近，他们匹配的越好。

> Note! 调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

### 6.6.1 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级。

1. 精确匹配，包括以下情况：
   - 实参类型和形参类型相同。
   - 实参从数组类型或函数类型转换成对应的指针类型。
   - 向实参添加顶层const或者从实参中删除顶层const。
2. 通过const转换实现的匹配。
3. 通过类型提升实现的匹配。
4. 通过算术类型转换或指针转换实现的匹配。
5. 通过类类型转换实现的匹配。

#### 函数匹配和const实参

```C++
Record lookup(Account&);
Record lookup(const Account&);
const Account a;
Account b;

lookup(a); // 调用lookup(const Account&)
lookup(b); // 调用lookup(Account&)
```

在第一个调用中，我们传入的是const 对象a。因为不能把普通引用绑定到const对象上，所以此例中唯一可行的函数是以常量引用作为形参的那个函数。

在第二个调用中，两个函数都是可行的，因为我们既可以使用b初始化常量引用也可以用它初始化非常量引用。然而，用非常量对象初始化常量引用需要类型转换。

指针也同样如此！

## 6.7 函数指针

### 6.7.1 函数指针

函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参共同决定，与函数名无关。

```C++
// 比较两个string对象的长度
bool lengthCompare(const string &,const string &);
```

该函数的类型是bool（const string&, const string&）。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：

```C++
// pf 指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型
bool (*pf) (const string &,const string &); // 未初始化
```

从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。

> Note! *pf 两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数。

#### 使用函数指针

当我们把函数名作为一个值使用时，该函数自动的转换成指针。例如，按照如下形式我们可以将lengthCompare的地址赋给pf：

```C++
pf = lengthCompare; // pf 指向名为lengthCompare的函数
pf = &lengthCompare; // 等价的赋值语句：取地址符是可选的
```

此外，我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针：

```C++
bool b1 = pf("hello","goodbye"); // 调用lengthCompare函数
bool b2 = (*pf)("hello","goodbye"); // 一个等价的调用
bool b3 = lengthCompare("hello","goodbye"); // 另一个等价的调用
```

在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何一个函数。

```C++
string::size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0; // 正确：pf不指向任何函数
pf = sumlength; // 错误：返回类型不匹配
pf = cstringCompare; // 错误：形参类型不匹配
pf = lengthCompare; // 正确：函数和指针的类型精确匹配
```

#### 重载函数的指针

当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。如果定义了指向重载函数的指针

```C++
void ff(int*);
void ff(unsigned int);

void (*pf1)(unsigned int) = ff; // pf1 指向 ff(unsigned)
```

编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配

```C++
void (*pf2)(int) = ff; // 错误：没有任何一个ff与该形参列表匹配
double (*pf3)(int*) = ff; // 错误： 返回类型不匹配
```

#### 函数指针形参

和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用：

```C++
// 第三个形参是函数类型，它会自动地转换成指向函数的指针
void useBigger(const string &s1, const string &s2, bool pf(const string &, const string &));
// 等价的声明：显示的将形参定义成指向函数的指针
void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &));
// 我们可以直接把函数作为实参使用，此时它会自动转换成指针：
useBigger(s1,s2,lengthCompare);
```

正如useBigger的声明语句所示，直接使用函数指针类型显得冗余而繁琐。类型别名和decltype能让我们简化使用了函数指针的代码：

```C++
// Func 和 Func2 是函数类型
typedef bool Func(const string&, const string&);
typedef decltype(lengthCompare) Func2; // 等价的类型
// FuncP 和 FuncP2 是指向函数的指针
typedef bool(*FuncP)(const string&, const string&);
typedef decltype(lengthCompare) *FuncP2; // 等价的类型
// 因为 decltype 的结果是函数类型，所以只有在结果前面加上*才能得到指针。
```

```C++
// useBigger 的等价声明，其中使用了类型别名
void useBigger(const string&, const string&, Func);
void useBigger(const string&, const string&, FuncP2);
```

这两个声明语句声明的是同一个函数，在第一条语句中，编译器自动的将 Func 表示的函数类型转换成指针。

#### 返回指向函数的指针

和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而， 我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要向声明一个返回函数指针的函数，最简单的办法是使用类型别名：

```C++
using F = int(int*, int); // F是函数类型，不是指针
using PF = int(*)(int*, int); // PF是指针类型
```

必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针，我们必须显示的将返回类型指定为指针：

```C++
PF f1(int); // 正确： PF 是指向函数的指针，f1返回指向函数的指针
F f1(int); // 错误：F是函数类型，f1不能返回一个函数
F *f1(int); // 正确：显示的指定返回类型是指向函数的指针
```

当然，我们也能用下面的形式直接声明f1:

```C++
int (*f1(int))(int*, int);
// 按照由内向外的顺序阅读这条声明语句：我们看到f1有形参列表，所以f1是一个函数：f1前面有*，所以f1返回一个指针，进一步观察发现，指针的类型本身也含有形参列表，因此指针指向函数，该函数的返回类型是int
```

我们还可以使用尾置返回类型的方式

```C++
auto f1(int) -> int (*)(int*, int);
```

#### 将auto和decltype用于函数指针类型

如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。

```C++
string::size_type sumLength(const string&, const string&);
string::size_type largeLength(const string&, const string&);
// 根据其形参的取值，getFcn函数返回指向 sumLength 或者 largeLength的指针
decltype(sumLength) *getFcn(const string &);
```

声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。因此，我们需要显示的加上*以表明我们需要返回指针。

## 6.8 总结

1. 函数有几个形参，我们就必须提供相同数量的实参

2. 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针

3. 可以将局部变量定义成static类型从而获得局部静态对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。

4. 如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0

5. 和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了

6. 尽量使用常量引用

7. 数组形参

   ```C++
   // 尽管形式不同，但这三个print函数是等价的
   // 每个函数都有一个const int*类型的形参
   void print(const int*);
   void print(const int[]); // 可以看出来，函数的意图是作用于一个数组
   void print(const int[10]); // 这里的维度表示我们期望数组含有多少元素，实际不一定
   ```

8. 管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。

9. 管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库的启发。

10. 第三种管理数组实参的方法是专门定义一个表示数组大小的形参。

11. 当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针

12. 形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上

13. 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入

14. 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。

15. 和vector一样，initializer_list也是一种模板类型。和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法修改其中的值。

16. 省略符形参应该仅仅用于C和C++通用的类型。特别注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝

17. 省略符形参只能出现在形参列表的最后一个位置，省略符形参所对应的实参无需类型检查。

18. 不要返回局部对象的引用或指针

19. 声明返回数组指针的函数

    ```C++
    int (*func(int i))[10];
    ```

    可以按照以下的顺序来逐层理解该声明的含义：

    - func(int i) 表示调用func函数时需要一个int类型的实参。
    - (*func(int i)) 意味着我们可以对函数调用的结果执行解引用操作
    - (*func(int i))[10] 表示解引用func的调用将得到一个大小为10的数组
    - int (*func(int i))[10] 表示数组中的元素是int类型

20. 简化上述func声明的方法，还可以使用**尾置返回类型**。

    ```C++
    // func 接受一个int 类型的实参，返回一个指针，该指针指向含有10个整数的数组
    auto func(int i) -> int(*)[10];
    ```

21. 如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。

22. 如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为**重载函数**。

23. 顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来

24. 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同

25. 如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。

26. 我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，他后面的所有形参都必须有默认值

27. 函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。而且只能省略尾部的实参。

28. 一个函数通常只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值得形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

29. 局部变量不能作为默认实参

30. 用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时

31. 将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。内联函数可避免函数调用的开销。

32. 在shorterString函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了

33. constexpr函数定义：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句

34. 在编译过程中，constexpr函数被隐士地指定为内联函数。

35. 对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。

36. 精确匹配，包括以下情况：

    - 实参类型和形参类型相同。
    - 实参从数组类型或函数类型转换成对应的指针类型。
    - 向实参添加顶层const或者从实参中删除顶层const。

    通过const转换实现的匹配。

    通过类型提升实现的匹配。

37. 函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参共同决定，与函数名无关。

38. 当我们把函数名作为一个值使用时，该函数自动的转换成指针

39. 此外，我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针

40. 在指向不同函数类型的指针间不存在转换规则

41. 和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针

42. 和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而， 我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理

---
title: C++ Primer 第3章 字符串、向量和数组
seo_title: C++ Primer 第3章 字符串、向量和数组
toc: true
indent: true
comments: true
archive: true
cover: true
mathjax: false
pin: false
top_meta: true
bottom_meta: true
sidebar:
  - toc
icons: []
references:
  - title: C++ Primer
date: 2021-11-13 19:51:59
updated: 2021-11-13 19:51:59
categories:
- C++基础知识
keywords: 字符串 向量 数组
description: C++语言的字符串、向量和数组
headimg: https://cdn.pkubailu.cn/img/第3章封面.png
thumbnail:
tags:
- C++基础
---

{% note info:: 第3章 字符串、向量和数组 %}

# 第3章 字符串、向量和数组

## 3.1 命名空间的using声明

有了using声明就无需专门的前缀（形如命名空间::）也能使用所需的名字了。

using声明具有如下的形式：

```c++
using namespace::name;
// 一旦声明了上述语句，就可以直接访问命名空间中的名字
```

> WARNING **!头文件不应包含using声明**

## 3.2 标准库类型 string

### 3.2.1 定义和初始化string对象

![image-20211115175652876](https://cdn.pkubailu.cn/img/3.1.png)

#### 直接初始化和拷贝初始化

如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化。

### 3.2.2 string对象上的操作

![image-20211115180215371](https://cdn.pkubailu.cn/img/3.2.png)

#### 读写string对象

```c++
int main()
{
  string s;
  cin >> s;
  cout << s << endl;
  return 0;
}
// 在执行读取操作时，string对象会自动忽略开头的空白（即空格、换行、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。
// 如果输入是"    hello world!    "则输出将是"hello"
```

#### 使用getline读取一整行

如果希望在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的 >> 运算符。

getline从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，如果一开始输入的是换行符，那么所得的结果是个空string。

#### 比较 string 对象

字典序规则！

### 3.2.3 处理string对象中的字符

![image-20211115191804174](https://cdn.pkubailu.cn/img/3.3.png)

#### 处理每个字符？使用基于范围的for语句

语法形式：

```c++
for (declaration : expression)
  statement
```

## 3.3 标准库类型 vector

编译器根据模板创建类或函数的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

> vector 是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>

### 3.3.1 定义和初始化vector对象

![image-20211119003835476](https://cdn.pkubailu.cn/img/3.4.png)

#### 列表初始化vector对象

在大多数情况下这些初始化方式可以相互等价的使用，不过也并非一直如此。两种例外情况如下：

1. 使用拷贝初始化时（即使用=时）只能提供一个初始值；
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。

第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化。

#### 值初始化

通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个**值初始化的**元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。

```C++
vector<int> ivec(10); //10个元素 每个都初始化为0
vector<string> svec(10) // 10个元素，每个都是空的string对象
```

对这种初始化的方式有两个特殊限制：

1. 有些类要求必须明确的提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始化的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。
2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化：

```C++
vector<int> vi = 10; // 错误：必须使用直接初始化的形式指定向量大小
```

#### 列表初始值还是元素数量

![image-20211121004224917](https://cdn.pkubailu.cn/img/列表初始值还是元素数量1.png)

![image-20211121004346187](https://cdn.pkubailu.cn/img/列表初始值还是元素数量2.png)

### 3.3.2 向vector对象中添加元素

可以先创建一个空的vector对象，然后在运行时再利用vector的成员函数**push_back**向其中添加元素。

>! 范围for语句体内不应该改变其所遍历序列的大小。

### 3.3.3 其他vector操作

![image-20211121005240108](https://cdn.pkubailu.cn/img/3.5.png)

> Note：要使用size_type，需要先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型
>
> ```C++
> vector<int>::size_type  // 正确
> vector::size_type  // 错误
> ```

两个vector对象相等当且仅当他们所含的元素个数相同，而且对应位置的元素值也相同。

关系运算符依照字典顺序进行比较：如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。

只有当元素的值可比较时，vector对象才能被比较。

## 3.4 迭代器介绍

有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

### 3.4.1 使用迭代器

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。这些类型都拥有名为**begin**和**end**的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器，end成员则负责返回指向容器”尾元素的下一位置“的迭代器，简称为尾迭代器。

#### 迭代器运算符

![3.6](https://cdn.pkubailu.cn/img/3.6.png)

#### 将迭代器从一个元素移动到另外一个元素

迭代器使用递增（++）运算符来从一个元素移动到下一个元素。

> Note：因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。

#### 迭代器类型

迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型

![迭代器类型](https://cdn.pkubailu.cn/img/迭代器类型.png)

const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。

#### begin和end运算符

```C++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1 的类型是vector<int>::iterator
auto it2 = cv.begin(); // it2 的类型是vector<int>::const_iterator
```

为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend：

```C++
auto it3 = v.cbegin(); // it3 的类型是vector<int>::const_iterator
```

不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。

#### 结合解引用和成员访问操作

```C++
(*it).empty() // 解引用it，然后调用结果对象的empty()成员
*it.empty()  //错误： 试图访问it的名为empty的成员，但it是个迭代器，没有empty成员
```

为了简化上述表达式，C++语言定义了**箭头运算符**(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说it->mem和(*it).mem表达的意思相同。

#### 某些对vector对象的操作会使迭代器失效

>**谨记！，但凡是使用了迭代器的循环体，都不要向迭代其所属的容器添加元素。**

### 3.4.2 迭代器运算

![3.7](https://cdn.pkubailu.cn/img/3.7.png)

#### 迭代器的算术运算

对于string或vector的迭代器来说，除了判断是否相等，还能使用关系运算符(<、<=、>、>=)对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（或者尾元素的下一位置）。例如，假设it和mid是同一个vector对象的两个迭代器，可以用下面的代码来比较他们所指的位置谁前谁后：

```C++
if (it < mid)
	// 处理vector前半部分的元素
```

## 3.5 数组

### 3.5.1 定义和初始化内置数组

默认情况下，数组的元素被默认初始化

> Warning! 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

#### 显示初始化数组

![显示初始化数组](https://cdn.pkubailu.cn/img/显示初始化数组.png)

#### 字符数组的特殊性

![字符数组的特殊性](https://cdn.pkubailu.cn/img/字符数组的特殊性.png )

#### 不允许拷贝和赋值

![不允许拷贝和赋值](https://cdn.pkubailu.cn/img/不允许拷贝和赋值.png )

#### 理解复杂的数组声明

定义数组的指针和数组的引用：

![数组的指针和数组的引用](https://cdn.pkubailu.cn/img/数组的指针和数组的引用.png )

对于数组而言，由内向外阅读要比从右向左好多了。例如：首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。

### 3.5.2 访问数组元素

最好的办法是使用范围for语言。

使用数组下标的时候，通常将其定义为**size_t**类型。

数组除了大小固定这一特点外，其他用法与vector基本类似。

### 3.5.3 指针和数组

> Note： 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

这一结论有很多隐含的意思：

1. 当使用数组作为一个auto变量的初始值时。推断得到的类型是指针而非是数组：

```C++
int ia[] = {0,1,2,3,4}; // ia 是一个含有5个整数的数组
auto ia2(ia); // ia2是一个整型指针,指向ia的第一个元素
ia2 = 42; // 错误：ia2是一个指针，不能用int值给指针赋值
```

必须指出的是，当使用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组：

```C++
// ia3 是一个含有5个整数的数组
decltype(ia) ia3 = {0,1,2,3,4};
ia3 = p; // 错误：不能用整形指针给数组赋值
ia3[4] = i; //正确：把i的值赋给ia3的一个元素
```

#### 指针也是迭代器

允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

```C++
int arr[] = {0,1,2,3,4};
int *p = arr; // p指向arr的第一个元素
++p; // p指向arr[1]
```

利用指针的循环

```C++
int *e = &arr[10];
for (int *b = arr; b != e; ++b)
  cout << *b <<endl;
```

#### 标准库函数begin和end

C++新标准引入了两个名为begin和end的函数

```C++
int ia[] = {0,1,2,3,4}; // ia是一个含有5个整数的数组
int *beg = begin(ia); //指向ia首元素的指针
int *last = end(ia); // 指向arr尾元素的下一位置的指针
```

>Note：一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。

#### 指针运算

指向数组元素的指针可以执行所有的迭代器运算。例如：解引用、递增、比较、与整数相加、两个指针相减等。

给指针加（减）一个整数，得到的新指针仍需要指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置。

```C++
//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置
int *p = arr + sz; //使用警告:不要解引用！
int *p2 = arr + 10; // 错误：arr只有5各元素，p2的值未定义
// 如果计算所得的指针超出了上述范围就将产生错误，而且这种错误编译器一般发现不了。
```

如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针也允许彼此相减，结果当然是0；

#### 解引用和指针运算的交互

```C++
int ia[] = {0,2,4,,6,8}; //含有5个整数的数组
int last = *(ia + 4); //正确：把last初始化成8，也就是ia[4]的值
```

#### 下标和指针

对数组执行下标运算其实是对指向数组元素的指针执行下标运算：

```C++
int i = ia[2]; //ia转换成指向数组首元素的指针
							//ia[2]得到(ia + 2)所指的元素
int *p = ia; // p指向ia的首元素
i = *(p + 2) // 等价于i = ia[2]
```

只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：

```c++
int *p = &ia[2]; // p指向索引为2的元素
int j = p[1]; // p[1]等价于 *(p+1),就是ia[3]表示的那个元素
int k = p[-2]; // p[-2]是ia[0]表示的那个元素
```

虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。

> 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。

### 3.5.4 C风格字符串

#### C标准库String函数

![C风格字符串函数](https://cdn.pkubailu.cn/img/3.8.png )

传入此类函数的指针必须指向以空字符作为结束的数组：

```C++
char ca[] = {'c','+','+'};  // 不以空字符结束
cout << strlen(ca) << endl; // 严重错误：ca没有以空字符结束
```

#### 比较字符串

比较C风格的字符串和比较标准库string对象的方法大相径庭。

string对象的比较可以用关系运算符，而C风格字符串用关系运算符比较的是指针所指对象的地址。

```C++
string s1 = "A string example";
string s2 = "A different example";
if (s1 < s2) // false: s2 小于 s1
const char ca1[] = "A string example";
const char ca2[] = "A different example";
if (ca1 < ca2) // 未定义的：试图比较两个无关地址
```

### 3.5.5 与旧代码的接口

#### 混用string对象和C风格字符串

允许使用字符串字面值来初始化string对象:

```c++
string s("hello world"); // s的内容是hello world
```

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：

- 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值。
- 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）;在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

**上述性质反过来不成立！**

不能使用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数:

```c++
char *str = s; //错误: 不能用string对象初始化char*
const char *str = s.c_str(); // 正确
```

#### 使用数组初始化vector对象

不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。

```c++
int int_arr[] = {0,1,2,3,4};
vector<int> ivec(begin(int_arr), end(int_arr));
```

在上述代码中，用于创建ivec的两个指针实际上指明了用来初始化的值在数组int_arr中的位置，其中第二个指针应指向待拷贝区域尾元素的下一位置。

> 应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。

## 3.6 多维数组

C++语言中的多维数组其实是数组的数组。

```C++
size_t cnt = 0;
for (auto &row : ia) {
  for (auto &col : row) {
    col = cnt;
    cnt++;
  }
}
```

> Note! 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

### 3.6.1 指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

> Note! 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。

```C++
// 在下述声明中，圆括号必不可少
int *ip[4]; // 整型指针的数组
int (*ip)[4]; // 指向含有4个整数的数组
```

```C++
//输出ia中每个元素的值，每个内层数组各占一行
// p指向含有4个整数的数组
for (auto p = ia; p != ia + 3; ++p) {
  for (auto q = *p; q != *p + 4; ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

使用标准库函数begin和end也能实现同样的功能。

```C++
for (auto p = begin(ia); p != end(ia); ++p) {
  for (auto q = begin(*p); q != end(*p); ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

## 3.7 总结

1. 如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化。

2. 在执行读取操作时，string对象会自动忽略开头的空白（即空格、换行、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。如果输入是"    hello world!    "则输出将是"hello"

3. getline从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，如果一开始输入的是换行符，那么所得的结果是个空string。

4. String 对象的比较遵循字典序规则

5. 编译器根据模板创建类或函数的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

6. 列表初始化与值初始化：

   大多数情况下这些初始化方式可以相互等价的使用，不过也并非一直如此。两种例外情况如下：

   1. 使用拷贝初始化时（即使用=时）只能提供一个初始值；
   2. 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化。

7. 值初始化的两个特殊限制：

   1. 有些类要求必须明确的提供初始值，对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。
   2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化

8. 范围for语句体内不应该改变其所遍历序列的大小。

9. 要使用size_type，需要先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型

   ```C++
   vector<int>::size_type  // 正确
   vector::size_type  // 错误
   ```

10. 关系运算符依照字典顺序进行比较：如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。

11. 只有当元素的值可比较时，vector对象才能被比较。

12. 有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

13. 因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。

14. C++语言定义了**箭头运算符**(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说it->mem和(*it).mem表达的意思相同。

15. 谨记！，但凡是使用了迭代器的循环体，都不要向迭代其所属的容器添加元素

16. 参与比较的两个迭代器必须合法而且指向的是同一个容器的元素。通过比较可以决定两个迭代器的先后位置。

17. 默认情况下，数组的元素被默认初始化。如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值

18. 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

19. 数组不允许拷贝和赋值

20. 需要理解复杂的数组声明（3.5.1节）

21. 使用数组下标的时候，通常将其定义为**size_t**类型。

22. 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针

23. 当使用数组作为一个auto变量的初始值时。推断得到的类型是指针而非是数组

24. 当使用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组

25. 允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上

26. 指向数组元素的指针可以执行所有的迭代器运算。例如：解引用、递增、比较、与整数相加、两个指针相减等

27. 给指针加（减）一个整数，得到的新指针仍需要指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置

28. 对数组执行下标运算其实是对指向数组元素的指针执行下标运算

29. 虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。

30. 传入C风格字符串的函数的指针必须指向以空字符作为结束的数组

31. string对象的比较可以用关系运算符，而C风格字符串用关系运算符比较的是指针所指对象的地址

32. 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：

    - 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值。
    - 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）;在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

33. 不能使用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数:

    ```c++
    char *str = s; //错误: 不能用string对象初始化char*
    const char *str = s.c_str(); // 正确
    ```

34. 不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。

    ```c++
    int int_arr[] = {0,1,2,3,4};
    vector<int> ivec(begin(int_arr), end(int_arr));
    ```

35. 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型

36. 当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针

37. 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组

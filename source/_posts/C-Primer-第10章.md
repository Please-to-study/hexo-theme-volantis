---
title: C++ Primer 第10章 泛型算法
seo_title: C++ Primer 第10章 泛型算法
toc: true
indent: true
comments: true
archive: true
cover: true
mathjax: false
pin: false
top_meta: true
bottom_meta: true
sidebar:
  - toc
icons: []
references:
  - title: C++ Primer
    url: https://github.com/Please-to-study/C-Study/blob/master/C++primer.md
date: 2021-12-25 21:16:26
updated: 2021-12-25 21:16:26
categories:
- C++基础知识
keywords: 泛型算法
description: C++中的泛型算法
headimg: https://cdn.pkubailu.cn/img/第10章封面.png
thumbnail:
tags:
- C++基础
---

{% note info:: 第 10 章 泛型算法 %}

# 第10章 泛型算法

> 关键概念：泛型算法永远不会执行容器的操作，他们只会运行于迭代器之上，执行迭代器的操作。算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。

## 10.2 初识泛型算法

虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。理解算法的最基本的方法就是了解他们是否读取元素、改变元素或是重排元素。

### 10.2.1 只读算法

```C++
// 对vec中的元素求和，和的初值是0
int sum = accumulate(vec.cbegin(), vec.cend());
```

accumulate将第三个参数作为求和的起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。

> Note! accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。

```C++
// 由于string定义了+运算符，所以我们可以通过调用accumulate来将vector中所有string元素连接起来
string sum = accumulate(v.cbegin(), v.cend(), string(""));
// 错误：const char* 上没有定义+运算符
string sum = accumulate(v.cbegin(), v.cend(), "");
```

#### 操作两个序列的算法

```C++
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```

由于equal利用迭代器完成操作，因此我们可以通过调用equal来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可。例如，在此例中，roster1可以是vector<string>,而roster2是list<const char*>。

但是，equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。

> 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。

### 10.2.2 写容器元素的算法

一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此他们自身不可能改变容器的大小。

#### 算法不检查写操作

一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数fill_n接受一个迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。

```C++
vector<int> vec; // 空vector
fill_n(vec.begin(), vec.size(), 0);
// 灾难: 修改vec中的10个（不存在）元素
// 这个调用是一场灾难。我们指定了要写入10个元素，但vec中并没有元素——他是空的，这条语句的结果是未定义的。
fill_n(vec.begin(), 10, 0);
```

#### 介绍back_inserter

一种保证算法有足够元素空间来容纳输出数据的方法是使用**插入迭代器**。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器所指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。

back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。

```C++
vector<int> vec; // 空向量
fill_n(back_inserter(vec), 10, 0);
```

在每步迭代中，fill_n向给定序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。

#### 拷贝算法

拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素。

```C++
// 我们可以用copy实现内置数组的拷贝
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];
//ret 指向拷贝到a2的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2);
```

copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。

多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果。

例如，replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：

```C++
// 将所有值为0的元素改为42
replace(ilst.begin(), ilst.end(), 0, 42);
// 如果我们希望保留原序列不变，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置
replace_copy(ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42);
// 此调用后，ilst并未改变，ivec包含ilst的一份拷贝，不过原来在ilst中值为0的元素在ivec中都变为42
```

### 10.2.3 重排容器元素的算法

某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的<运算符来实现排序的。

#### 消除重复单词

为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分。由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作。

```C++
void elimDups(vector<int> &word) {
  // 按字典排序words，以便查找重复单词
  sort(word.begin(), word.end());
  // unique重排输入范围，使得每个单词只出现一次
  // 排列在范围的前部，返回指向不重复区域之后第一个位置的迭代器
  auto end_unique = unique(word.begin(), word.end());
  // 使用向量操作erase删除重复单词
  word.erase(end_unique, word.end());
}
```

#### 使用unique

![](https://cdn.pkubailu.cn/img/使用unique.png)

> 标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素

## 10.3 定制操作

很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的<或==运算符完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。

例如，sort算法默认使用元素类型的<运算符。但可能我们希望的排序顺序与<所定义的顺序不同，或是我们的序列可能保存的是未定义<运算符的元素类型（如Sales_data）。在这两种情况下，都需要重载sort的默认行为。

### 10.3.1 向算法传递函数

为了按长度重排vector，我们将使用sort的第二个版本，此版本是重载过的，他接受第三个参数，此参数是一个谓词。

#### 谓词

谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：**一元谓词**（意味着他们只接受单一参数）和**二元谓词**（意味着它们有两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。

```C++
bool isShorter(const string &s1, const string &s2) {
  return s1.size() < s2.size();
}
// 按长度由短至长排序words
sort(words.begin(), words.end(), isShorter);
```

#### 排序算法

在我们将words按大小重排的同时，还希望具有相同长度的元素按字典序排列。为了保持相同长度的单词按字典序排列，可以使用stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。

```C++
elimDups(words); // 将words按字典序重排，并消除重复单词
// 按长度重新排序，长度相同的单词维持字典序
stable_sort(words.begin(), words.end(), isShorter);
```

### 10.3.2 lambda 表达式

根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。

举个例子：求大于等于一个给定长度的单词有多少。

![](https://cdn.pkubailu.cn/img/lambda表达式.png)

#### 介绍lambda

我们可以向一个算法传递任何类别的可调用对象。对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。

到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针。还有其他两种可调用对象：重载了函数调用运算符的类，以及lambda表达式。

一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何内联函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式：

```C++
[capture list] (parameter list) -> return type {function body}
```

其中，capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）return type、parameter list、function body与任何普通函数一样，分别表示返回类型、参数列表、函数体。但是，与普通函数不同，lambda必须使用尾置返回来指定返回类型。

我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体

```C++
auto f = [] { return 42; };
```

此例中，我们定义了一个可调用对象f，它不接收参数，返回42。

lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符。

在lambda中忽略括号和参数列表等价于制定一个空参数列表。在此例中，当调用f时，参数列表是空的。如果忽略返回类型，lambda根据函数体中的代码推断出返回类型。如果函数体内是一个return语句，则返回类型从返回的表达式的类型推断而来。否则，返回类型为void。

> 如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。

#### 向lambda传递参数

与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，**lambda不能有默认参数**。因此，一个lambda调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。

例子：

```C++
[](const string &s1, const string &s2) { return s1.size() < s2.size(); }
```

空捕获列表表明此lambda不使用他所在函数中的任何局部变量。

```C++
stable_sort(words.begin(), words.end(),
           [](const string &s1, const string &s2)
            { return s1.size() < s2.size(); });
```

当stable_sort需要比较两个元素时，他就会调用给定的这个lambda表达式。

#### 使用捕获列表

虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需的信息。

```C++
// 在本例中，我们的lambda会捕获sz，并只有单一的string参数。其函数体会将string的大小与捕获的sz的值进行比较：
[sz](const string &s)
	{ return s.size() >= sz; };
```

由于此lambda捕获sz，因此lambda的函数体可以使用sz。lambda没有捕获words,因此不能访问此变量。

> 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。

#### 调用find_if

使用此lambda，我们就可以查找第一个长度大于等于sz的元素：

```C++
// 获取一个迭代器，指向第一个满足size() >= sz 的元素
auto wc = find_if(words.begin(), words.end(),
           [sz](const string &s)
            { return s.size() < sz; });
```

我们可以使用find_if返回的迭代器来计算从它开始到words的末尾一共有多少个元素：

```C++
auto count = words.end() - wc;
```

#### for_each 算法

打印words中长度大于等于sz的元素。为了达到这一目的，我们可以使用for_each算法。此算法接受一个可调用对象，并对输入序列中每个元素调用此对象：

```C++
for_each(wc, words.end(),
        [](const string &s){ cout << s << "" });
```

捕获列表为空，是因为我们只对lambda所在函数中定义的（非static）变量使用捕获列表。一个lambda可以直接使用定义在当前函数之外的名字。cout不是定义在biggies中的局部名字，而是定义在头文件iostream中。

#### 完整的 biggies

![](https://cdn.pkubailu.cn/img/完整的biggies.png)

### 10.3.3 lambda 捕获和返回

当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。

默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。

#### 值捕获

类似参数传递，变量的捕获方式也可以是值或引用。到目前为止，我们的lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。

```C++
void fcn1() {
  size_t v1 = 42;
  auto f = [v1] { return v1; };
  v1 = 0;
  auto j = f(); // j是42；f保存了我们创建它时v1的拷贝
}
```

#### 引用捕获

我们定义lambda时可以采用引用方式捕获变量。

```C++
void fcn1() {
  size_t v1 = 42;
  auto f = [&v1] { return v1; };
  v1 = 0;
  auto j = f(); // j是0；f保存v1的引用，而非拷贝
}
```

v1之前的&指出v1应该以引用方式捕获。一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。

引用捕获与返回引用有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。

我们也可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。

> 当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。

![](https://cdn.pkubailu.cn/img/lambda建议.png)

#### 隐式捕获

除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则表示采用值捕获方式。

```C++
// sz 为隐式捕获，值捕获方式
wc = find_if(words.begin(), words.end(),
           [=](const string &s)
            { return s.size() < sz; });
```

如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：

```C++
void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os = cout, char c = ' ') {
  // os隐式捕获，引用捕获；c显式捕获，值捕获
  for_each(words.begin(), words.end(),
           [&, c](const string &s) { os << s << c; });
  // os显式捕获，引用捕获；c隐式捕获，值捕获
  for_each(words.begin(), words.end(),
           [=, &os](const string &s) { os << s << c; });
}
```

当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=。此符号指定了默认捕获方式为引用或值。

**当混合使用隐式捕获和显式捕获时，显示捕获的变量必须使用与隐式捕获不同的方式。**

![](https://cdn.pkubailu.cn/img/10.1.png)

#### 可变lambda

默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表：

```C++
void fcn3() {
  size_t v1 = 42;
  auto f = [=] () mutable { return ++v1; };
  v1 = 0;
  auto j = f(); // j是43
}
```

一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型。

```C++
void fcn4() {
  size_t v1 = 42;
  // v1是一个非const变量的引用
  auto f = [&] () { return ++v1; };
  v1 = 0;
  auto j = f(); // j是1
}
```

#### 指定lambda 返回类型

默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。与其他返回void的函数类似，被推断返回void的lambda不能返回值。

函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。

```C++
// lambda体是单一的return语句，返回一个条件表达式的结果。我们无须指定返回类型，因为可以根据条件运算符的类型推断出来
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i){ return i < 0 ? -i : i; });
// 错误：不能推断lambda的返回类型
// 编译器推断这个版本的lambda返回类型为void，但它返回了一个int值
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i){ if(i<0) return -i; else return i; });
// 当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i) -> int
         { if(i<0) return -i; else return i; });
```

### 10.3.4 参数绑定

对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作中，通常应该定义一个函数，而不是多次编写相同的lambda表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。

如果lambda的捕获列表为空，通常可以用函数来代替它。

但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。

例如，我们用在find_if调用中的lambda比较一个string和一个给定大小。我们可以很容易地编写一个完成同样工作的函数：

```C++
bool check_size(const string &s, string::size_type sz) {
  return s.size() >= sz;
}
```

但是，我们不能用这个函数作为find_if的一个参数。find_if接受一个一元谓词，因此传递给find_if的可调用对象必须接受单一参数。

#### 标准库bind函数

bind的标准库函数，它定义在头文件functional中，可以将bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。

```C++
// 调用bind的一般形式为：
auto newCallable = bind(callable, arg_list);
```

其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。

arg_list中的参数可能包含形如\_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，她们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，\_2为第二个参数，依此类推。

#### 绑定check_size 的sz参数

作为一个简单的例子，我们将使用bind生成一个调用check_size的对象。

```C++
// check6 是一个可调用对象，接受一个string类型的参数
// 并用此string和值6来调用check_size
auto check6 = bind(check_size, _1, 6);
```

此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const string&。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。

使用bind，我们可以将原来基于lambda的find_if调用替换为如下形式：

```C++
// lambda 形式
auto wc = find_if(words.begin(), words.end(),
           [sz](const string &s)
            { return s.size() < sz; });
// bind形式
auto wc = find_if(words.begin(), words.end(),
           bind(check_size, _1, sz));
```

#### 使用placeholders名字

名字_n都定义在一个名为placeholders中，而此命名空间又定义在命名空间std中。

为了使用这些名字，两个命名空间都要写上。与我们的其他例子类似，对bind的调用代码假定之前已经恰当地使用了using声明。

```C++
// 例如，_1对应的using声明为：
using std::placeholders::_1;
```

此声明说明我们要使用的名字_1定义在命名空间placeholders中，而此命名空间又定义在命名空间std中。

对每个占位符名字，我们都必须提供一个单独的using声明。编写这样的声明很烦人，也很容易出错。可以使用另外一种不同形式的using语句，而不是分别声明每个占位符。

```C++
using namespace namespace_name;
```

这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。

```C++
using namespace std::placeholders;
```

使得由placeholders定义的所有名字都可用。与bind函数一样，placeholders命名空间也定义在functional头文件中。

#### bind 的参数

我们可以用bind修正参数的值。更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。例如，假定f是一个可调用对象，它有5个参数，则下面对bind的调用

```C++
// g 是一个有两个参数的可调用对象
auto g = bind(f, a, b, _2, _c, _1);
```

生成一个新的可调用对象，它有两个参数，分别用占位符\_2和_1表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个参数分别被绑定到给定值a、b和c上。

传递给g的参数按位置绑定到占位符。即，第一个参数绑定到_1，第二个参数绑定到\_2。因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个参数将被传递给f作为第三个参数。实际上，这个bind调用会将

```C++
g(_1, _2);
// 映射为
f(a, b, _2, c, _1);
// 例如，调用g(X,Y)会调用
f(a, b, Y, c, X);
```

#### 用bind重排参数顺序

我们可以用bind颠倒isShorter的含义：

```C++
// 按单词长度由短至长排序
sort(words.begin(), words.end(), isShorter);
// 按单词长度由长至短排序
sort(words.begin(), words.end(), bind(isShorter, _2, _1));
```

在第一个调用中，当sort需要比较两个元素A和B时，它会调用isShorter(A,B)。

在第二个对sort的调用中，传递给isShorter的参数被交换过来了。因此，当sort比较两个元素时，就好像调用isShorter(B,A)一样。

#### 绑定引用参数

默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。

但是，与lambda类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。

```C++
// 错误： 不能拷贝os
for_each(words.begin(), words.end(), bind(print, os, _1, ' '));
```

原因在于bind拷贝其参数，而我们不能拷贝一个ostream。如果我们希望传递给bind一个对象而又不拷贝它，就必须使用标准库**ref**函数：

```C++
for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));
```

函数ref返回一个对象，包含给定的的引用，此对象是可以拷贝的。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在头文件functional中。

## 10.4 再探迭代器

除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。

- **插入迭代器**：这些迭代器被绑定到一个容器上，可用来向容器插入元素。
- **流迭代器**：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流
- **反向迭代器**：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。
- **移动迭代器**：这些专用的迭代器不是拷贝其中的元素，而是移动它们。

### 10.4.1 插入迭代器

插入器是一种迭代器适配器，他接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。

![](https://cdn.pkubailu.cn/img/10.2.png)

插入器有三种类型，差异在于元素插入的位置：

- **back_inserter**：创建一个使用push_back的迭代器。
- **front_inserter**：创建一个使用push_front的迭代器。
- **inserter**：创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。

> Note! 只有在容器支持push_front的情况下，我们才可以使用front_inserter。类似的，只有在容器支持push_back的情况下，我们才能使用back_inserter。

理解插入器的工作过程是很重要的：当调用inserter(c,iter)时，我们得到一个迭代器，接下来使用它时，会将元素插入到iter原来所指向的元素之前的位置。即，如果it是由inserter生成的迭代器。

```C++
*it = val;
// 其效果与下面代码一样
it = c.insert(it, val); // it指向新加入的元素
++it; // 递增it使它指向原来的元素
```

front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。当我们使用front_inserter时，元素总是插入到容器第一个元素之前。即使我们传递给inserter的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：

```C++
list<int> lst = {1,2,3,4};
list<int> lst2, lst3; // 空list
// 拷贝完成后，lst2包含4 3 2 1
copy(lst.cbegin(), lst.cend(), front_inserter(lst2));
// 拷贝完成后，lst3包含1 2 3 4
copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));
```

当调用front_inserter(c)时，我们得到一个插入迭代器，接下来会调用push_front。当每个元素被插入到容器c中时，它变为c的新的首元素。因此，front_inserter生成的迭代器会将插入的元素序列的顺序颠倒过来，而inserter和back_inserter则不会。

### 10.4.2 iostream 迭代器

虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器。**istream_iterator**读取输入流，**ostream_iterator**向一个输出流写数据。这些迭代器将他们对应的流当作一个特定类型的元素序列来处理。通过使用迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。

#### istream_iterator 操作

当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个istream_iterator使用>>来读取流。因此，istream_iterator要读取的类型必须定义了输入运算符。当创建一个istream_iterator时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当做尾后值使用的迭代器。

```C++
istream_iterator<int> int_it(cin); // 从cin读取int
istream_iterator<int> int_eof; // 尾后迭代器
ifstream in("afile");
istream_iterator<string> str_it(in); // 从"afile"读取字符串
```

例子：用istream_iterator从标准输入读取数据，存入一个vector

```C++
istream_iterator<int> in_iter(cin); // 从cin读取int
istream_iterator<int> eof; // 尾后迭代器
while (in_iter != eof) {
  // 后置递增运算读取流，返回迭代器的旧值
  // 解引用迭代器，获得从流读取的前一个值
  vec.push_back(*in_iter++);
}
```

此循环从cin读取int值，保存在vec中。在每个循环步中，循环体代码检查in_iter是否等于eof。eof被定义为空的istream_iterator，从而可以当做尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的值就与尾后迭代器相等。

我们可以将程序重写为如下形式，这体现了istream_iterator更有用的地方：

```C++
istream_iterator<int> in_iter(cin), eof; // 从cin读取int
vector<int> vec(in_iter, eof); // 从迭代器范围构造vec
```

本例中我们用一对表示元素范围的迭代器来构造vec。这两个迭代器是istream_iterator，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从cin中读取数据，直至遇到文件尾或者遇到一个不是int的数据为止。从流中读取的数据用来构造vec。

![](https://cdn.pkubailu.cn/img/10.3.png)

#### 使用算法操作流迭代器

由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。

```C++
// 我们可以用一对istream_iterator来调用accumulate
isstream_iterator<int> in_iter(cin), eof;
cout << accumulate(in_iter, eof, 0) << endl;
// 此调用会计算出从标准输入读取的值的和
```

#### istream_iterator 允许使用懒惰求值

当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。

#### ostream_iterator 操作

我们可以对任何具有输出运算符（<<运算符）的类型定义ostream_iterator。当创建一个ostream_iterator时，我们可以提供（可选的）第二个参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符串字面值常量或者一个指向以空字符结尾的字符数组的指针）。必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator。

![](https://cdn.pkubailu.cn/img/10.4.png)

我们可以用ostream_iterator来输出值的序列：

```C++
ostream_iterator<int> out_iter(cout, " ");
for (auto e : vec)
  *out_iter++ = e; // 赋值语句实际上将元素写到cout
cout << endl;
```

此程序将vec中的每个元素写到cout，每个元素后加一个空格。每次向out_iter赋值时，写操作就会被提交。

值得注意的是，当我们向out_iter赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子：

```C++
for (auto e : vec)
  out_iter = e;
```

运算符*和++实际上对ostream_iterator对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保持一致。

可以通过调用copy来打印vec中的元素，这比编写循环更为简单：

```C++
copy(vec.begin(), vec.end(), out_iter);
cout << endl;
```

#### 使用流迭代器处理类类型

![](https://cdn.pkubailu.cn/img/使用流迭代器处理类类型.png)

### 10.4.3 反向迭代器

反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素：递减一个迭代器（--it）会移动到下一个元素。

除了forward_list之外，其他容器都支持反向迭代器。我们可以通过调用rbegin、rend、crbegin和crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有const和非const版本。

![](https://cdn.pkubailu.cn/img/反向迭代器.png)

虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做是我们可以用算法透明的向前或向后处理容器。例如，可以通过向sort传递一对反向迭代器来将vector整理为递减排序

```C++
sort(vec.begin(), vec.end()); // 按”正常序“排列vec
sort(vec.rbegin(), vec.rend()); // 按”逆序“排列vec
```

#### 反向迭代器需要递减运算符

不必惊讶，我们只能从既支持++也支持--的迭代器来定义反向迭代器。毕竟反向迭代器的目的是在序列中反向移动。除了forward_list之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个forward_list或一个流迭代器创建反向迭代器。

#### 反向迭代器和其他迭代器间的关系

![](https://cdn.pkubailu.cn/img/反向迭代器和其他迭代器间的关系.png)

图10.2中的对象显示了普通迭代器与反向迭代器之间的关系。例如，rcomma和rcomma.base()指向不同的元素，line.crbegin和line.cend()也是如此。这些不同保证了元素范围无论是正向处理还是反向处理都是相同的。

> Note! 反向迭代器的目的是表示元素范围，而这些范围是不对称的，这导致一个重要的结果：当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素。

## 10.5 泛型算法结构

任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如find，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如sort，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个迭代器类别。

![](https://cdn.pkubailu.cn/img/10.5.png)

第二种算法分类的方式是按照是否读、写或是重排序列中的元素来分类。

### 10.5.1  5类迭代器

类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另外一些只有特定类别的迭代器才支持。例如，ostream_iterator只支持递增、解引用和赋值。vector、string和deque的迭代器除了这些操作外，还支持递减、关系和算术运算。

迭代器是按他们所提供的操作来分类的，而这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作。

C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如，find算法在一个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。replace函数需要一对迭代器，至少是前向迭代器。对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。

> 对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或提示。

#### 迭代器类别

**输入迭代器**：可以读取序列中的元素。一个输入迭代器必须支持

- 用于比较两个迭代器的相等和不相等运算符（==、!=）
- 用于推进迭代器的前置和后置递增运算（++）
- 用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧
- 箭头运算符（->），等价于(*it).member，即，解引用迭代器，并提取对象的成员

输入迭代器只用于顺序访问。对于一个输入迭代器，*it++保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法find和accumulate要求输入迭代器；而istream_iterator是一种输入迭代器。

**输出迭代器**：可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：

- 用于推进迭代器的前置和后置递增运算（++）
- 解引用运算符（*），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）

我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，copy函数的第三个参数就是输出迭代器。ostream_iterator类型也是输出迭代器

**前向迭代器**：可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法replace要求前向迭代器，forward_list上的迭代器是前向迭代器。

**双向迭代器**：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（--）。算法reverse要求双向迭代器。除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。

**随机迭代器**：提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持：

- 用于比较两个迭代器相对位置的关系运算符（<、<=、>和>=）
- 迭代器和一个整数值的加减运算（+、+=、-和-=），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置
- 用于两个迭代器上的减法运算符（-），得到两个迭代器的距离。
- 下标运算符（iter[n])，与*(iter[n])等价

算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。

### 10.5.2 算法形参模式

在任何其他算法分类之上，还有一组参数规范。理解这些参数规范对学习新算法很有帮助——通过理解参数的含义，你可以将注意力集中在算法所做的操作上。大多数算法具有如下4种形式之一：

```C++
alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
```

#### 接受单个目标迭代器的算法

dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定：按其需要写入数据，不管写入多少个元素都是安全的。

> Warning! 向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。

如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的元素内。更常见的情况是，dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因而保证空间是足够的。ostream_iterator会将数据写入到一个输出流，同样不管写入多少个元素都没有问题。

#### 接受第二个输入序列的算法

> 接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。

### 10.5.3 算法命名规范

除了参数规范，算法还遵循一套命名和重载规范。这些规范处理诸如：如何提供一个操作代替默认的<或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。

#### 一些算法使用重载形式传递一个谓词

接受谓词参数来代替<或==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替<或==：

```C++
unique(beg, end); // 使用 == 运算符比较元素
unique(beg, end, comp); // 使用comp比较元素
```

两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的==运算符来检查重复元素；第二个则调用comp来确定两个元素是否相等。由于两个版本的函数在参数个数上不相等，因此具体应该调用哪个版本不会产生歧义。

#### _if版本的算法

接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。**接受谓词参数的算法都有附加的_if前缀：**

```C++
find(beg, end, val); // 查找输入范围中val第一次出现的位置
find_if(beg, end, pred); // 查找第一个令pred为真的元素
```

这两个算法提供了命名上差异的版本，而非重载版本，因为这两个版本的算法都接受相同数目的参数。因此可能产生重载歧义，虽然很罕见，但是为了避免任何可能的歧义，标准库选择提供不同名字的版本而不是重载。

#### 区分拷贝元素的版本和不拷贝的版本

默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个_copy：

```C++
reverse(beg, end); // 反转输入范围中元素的顺序
reverse_copy(beg, end, dest); // 将元素按逆序拷贝到dest
```

一些算法同时提供_copy和\_if版本。这些版本接受一个目的位置迭代器和一个谓词：

```C++
// 从v1中删除奇数元素
remove_if(v1.begin(), v1.end(), [](int i){ return i%2; });
// 将奇数元素从v1拷贝到v2;v1不变
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i){ return i%2; });
```

## 10.6 特定容器算法

### 10.6.1 list和forward_list特定算法

与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算法。特别是，它们定义了独有的sort、merge、remove、reverse和unique。通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，因为这两个类型分别提供双向迭代器和前向迭代器。

链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个列表可以通过改变元素间的链接而不是真的交换他们的值来快速”交换“元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。

> 对于list和forward_list，应该优先使用成员函数版本的算法而不是通用算法。

![](https://cdn.pkubailu.cn/img/10.6-1.png)

![](https://cdn.pkubailu.cn/img/10.6-2.png)

#### splice 成员

此算法是链表数据结构所特有的。

![](https://cdn.pkubailu.cn/img/10.7.png)

#### 链表特有的操作会改变容器

多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。

例如，通用版本的merge将合并的序列写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本的merge函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用merge的链表对象中。

## 10.7 总结

1. 泛型算法永远不会执行容器的操作，他们只会运行于迭代器之上，执行迭代器的操作

2. 算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素

3.  accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型

4. 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长

5. 一种保证算法有足够元素空间来容纳输出数据的方法是使用**插入迭代器**。插入迭代器是一种向容器中添加元素的迭代器

6. 当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器所指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。

7. 多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果。

8. 标准库允许我们提供自己定义的操作来代替默认运算符重载算法。

9. 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。

10. 可调用对象有：函数、函数指针、重载了函数调用运算符的类、lambda表达式

11. 一个lambda表达式具有如下形式：

    ```C++
    [capture list] (parameter list) -> return type {function body}
    ```

12. 如果函数体内是一个return语句，则返回类型从返回的表达式的类型推断而来。否则，返回类型为void。

13. lambda不能有默认参数

14. 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量

15. 当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型

16. lambda中被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝

17. 当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的

18. 为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则表示采用值捕获方式

19. 当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=。此符号指定了默认捕获方式为引用或值

20. 当混合使用隐式捕获和显式捕获时，显示捕获的变量必须使用与隐式捕获不同的方式

21. 如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable

22. 一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型

23. bind 接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。

    ```C++
    // 调用bind的一般形式为：
    auto newCallable = bind(callable, arg_list);
    ```

24. 如果我们希望传递给bind一个对象而又不拷贝它，就必须使用标准库**ref**函数，函数ref返回一个对象，包含给定的的引用，此对象是可以拷贝的。

25. front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。要注意这两个迭代器的区别。

26. 通过使用迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。

27. 当创建一个流迭代器时，必须指定迭代器将要读写的对象类型

28. 我们还可以默认初始化迭代器，这样就创建了一个可以当做尾后值使用的迭代器

29. istream_iterator 允许使用懒惰求值

30. 标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了

31. 必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator

32. 不能从一个forward_list或一个流迭代器创建反向迭代器

33. 向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据

34. 对于list和forward_list，应该优先使用成员函数版本的算法而不是通用算法

35. 多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。

{"meta":{"title":"露从今夜白","subtitle":"","description":"","author":"John Doe","url":"https://www.pkubailu.cn","root":"/"},"pages":[{"title":"","date":"2019-11-20T02:49:00.000Z","updated":"2020-07-28T08:22:00.000Z","comments":true,"path":"about/index.html","permalink":"https://www.pkubailu.cn/about/index.html","excerpt":"","text":"个人简述"},{"title":"archives","date":"2021-10-22T07:57:22.000Z","updated":"2021-10-22T08:02:25.224Z","comments":true,"path":"archives/index.html","permalink":"https://www.pkubailu.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-20T12:19:13.000Z","updated":"2021-10-23T17:30:52.762Z","comments":true,"path":"categories/index.html","permalink":"https://www.pkubailu.cn/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-10-20T12:25:36.000Z","updated":"2021-10-24T08:27:10.918Z","comments":false,"path":"tags/index.html","permalink":"https://www.pkubailu.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-10-24T08:10:00.000Z","updated":"2021-10-24T08:10:00.000Z","comments":false,"path":"live/index.html","permalink":"https://www.pkubailu.cn/live/index.html","excerpt":"","text":"我和丫头的时光旅程 2021-11-06 2021的第一场雪 2021-10-30 还在寻找答案的路上"},{"title":"","date":"2019-11-20T02:49:00.000Z","updated":"2020-07-28T08:22:00.000Z","comments":true,"path":"message/index.html","permalink":"https://www.pkubailu.cn/message/index.html","excerpt":"","text":"请遵守相关法律法规，文明灌水，谢谢合作~"}],"posts":[{"title":"打卡北京和happyiess凉城","slug":"打卡北京和happyiess凉城","date":"2022-01-24T12:10:41.000Z","updated":"2022-01-24T12:10:41.000Z","comments":true,"path":"2022/01/24/打卡北京和happyiess凉城/","link":"","permalink":"https://www.pkubailu.cn/2022/01/24/%E6%89%93%E5%8D%A1%E5%8C%97%E4%BA%AC%E5%92%8Chappyiess%E5%87%89%E5%9F%8E/","excerpt":"","text":"一周的奇幻旅行！ 周六早上迷迷糊糊中感觉到有人进了我的屋子，我还以为蒙蒙进来接水了呢。结果发现这个人直接坐在了我的椅子上不动了。过了好一会才清醒过来，看到丫头坐在椅子上，睡得有点懵，快乐的反射弧慢了好多拍，渐渐反应过来之后，我当即立刻马上向丫头要了一个亲亲！虽然刚见完也没有太久，但是看到丫头还是忍不住想亲亲抱抱贴贴！和丫头亲亲简直太幸福了！我和蒙蒙把屋子住的太脏乱差了，卫生间的环境水平都突破底线了。我起来之后赶忙去打扫卫生间，这样丫头中午就能洗个热水澡，好好休息一下了，在火车上待了一晚上，睡也没睡好。我丫头肯定是要香喷喷的呀。紧收拾慢收拾时间就来不及洗澡了。只能先去吃火锅回来再舒舒服服了。丫头来了我高兴地不得了，直接下血本点了三个锅底，有丫头最爱吃的沙棘锅和真香锅。菜品我们点的也非常满意，那个沙棘锅是越煮越香，我给丫头夹了很多菜，感觉丫头这次是真的吃得饱饱的了。唯一尴尬的是我们把优惠时间点给记错了，算是美中不足吧。下了一楼我们还逛了盒马鲜生，这个店里的海鲜是真的好，我们本来也在计划着买海鲜去你家拜访，这个店里的那些海鲜给了我直观的感受，感觉有雪中送炭的妙用。盒马鲜生的花花也很便宜，一束粉色康乃馨居然才19，属实让我有些意外，这束花花和丫头太配了，粉粉嫩嫩的，我丫头显然18岁嘛！我还买到了NFC饮料，这个饮料我一直想给丫头尝尝，觉得它真的很好喝，想把我尝过的美好分享给我的宝儿。这里也必须夸奖一下蒙蒙！他请我们喝了椰汁，这个也是丫头喜欢的，而且经过丫头的不懈努力我们还吃到了那么多椰肉，丫头简直太厉害了！么么哒敬上！","categories":[{"name":"private","slug":"private","permalink":"https://www.pkubailu.cn/categories/private/"}],"tags":[]},{"title":"C++ Primer 第11章 关联容器","slug":"C-Primer-第11章","date":"2021-12-31T17:43:37.000Z","updated":"2021-12-31T17:43:37.000Z","comments":true,"path":"2022/01/01/C-Primer-第11章/","link":"","permalink":"https://www.pkubailu.cn/2022/01/01/C-Primer-%E7%AC%AC11%E7%AB%A0/","excerpt":"","text":"第 11 章 关联容器 第11章 关联容器关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是map和set。map中的元素是一些（关键字-值）对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素只包含一个关键字；set支持高效的关键字查询操作—检查一个给定关键字是否在set中。例如，在某些文本处理过程中，可以用一个set来保存想要忽略的单词。字典则是一个很好的使用map的例子：可以将单词作为关键字，将单词释义作为值。 标准库提供8个关联容器。这8个容器间的不同体现在三个维度上： 或者是一个set，或者是一个map； 或者要求不重复的关键字，或者允许重复关键字； 按顺序保存元素，或无序保存。 允许重复关键字的容器的名字中都包含单词multi； 不保持关键字按顺序存储的容器的名字都以单词unordered开头。 无序容器使用哈希函数来组织元素。 11.1 使用关联容器map通常被称为关联数组。关联数组与”正常数组“类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。 与之相对，set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。 11.1.1 使用 map 11.1.2 使用 set 11.2 关联容器概述关联容器都支持9.2节中介绍的普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如push_front、push_back。原因是关联容器中元素是根据关键字存储的。 关联容器的迭代都是双向的。 11.2.1 定义关联容器当定义一个map时，必须即指明关键字类型又指明值类型；而定义一个set时，只需指明关键字类型就行。 12345678map&lt;string, size_t&gt; word_count; // 空容器// 列表初始化set&lt;string&gt; exclude = &#123;&quot;the&quot;, &quot;but&quot;, &quot;and&quot;&#125;;// 三个元素；authors将姓映射为名map&lt;string, string&gt; authors = &#123; &#123;&quot;Joyce&quot;, &quot;james&quot;&#125;, &#123;&quot;Austen&quot;, &quot;Jane&quot;&#125;, &#123;&quot;Dickens&quot;, &quot;Charles&quot;&#125; &#125;; 初始化器必须能转换为容器中元素的类型。 当初始化一个map时，必须提供关键字类型和值类型。我们将每个关键字—值对包围在花括号中：{key, value}。 初始化multimap 或 multiset一个map或set中的关键字必须是唯一的。容器multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字。 12345678vector&lt;int&gt; ivec;for(vector&lt;int&gt;::size_type i = 0; i != 10; ++i)&#123; ivec.push_back(i); ivec.push_back(i);&#125;// ivec 包含来自ivec的不重复的元素；miset包含所有20个元素set&lt;int&gt; iset(ivec.cbegin(), ivec.cend());multiset&lt;int&gt; miset(ivec.cbegin(), ivec.cend()); 即使我们用整个ivec容器来初始化iset，它也只含有10个元素：对应ivec中每个不同的元素。另一方面，miset有20个元素，与ivec中的元素数量一样多。 11.2.2 关键字类型的要求关联容器对其关键字类型有一些限制。对于有序容器——map、multimap、set、multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。 Note! 传递给排序算法的可调用对象必须满足与关联容器中关键字一样的类型要求。 有序容器的关键字类型可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个严格弱序。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质： 两个关键字不能同时“小于等于”对方；如果k1“小于等于”k2，那么k2决不能“小于等于”k1。 如果k1“小于等于”k2，且k2”小于等于“k3，那么k1必须”小于等于“k3。 如果存在两个关键字，任何一个都不”小于等于“另一个，那么我们称这两个关键字是”等价“的。 如果两个关键字是等价的，那么容器将他们视为相等来处理。当用作map的关键字时，只能有一个元素与这两个关键字关联，我们可以用两者中任意一个来访问对应的值。 Note! 在实际编程中，重要的是，如果一个类型定义了”行为正常“的&lt;运算符，则它可以用作关键字类型。 使用关键字类型的比较函数用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。 在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。 11.2.3 pair 类型一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。两个类型不要求一样： 123pair&lt;string, string&gt; anon; // 保存两个stringpair&lt;string, size_t&gt; word_count; // 保存一个string和一个size_tpair&lt;string, vector&lt;int&gt;&gt; line; // 保存string和vector&lt;int&gt; pair的默认构造函数对数据成员进行值初始化。因此，anon是一个包含两个空string的pair，word_count中的size_t成员值为0，而string成员被初始化为空。 我们也可以为每个成员提供初始化器： 1pair&lt;string, string&gt; author&#123;&quot;James&quot;, &quot;Joyce&quot;&#125;; 与其他标准库类型不同，pair的数据成员是public的。两个成员分别命名为first和second。我们用普通的成员访问符号（.）来访问他们。 创建pair对象的函数想象有一个函数需要返回一个pair。在新标准下，我们可以对返回值进行列表初始化 123456789101112131415pair&lt;string, int&gt; process(vector&lt;int&gt; &amp;v) &#123; // 处理v if(!v.empty()) return &#123;v.back(), v.back().size()&#125;; // 列表初始化 else return pair&lt;string, int&gt;(); // 隐式构造返回值&#125;// 显式构造返回值if(!v.empty()) &#123; return pair&lt;string, int&gt;(v.back(), v.back().size());&#125;// 使用make_pair来生成pair对象，pair的两个类型来自于make_pair的参数if(!v.empty()) &#123; return make_pair(v.back(), v.back().size());&#125; 11.3 关联容器操作除了表9.2中列出的类型，关联容器还定义了以下列出的类型。这些类型表示容器关键字和值的类型。 对于set类型，key_type和value_type是一样的；set中保存的值就是关键字。在一个map中，元素是关键字—值对。即，每个元素是一个pair对象，包含一个关键字和一个关联的值。由于我们不能改变一个元素的关键字，因此这些pair的关键字部分是const的： 12345set&lt;string&gt;::value_type v1; // v1是一个stringset&lt;string&gt;::key_type v2; // v2是一个stringmap&lt;string, int&gt;::value_type v3; // v3是一个pair&lt;const string, int&gt;map&lt;string, int&gt;::key_type v4; // v4是一个stringmap&lt;string, int&gt;::mapped_type v5; // v5是一个int 与顺序容器一样，我们使用作用域运算符来提取一个类型的成员——例如，map&lt;string, int&gt;::key_type。 只有map类型（unordered_map、unordered_multimap、multimap、map）才定义了mapped_type。 11.3.1 关联容器迭代器当解引用一个关联迭代器时，我们会得到一个类型为容器的value_type的值的引用。 1234567// 获得指向word_count中一个元素的迭代器auto map_it = word_count.begin();// *map_it是一个指向pair&lt;const string, size_t&gt;对象的引用cout &lt;&lt; map_it-&gt;first; // 打印此元素的关键字cout &lt;&lt; map_it-&gt;second // 打印此元素的值map_it-&gt;first = &quot;new key&quot;; // 错误：关键字是const的++map_it-&gt;second; // 正确：我们可以通过迭代器改变元素 Note! 必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值。 set的迭代器是const的虽然set类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改： 123456set&lt;int&gt; iset = &#123;0,1,2,3,4,5&#125;;set&lt;int&gt;::iterator set_it = iset.begin();if(set_it != iset.end())&#123; *set_it = 42; // 错误：set中的关键字是只读的 cout &lt;&lt; *set_it &lt;&lt;endl; // 正确：可以读关键字&#125; 遍历关联容器map和set类型都支持表9.2中的begin和end操作。与往常一样，我们可以用这些函数获取迭代器，然后用迭代器来遍历容器。 1234567// 获得一个指向首元素的迭代器auto map_it = word_count.cbegin();while(map_it != word_count.cend())&#123; cout &lt;&lt; map_it-&gt;first; cout &lt;&lt; map_it-&gt;second; ++map_it; // 递增迭代器，移动到下一个元素&#125; Note! 本程序的输出是按字典序排列的。当使用一个迭代器遍历一个map、multimap、set、multiset时，迭代器按关键字升序遍历元素 关联容器和算法我们通常不对关联容器使用泛型算法。关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而set类型中的元素是const的，map中的元素是pair，其第一个成员是const的。 关联容器可用于只读取元素的算法。但是，很多这类算法都要搜索序列。由于关联容器中的元素不能通过它们的关键字进行（快速）查找，因此对其使用泛型搜索算法几乎总是个坏主意。例如，关联容器定义了一个名为find的成员，它通过一个给定的关键字直接获取元素。我们可以用泛型find算法来查找一个元素，但此算法会进行顺序搜索。使用关联容器定义的专用的find成员会比调用泛型find快得多。 在实际编程中，如果我们真要对一个关联容器使用算法，要么是将它当做一个源序列，要么当做一个目的位置。 11.3.2 添加元素关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set（以及对应的无序类型）包含不重复的关键字，因此插入一个已经存在的元素对容器没有任何影响： 1234vector&lt;int&gt; ivec = &#123;2,4,6,8,2,4,6,8&#125;;set&lt;int&gt; set2;set2.insert(ivec.begin(), ivec.end()); // set2有4个元素set2.insert(&#123;1,3,5,7,1,3,5,7&#125;); // set2 现在有8个元素 insert有两个版本，分别接受一对迭代器，或是一个初始化器列表，这两个版本的行为类似对应的构造函数——对于一个给定的关键字，只有第一个带此关键字的元素才被插入到容器中。 向map添加元素对一个map进行insert操作时，必须记住元素类型是pair。通常对于想要插入的数据，并没有一个现成的pair对象。可以在insert的参数列表中创建一个pair： 12345// 向word_count插入word的4种方法word_count.insert(&#123;word, 1&#125;);word_count.insert(make_pair(word, 1));word_count.insert(pair&lt;string, size_t&gt;(word, 1));word_count.insert(map&lt;string, size_t&gt;::value_type(word, 1)); 如我们所见，在新标准下，创建一个pair最简单的方法是在参数列表中使用花括号初始化。 检测insert的返回值insert（或emplace）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功。pair的first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则insert什么事情也不做，且返回值中的bool部分为false。如果关键字不存在，元素被插入容器中，且bool值为true。 例子：用insert重写单词计数程序： 1234567map&lt;string, size_t&gt; word_count;string word;while(cin &gt;&gt; word)&#123; auto ret = word_count.insert(&#123;word, 1&#125;); if(!ret.second) // word 已在word_count中 ++ret.first-&gt;second; // 递增计数器&#125; 展开递增语句在这版本的单词计数程序中，递增计数器的语句很难理解。通过添加一些括号来反映出运算符的优先级，会使表达式更容易理解一些： 1++((ret.first)-&gt;second); // 等价的表达式 下面我们一步一步来解释此表达式： ret 保存insert返回的值，是一个pair。 ret.first是pair的第一个成员，是一个map迭代器，指向具有给定关键字的元素。 ret.first-&gt;解引用此迭代器，提取map中的元素，元素也是一个pair。 ret.first-&gt;second map中元素的值部分。 ++ret.first-&gt;second递增此值。 向multiset 或 multimap添加元素我们的单词计数程序依赖于这样一个事实：一个给定的关键字只能出现一次。我们有时希望能添加具有相同关键字的多个元素。例如，可能想建立作者到他所著书籍题目的映射。 12345multimap&lt;string, string&gt; authors;// 插入第一个元素，关键字为Barth, Johnauthors.insert(&#123;&quot;Barth, John&quot;, &quot;Sot-Weed Factor&quot;&#125;);// 正确：添加第二个元素，关键字也是Barth, Johnauthors.insert(&#123;&quot;Barth, John&quot;, &quot;Lost in the Funhouse&quot;&#125;); 对允许重复关键字的容器，接收单个元素的insert操作返回一个指向新元素的迭代器。这里无须返回一个bool值，因为insert总是向这类容器中加入一个新元素。 11.3.3 删除元素 关联容器定义了三个版本的erase。与顺序容器一样，我们可以通过传递给erase一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。 关联容器提供一个额外的erase操作，它接受一个key_value参数。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。 12345// 删除一个关键字，返回删除的元素数量if(word_count.erase(removal_word)) cout &lt;&lt; &quot;OK: &quot; &lt;&lt; removal_word &lt;&lt; &quot;removed\\n&quot;;else cout &lt;&lt; &quot;oops: &quot; &lt;&lt; removal_word &lt;&lt; &quot;not found!\\n&quot;; 对于保存不重复关键字的容器，erase的返回值总是0或1。若返回值为0，则表明想要删除的元素并不在容器中 对允许重复关键字的容器，删除元素的数量可能大于1： 12auto cnt = authors.erase(&quot;Barth, John&quot;);// cnt的值为2 11.3.4 map的下标操作 map和unordered_map容器提供了下标运算符和一个对应的at函数。set类型不支持下标因为set中没有与关键字相关联的”值“。元素本身就是关键字。我们不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。 类似我们用过的其他下标运算符，map下标运算符接受一个索引（即，一个关键字），获取与此关键字相关联的值。但是，与其他下标运算符不同的是，如果关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。 123// 例如，如果我们编写如下代码map &lt;string, size_t&gt; word_count; // empty mapword_count[&quot;Anna&quot;] = 1; 将会执行如下操作 在word_count中搜索关键字为Anna的元素，未找到。 将一个新的关键字—值对插入到word_count中。关键字是一个const string，保存Anna。值进行值初始化，在本例中意味着值为0. 提取出新插入的元素，并将值1赋予它。 由于下标运算符可能插入一个新元素，我们只可以对非const的map使用下标操作。 使用下标操作的返回值map的下标运算符与我们用过的其他下标运算符的另一个不同之处是其返回类型。通常情况下，解引用一个迭代器所返回的类型与下标运算符返回的类型是一样的。但对map则不然：当对一个map进行下标操作时，会获得一个mapped_type对象；当解引用一个map迭代器时，会得到一个value_type对象。 与其他下标运算符相同的是，map的下标运算符返回一个左值。由于返回的是一个左值，所以我们既可以读也可以写元素： 123cout &lt;&lt; word_count[&quot;Anna&quot;]; // 用Anna作为下表提取元素；会打印出1++word_count[&quot;Anna&quot;]; // 提取元素，将其增1cout &lt;&lt; word_count[&quot;Anna&quot;]; Note! 与vector和string不同，map的下标运算符返回的类型与解引用map迭代器得到的类型不同。 有时只是想知道一个元素是否已在map中，但在不存在的时候并不想添加元素。在这种情况下就不能使用下标运算符。 11.3.5 访问元素关联容器提供多种查找一个指定元素的方法，应该使用哪个操作依赖于我们要解决什么问题。如果我们所关心的只不过是一个特定元素是否已在容器中，可能find是最佳选择。对于不允许重复关键字的容器，可能使用find还是count没什么区别。但对于允许重复关键字的容器，count还会做更多的工作：如果元素在容器中，它还会统计有多少个元素有相同的关键字。如果不需要计数，最好使用find： 12345set&lt;int&gt; iset = &#123;0,1,2,3,4,5&#125;;iset.find(1); // 返回一个迭代器，指向key == 1 的元素iset.find(11); // 返回一个迭代器，指向iset.end()iset.count(1); // 返回1iset.count(11); // 返回0 对map使用find代替下标操作对map和unordered_map类型，下标运算符提供了最简单的提取元素的方法。但是，使用下标运算符有一个严重的副作用：如果关键字还未在map中，下标操作会插入一个具有给定关键字的元素。 但有时，我们只是想知道一个给定关键字是否在map中，而不想改变map。这种情况下，应该使用find。 在multimap或multiset中查找元素在允许重复关键字的容器中查找一个元素其过程较为复杂：在容器中可能有很多元素具有给定的关键字。如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。 Note! 当我们遍历一个multimap或multiset时，保证可以得到序列中所有具有给定关键字的元素。 一种不同的，面向迭代器的解决办法我们还可以用lower_bound和upper_bound来解决此问题。如果关键字在容器中，lower_bound返回的迭代器将指向第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配给定关键字的元素之后的位置。如果元素不在multimap中，则lower_bound和upper_bound会返回相等的迭代器——指向一个不影响排序的关键字插入位置。因此，用相同的关键字调用lower_bound和upper_bound会得到一个迭代器范围，表示所有具有该关键字的元素的范围。 当然，这两个操作返回的迭代器可能是容器的尾后迭代器。 lower_bound返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向。如果关键字不在容器中，则lower_bound会返回关键字的第一个安全插入点——不影响容器中元素顺序的插入位置 123// 重写前面的程序for(auto beg = authors.lower_bound(search_item), end = authors.upper_bound(search_item); beg != end; ++beg) cout &lt;&lt; beg-&gt;second &lt;&lt; endl; // 打印每个题目 equal_range 函数解决此问题的最后一种方法是三种方法中最直接的：不必再调用upper_bound和lower_bound，直接调用equal_range即可。此函数接受一个关键字，返回一个迭代器pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。 12for(auto pos = authors.equal_range(search_item); pos.first != pos.end; ++pos.first) cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl; 11.4 无序容器新标准定义了4个无序关联容器，这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。 如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器。 11.4.1 使用无序容器除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作。这意味着我们曾用于map和set的操作也能用于unordered_map和unordered_set。 因此，通常可以用一个无序容器替换对应的有序容器，反之亦然。但是，由于元素未按顺序存储，一个使用无序容器的程序的输出（通常）会与使用有序容器的版本不同。 11.4.2 管理桶无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，他指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。 无序容器提供了一组管理桶的函数。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。 11.4.3 无序容器对关键字类型的要求默认情况下，无序容器使用关键字类型的==运算符来比较元素，他们还使用一个hash类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string和智能指针类型定义了hash。因此，我们可以直接定义关键字是内置类型（包括指针）、string还是智能指针类型的无序容器。 但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。 如果我们的类定义了==运算符，则可以只重载哈希函数： 12// 使用FooHash 生成哈希值； Foo必须有==运算符unorder_set&lt;Foo, decltype(FooHash)*&gt; fooSet(10, FooHash); 11.5 总结 关联容器不支持顺序容器的位置相关的操作，例如push_front、push_back 对于有序容器——map、multimap、set、multiset，关键字类型必须定义元素比较的方法 为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。 在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。 与其他标准库类型不同，pair的数据成员是public的。两个成员分别命名为first和second 必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值 与不能改变一个map元素的关键字一样，一个set中的关键字也是const的 由于下标运算符可能插入一个新元素，我们只可以对非const的map使用下标操作 与vector和string不同，map的下标运算符返回的类型与解引用map迭代器得到的类型不同 新标准定义了4个无序关联容器，这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符 与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本","categories":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://www.pkubailu.cn/categories/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"https://www.pkubailu.cn/tags/C-%E5%9F%BA%E7%A1%80/"}]},{"title":"C++ Primer 第10章 泛型算法","slug":"C-Primer-第10章","date":"2021-12-25T13:16:26.000Z","updated":"2021-12-25T13:16:26.000Z","comments":true,"path":"2021/12/25/C-Primer-第10章/","link":"","permalink":"https://www.pkubailu.cn/2021/12/25/C-Primer-%E7%AC%AC10%E7%AB%A0/","excerpt":"","text":"第 10 章 泛型算法 第10章 泛型算法 关键概念：泛型算法永远不会执行容器的操作，他们只会运行于迭代器之上，执行迭代器的操作。算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。 10.2 初识泛型算法虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。理解算法的最基本的方法就是了解他们是否读取元素、改变元素或是重排元素。 10.2.1 只读算法12// 对vec中的元素求和，和的初值是0int sum = accumulate(vec.cbegin(), vec.cend()); accumulate将第三个参数作为求和的起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。 Note! accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。 1234// 由于string定义了+运算符，所以我们可以通过调用accumulate来将vector中所有string元素连接起来string sum = accumulate(v.cbegin(), v.cend(), string(&quot;&quot;));// 错误：const char* 上没有定义+运算符string sum = accumulate(v.cbegin(), v.cend(), &quot;&quot;); 操作两个序列的算法1equal(roster1.cbegin(), roster1.cend(), roster2.cbegin()); 由于equal利用迭代器完成操作，因此我们可以通过调用equal来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可。例如，在此例中，roster1可以是vector,而roster2是list&lt;const char*&gt;。 但是，equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。 10.2.2 写容器元素的算法一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此他们自身不可能改变容器的大小。 算法不检查写操作一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数fill_n接受一个迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。 12345vector&lt;int&gt; vec; // 空vectorfill_n(vec.begin(), vec.size(), 0);// 灾难: 修改vec中的10个（不存在）元素// 这个调用是一场灾难。我们指定了要写入10个元素，但vec中并没有元素——他是空的，这条语句的结果是未定义的。fill_n(vec.begin(), 10, 0); 介绍back_inserter一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器所指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。 back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。 12vector&lt;int&gt; vec; // 空向量fill_n(back_inserter(vec), 10, 0); 在每步迭代中，fill_n向给定序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。 拷贝算法拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素。 12345// 我们可以用copy实现内置数组的拷贝int a1[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int a2[sizeof(a1)/sizeof(*a1)];//ret 指向拷贝到a2的尾元素之后的位置auto ret = copy(begin(a1), end(a1), a2); copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。 多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果。 例如，replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值： 12345// 将所有值为0的元素改为42replace(ilst.begin(), ilst.end(), 0, 42);// 如果我们希望保留原序列不变，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置replace_copy(ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42);// 此调用后，ilst并未改变，ivec包含ilst的一份拷贝，不过原来在ilst中值为0的元素在ivec中都变为42 10.2.3 重排容器元素的算法某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的&lt;运算符来实现排序的。 消除重复单词为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分。由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作。 123456789void elimDups(vector&lt;int&gt; &amp;word) &#123; // 按字典排序words，以便查找重复单词 sort(word.begin(), word.end()); // unique重排输入范围，使得每个单词只出现一次 // 排列在范围的前部，返回指向不重复区域之后第一个位置的迭代器 auto end_unique = unique(word.begin(), word.end()); // 使用向量操作erase删除重复单词 word.erase(end_unique, word.end());&#125; 使用unique 标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素 10.3 定制操作很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的&lt;或==运算符完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。 例如，sort算法默认使用元素类型的&lt;运算符。但可能我们希望的排序顺序与&lt;所定义的顺序不同，或是我们的序列可能保存的是未定义&lt;运算符的元素类型（如Sales_data）。在这两种情况下，都需要重载sort的默认行为。 10.3.1 向算法传递函数为了按长度重排vector，我们将使用sort的第二个版本，此版本是重载过的，他接受第三个参数，此参数是一个谓词。 谓词谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词（意味着他们只接受单一参数）和二元谓词（意味着它们有两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。 12345bool isShorter(const string &amp;s1, const string &amp;s2) &#123; return s1.size() &lt; s2.size();&#125;// 按长度由短至长排序wordssort(words.begin(), words.end(), isShorter); 排序算法在我们将words按大小重排的同时，还希望具有相同长度的元素按字典序排列。为了保持相同长度的单词按字典序排列，可以使用stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。 123elimDups(words); // 将words按字典序重排，并消除重复单词// 按长度重新排序，长度相同的单词维持字典序stable_sort(words.begin(), words.end(), isShorter); 10.3.2 lambda 表达式根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。 举个例子：求大于等于一个给定长度的单词有多少。 介绍lambda我们可以向一个算法传递任何类别的可调用对象。对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。 到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针。还有其他两种可调用对象：重载了函数调用运算符的类，以及lambda表达式。 一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何内联函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式： 1[capture list] (parameter list) -&gt; return type &#123;function body&#125; 其中，capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）return type、parameter list、function body与任何普通函数一样，分别表示返回类型、参数列表、函数体。但是，与普通函数不同，lambda必须使用尾置返回来指定返回类型。 我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体 1auto f = [] &#123; return 42; &#125;; 此例中，我们定义了一个可调用对象f，它不接收参数，返回42。 lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符。 在lambda中忽略括号和参数列表等价于制定一个空参数列表。在此例中，当调用f时，参数列表是空的。如果忽略返回类型，lambda根据函数体中的代码推断出返回类型。如果函数体内是一个return语句，则返回类型从返回的表达式的类型推断而来。否则，返回类型为void。 如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。 向lambda传递参数与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，lambda不能有默认参数。因此，一个lambda调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。 例子： 1[](const string &amp;s1, const string &amp;s2) &#123; return s1.size() &lt; s2.size(); &#125; 空捕获列表表明此lambda不使用他所在函数中的任何局部变量。 123stable_sort(words.begin(), words.end(), [](const string &amp;s1, const string &amp;s2) &#123; return s1.size() &lt; s2.size(); &#125;); 当stable_sort需要比较两个元素时，他就会调用给定的这个lambda表达式。 使用捕获列表虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需的信息。 123// 在本例中，我们的lambda会捕获sz，并只有单一的string参数。其函数体会将string的大小与捕获的sz的值进行比较：[sz](const string &amp;s) &#123; return s.size() &gt;= sz; &#125;; 由于此lambda捕获sz，因此lambda的函数体可以使用sz。lambda没有捕获words,因此不能访问此变量。 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。 调用find_if使用此lambda，我们就可以查找第一个长度大于等于sz的元素： 1234// 获取一个迭代器，指向第一个满足size() &gt;= sz 的元素auto wc = find_if(words.begin(), words.end(), [sz](const string &amp;s) &#123; return s.size() &lt; sz; &#125;); 我们可以使用find_if返回的迭代器来计算从它开始到words的末尾一共有多少个元素： 1auto count = words.end() - wc; for_each 算法打印words中长度大于等于sz的元素。为了达到这一目的，我们可以使用for_each算法。此算法接受一个可调用对象，并对输入序列中每个元素调用此对象： 12for_each(wc, words.end(), [](const string &amp;s)&#123; cout &lt;&lt; s &lt;&lt; &quot;&quot; &#125;); 捕获列表为空，是因为我们只对lambda所在函数中定义的（非static）变量使用捕获列表。一个lambda可以直接使用定义在当前函数之外的名字。cout不是定义在biggies中的局部名字，而是定义在头文件iostream中。 完整的 biggies 10.3.3 lambda 捕获和返回当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。 默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。 值捕获类似参数传递，变量的捕获方式也可以是值或引用。到目前为止，我们的lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。 123456void fcn1() &#123; size_t v1 = 42; auto f = [v1] &#123; return v1; &#125;; v1 = 0; auto j = f(); // j是42；f保存了我们创建它时v1的拷贝&#125; 引用捕获我们定义lambda时可以采用引用方式捕获变量。 123456void fcn1() &#123; size_t v1 = 42; auto f = [&amp;v1] &#123; return v1; &#125;; v1 = 0; auto j = f(); // j是0；f保存v1的引用，而非拷贝&#125; v1之前的&amp;指出v1应该以引用方式捕获。一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。 引用捕获与返回引用有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。 我们也可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。 当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。 隐式捕获除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式，=则表示采用值捕获方式。 1234// sz 为隐式捕获，值捕获方式wc = find_if(words.begin(), words.end(), [=](const string &amp;s) &#123; return s.size() &lt; sz; &#125;); 如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获： 12345678void biggies(vector&lt;string&gt; &amp;words, vector&lt;string&gt;::size_type sz, ostream &amp;os = cout, char c = &#x27; &#x27;) &#123; // os隐式捕获，引用捕获；c显式捕获，值捕获 for_each(words.begin(), words.end(), [&amp;, c](const string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;); // os显式捕获，引用捕获；c隐式捕获，值捕获 for_each(words.begin(), words.end(), [=, &amp;os](const string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);&#125; 当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。 当混合使用隐式捕获和显式捕获时，显示捕获的变量必须使用与隐式捕获不同的方式。 可变lambda默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表： 123456void fcn3() &#123; size_t v1 = 42; auto f = [=] () mutable &#123; return ++v1; &#125;; v1 = 0; auto j = f(); // j是43&#125; 一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型。 1234567void fcn4() &#123; size_t v1 = 42; // v1是一个非const变量的引用 auto f = [&amp;] () &#123; return ++v1; &#125;; v1 = 0; auto j = f(); // j是1&#125; 指定lambda 返回类型默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。与其他返回void的函数类似，被推断返回void的lambda不能返回值。 函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。 1234567891011// lambda体是单一的return语句，返回一个条件表达式的结果。我们无须指定返回类型，因为可以根据条件运算符的类型推断出来transform(vi.begin(), vi.end(), vi.begin(), [](int i)&#123; return i &lt; 0 ? -i : i; &#125;);// 错误：不能推断lambda的返回类型// 编译器推断这个版本的lambda返回类型为void，但它返回了一个int值transform(vi.begin(), vi.end(), vi.begin(), [](int i)&#123; if(i&lt;0) return -i; else return i; &#125;);// 当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型transform(vi.begin(), vi.end(), vi.begin(), [](int i) -&gt; int &#123; if(i&lt;0) return -i; else return i; &#125;); 10.3.4 参数绑定对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作中，通常应该定义一个函数，而不是多次编写相同的lambda表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。 如果lambda的捕获列表为空，通常可以用函数来代替它。 但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。 例如，我们用在find_if调用中的lambda比较一个string和一个给定大小。我们可以很容易地编写一个完成同样工作的函数： 123bool check_size(const string &amp;s, string::size_type sz) &#123; return s.size() &gt;= sz;&#125; 但是，我们不能用这个函数作为find_if的一个参数。find_if接受一个一元谓词，因此传递给find_if的可调用对象必须接受单一参数。 标准库bind函数bind的标准库函数，它定义在头文件functional中，可以将bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。 12// 调用bind的一般形式为：auto newCallable = bind(callable, arg_list); 其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。 arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，她们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，依此类推。 绑定check_size 的sz参数作为一个简单的例子，我们将使用bind生成一个调用check_size的对象。 123// check6 是一个可调用对象，接受一个string类型的参数// 并用此string和值6来调用check_sizeauto check6 = bind(check_size, _1, 6); 此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const string&amp;。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。 使用bind，我们可以将原来基于lambda的find_if调用替换为如下形式： 1234567// lambda 形式auto wc = find_if(words.begin(), words.end(), [sz](const string &amp;s) &#123; return s.size() &lt; sz; &#125;);// bind形式auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz)); 使用placeholders名字名字_n都定义在一个名为placeholders中，而此命名空间又定义在命名空间std中。 为了使用这些名字，两个命名空间都要写上。与我们的其他例子类似，对bind的调用代码假定之前已经恰当地使用了using声明。 12// 例如，_1对应的using声明为：using std::placeholders::_1; 此声明说明我们要使用的名字_1定义在命名空间placeholders中，而此命名空间又定义在命名空间std中。 对每个占位符名字，我们都必须提供一个单独的using声明。编写这样的声明很烦人，也很容易出错。可以使用另外一种不同形式的using语句，而不是分别声明每个占位符。 1using namespace namespace_name; 这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。 1using namespace std::placeholders; 使得由placeholders定义的所有名字都可用。与bind函数一样，placeholders命名空间也定义在functional头文件中。 bind 的参数我们可以用bind修正参数的值。更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。例如，假定f是一个可调用对象，它有5个参数，则下面对bind的调用 12// g 是一个有两个参数的可调用对象auto g = bind(f, a, b, _2, _c, _1); 生成一个新的可调用对象，它有两个参数，分别用占位符_2和_1表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个参数分别被绑定到给定值a、b和c上。 传递给g的参数按位置绑定到占位符。即，第一个参数绑定到_1，第二个参数绑定到_2。因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个参数将被传递给f作为第三个参数。实际上，这个bind调用会将 12345g(_1, _2);// 映射为f(a, b, _2, c, _1);// 例如，调用g(X,Y)会调用f(a, b, Y, c, X); 用bind重排参数顺序我们可以用bind颠倒isShorter的含义： 1234// 按单词长度由短至长排序sort(words.begin(), words.end(), isShorter);// 按单词长度由长至短排序sort(words.begin(), words.end(), bind(isShorter, _2, _1)); 在第一个调用中，当sort需要比较两个元素A和B时，它会调用isShorter(A,B)。 在第二个对sort的调用中，传递给isShorter的参数被交换过来了。因此，当sort比较两个元素时，就好像调用isShorter(B,A)一样。 绑定引用参数默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。 但是，与lambda类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。 12// 错误： 不能拷贝osfor_each(words.begin(), words.end(), bind(print, os, _1, &#x27; &#x27;)); 原因在于bind拷贝其参数，而我们不能拷贝一个ostream。如果我们希望传递给bind一个对象而又不拷贝它，就必须使用标准库ref函数： 1for_each(words.begin(), words.end(), bind(print, ref(os), _1, &#x27; &#x27;)); 函数ref返回一个对象，包含给定的的引用，此对象是可以拷贝的。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在头文件functional中。 10.4 再探迭代器除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。 插入迭代器：这些迭代器被绑定到一个容器上，可用来向容器插入元素。 流迭代器：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流 反向迭代器：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。 移动迭代器：这些专用的迭代器不是拷贝其中的元素，而是移动它们。 10.4.1 插入迭代器插入器是一种迭代器适配器，他接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。 插入器有三种类型，差异在于元素插入的位置： back_inserter：创建一个使用push_back的迭代器。 front_inserter：创建一个使用push_front的迭代器。 inserter：创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。 Note! 只有在容器支持push_front的情况下，我们才可以使用front_inserter。类似的，只有在容器支持push_back的情况下，我们才能使用back_inserter。 理解插入器的工作过程是很重要的：当调用inserter(c,iter)时，我们得到一个迭代器，接下来使用它时，会将元素插入到iter原来所指向的元素之前的位置。即，如果it是由inserter生成的迭代器。 1234*it = val;// 其效果与下面代码一样it = c.insert(it, val); // it指向新加入的元素++it; // 递增it使它指向原来的元素 front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。当我们使用front_inserter时，元素总是插入到容器第一个元素之前。即使我们传递给inserter的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了： 123456list&lt;int&gt; lst = &#123;1,2,3,4&#125;;list&lt;int&gt; lst2, lst3; // 空list// 拷贝完成后，lst2包含4 3 2 1copy(lst.cbegin(), lst.cend(), front_inserter(lst2));// 拷贝完成后，lst3包含1 2 3 4copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin())); 当调用front_inserter(c)时，我们得到一个插入迭代器，接下来会调用push_front。当每个元素被插入到容器c中时，它变为c的新的首元素。因此，front_inserter生成的迭代器会将插入的元素序列的顺序颠倒过来，而inserter和back_inserter则不会。 10.4.2 iostream 迭代器虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器。istream_iterator读取输入流，ostream_iterator向一个输出流写数据。这些迭代器将他们对应的流当作一个特定类型的元素序列来处理。通过使用迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。 istream_iterator 操作当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个istream_iterator使用&gt;&gt;来读取流。因此，istream_iterator要读取的类型必须定义了输入运算符。当创建一个istream_iterator时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当做尾后值使用的迭代器。 1234istream_iterator&lt;int&gt; int_it(cin); // 从cin读取intistream_iterator&lt;int&gt; int_eof; // 尾后迭代器ifstream in(&quot;afile&quot;);istream_iterator&lt;string&gt; str_it(in); // 从&quot;afile&quot;读取字符串 例子：用istream_iterator从标准输入读取数据，存入一个vector 1234567istream_iterator&lt;int&gt; in_iter(cin); // 从cin读取intistream_iterator&lt;int&gt; eof; // 尾后迭代器while (in_iter != eof) &#123; // 后置递增运算读取流，返回迭代器的旧值 // 解引用迭代器，获得从流读取的前一个值 vec.push_back(*in_iter++);&#125; 此循环从cin读取int值，保存在vec中。在每个循环步中，循环体代码检查in_iter是否等于eof。eof被定义为空的istream_iterator，从而可以当做尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的值就与尾后迭代器相等。 我们可以将程序重写为如下形式，这体现了istream_iterator更有用的地方： 12istream_iterator&lt;int&gt; in_iter(cin), eof; // 从cin读取intvector&lt;int&gt; vec(in_iter, eof); // 从迭代器范围构造vec 本例中我们用一对表示元素范围的迭代器来构造vec。这两个迭代器是istream_iterator，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从cin中读取数据，直至遇到文件尾或者遇到一个不是int的数据为止。从流中读取的数据用来构造vec。 使用算法操作流迭代器由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。 1234// 我们可以用一对istream_iterator来调用accumulateisstream_iterator&lt;int&gt; in_iter(cin), eof;cout &lt;&lt; accumulate(in_iter, eof, 0) &lt;&lt; endl;// 此调用会计算出从标准输入读取的值的和 istream_iterator 允许使用懒惰求值当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。 ostream_iterator 操作我们可以对任何具有输出运算符（&lt;&lt;运算符）的类型定义ostream_iterator。当创建一个ostream_iterator时，我们可以提供（可选的）第二个参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符串字面值常量或者一个指向以空字符结尾的字符数组的指针）。必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator。 我们可以用ostream_iterator来输出值的序列： 1234ostream_iterator&lt;int&gt; out_iter(cout, &quot; &quot;);for (auto e : vec) *out_iter++ = e; // 赋值语句实际上将元素写到coutcout &lt;&lt; endl; 此程序将vec中的每个元素写到cout，每个元素后加一个空格。每次向out_iter赋值时，写操作就会被提交。 值得注意的是，当我们向out_iter赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子： 12for (auto e : vec) out_iter = e; 运算符*和++实际上对ostream_iterator对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保持一致。 可以通过调用copy来打印vec中的元素，这比编写循环更为简单： 12copy(vec.begin(), vec.end(), out_iter);cout &lt;&lt; endl; 使用流迭代器处理类类型 10.4.3 反向迭代器反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素：递减一个迭代器（–it）会移动到下一个元素。 除了forward_list之外，其他容器都支持反向迭代器。我们可以通过调用rbegin、rend、crbegin和crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有const和非const版本。 虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做是我们可以用算法透明的向前或向后处理容器。例如，可以通过向sort传递一对反向迭代器来将vector整理为递减排序 12sort(vec.begin(), vec.end()); // 按”正常序“排列vecsort(vec.rbegin(), vec.rend()); // 按”逆序“排列vec 反向迭代器需要递减运算符不必惊讶，我们只能从既支持++也支持–的迭代器来定义反向迭代器。毕竟反向迭代器的目的是在序列中反向移动。除了forward_list之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个forward_list或一个流迭代器创建反向迭代器。 反向迭代器和其他迭代器间的关系 图10.2中的对象显示了普通迭代器与反向迭代器之间的关系。例如，rcomma和rcomma.base()指向不同的元素，line.crbegin和line.cend()也是如此。这些不同保证了元素范围无论是正向处理还是反向处理都是相同的。 Note! 反向迭代器的目的是表示元素范围，而这些范围是不对称的，这导致一个重要的结果：当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素。 10.5 泛型算法结构任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如find，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如sort，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个迭代器类别。 第二种算法分类的方式是按照是否读、写或是重排序列中的元素来分类。 10.5.1 5类迭代器类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另外一些只有特定类别的迭代器才支持。例如，ostream_iterator只支持递增、解引用和赋值。vector、string和deque的迭代器除了这些操作外，还支持递减、关系和算术运算。 迭代器是按他们所提供的操作来分类的，而这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作。 C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如，find算法在一个序列上进行一遍扫描，对元素进行只读操作，因此至少需要输入迭代器。replace函数需要一对迭代器，至少是前向迭代器。对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。 对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或提示。 迭代器类别输入迭代器：可以读取序列中的元素。一个输入迭代器必须支持 用于比较两个迭代器的相等和不相等运算符（==、!=） 用于推进迭代器的前置和后置递增运算（++） 用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧 箭头运算符（-&gt;），等价于(*it).member，即，解引用迭代器，并提取对象的成员 输入迭代器只用于顺序访问。对于一个输入迭代器，*it++保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法find和accumulate要求输入迭代器；而istream_iterator是一种输入迭代器。 输出迭代器：可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持： 用于推进迭代器的前置和后置递增运算（++） 解引用运算符（*），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素） 我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，copy函数的第三个参数就是输出迭代器。ostream_iterator类型也是输出迭代器 前向迭代器：可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法replace要求前向迭代器，forward_list上的迭代器是前向迭代器。 双向迭代器：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（–）。算法reverse要求双向迭代器。除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。 随机迭代器：提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持： 用于比较两个迭代器相对位置的关系运算符（&lt;、&lt;=、&gt;和&gt;=） 迭代器和一个整数值的加减运算（+、+=、-和-=），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置 用于两个迭代器上的减法运算符（-），得到两个迭代器的距离。 下标运算符（iter[n])，与*(iter[n])等价 算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。 10.5.2 算法形参模式在任何其他算法分类之上，还有一组参数规范。理解这些参数规范对学习新算法很有帮助——通过理解参数的含义，你可以将注意力集中在算法所做的操作上。大多数算法具有如下4种形式之一： 1234alg(beg, end, other args);alg(beg, end, dest, other args);alg(beg, end, beg2, other args);alg(beg, end, beg2, end2, other args); 接受单个目标迭代器的算法dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定：按其需要写入数据，不管写入多少个元素都是安全的。 Warning! 向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。 如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的元素内。更常见的情况是，dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因而保证空间是足够的。ostream_iterator会将数据写入到一个输出流，同样不管写入多少个元素都没有问题。 接受第二个输入序列的算法 接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。 10.5.3 算法命名规范除了参数规范，算法还遵循一套命名和重载规范。这些规范处理诸如：如何提供一个操作代替默认的&lt;或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。 一些算法使用重载形式传递一个谓词接受谓词参数来代替&lt;或==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替&lt;或==： 12unique(beg, end); // 使用 == 运算符比较元素unique(beg, end, comp); // 使用comp比较元素 两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的==运算符来检查重复元素；第二个则调用comp来确定两个元素是否相等。由于两个版本的函数在参数个数上不相等，因此具体应该调用哪个版本不会产生歧义。 _if版本的算法接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的_if前缀： 12find(beg, end, val); // 查找输入范围中val第一次出现的位置find_if(beg, end, pred); // 查找第一个令pred为真的元素 这两个算法提供了命名上差异的版本，而非重载版本，因为这两个版本的算法都接受相同数目的参数。因此可能产生重载歧义，虽然很罕见，但是为了避免任何可能的歧义，标准库选择提供不同名字的版本而不是重载。 区分拷贝元素的版本和不拷贝的版本默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个_copy： 12reverse(beg, end); // 反转输入范围中元素的顺序reverse_copy(beg, end, dest); // 将元素按逆序拷贝到dest 一些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词： 1234// 从v1中删除奇数元素remove_if(v1.begin(), v1.end(), [](int i)&#123; return i%2; &#125;);// 将奇数元素从v1拷贝到v2;v1不变remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i)&#123; return i%2; &#125;); 10.6 特定容器算法10.6.1 list和forward_list特定算法与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算法。特别是，它们定义了独有的sort、merge、remove、reverse和unique。通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，因为这两个类型分别提供双向迭代器和前向迭代器。 链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个列表可以通过改变元素间的链接而不是真的交换他们的值来快速”交换“元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。 对于list和forward_list，应该优先使用成员函数版本的算法而不是通用算法。 splice 成员此算法是链表数据结构所特有的。 链表特有的操作会改变容器多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。 例如，通用版本的merge将合并的序列写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本的merge函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用merge的链表对象中。 10.7 总结 泛型算法永远不会执行容器的操作，他们只会运行于迭代器之上，执行迭代器的操作 算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素 accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长 一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。插入迭代器是一种向容器中添加元素的迭代器 当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器所指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。 多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果。 标准库允许我们提供自己定义的操作来代替默认运算符重载算法。 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。 可调用对象有：函数、函数指针、重载了函数调用运算符的类、lambda表达式 一个lambda表达式具有如下形式： 1[capture list] (parameter list) -&gt; return type &#123;function body&#125; 如果函数体内是一个return语句，则返回类型从返回的表达式的类型推断而来。否则，返回类型为void。 lambda不能有默认参数 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量 当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型 lambda中被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝 当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的 为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式，=则表示采用值捕获方式 当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值 当混合使用隐式捕获和显式捕获时，显示捕获的变量必须使用与隐式捕获不同的方式 如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable 一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型 bind 接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。 12// 调用bind的一般形式为：auto newCallable = bind(callable, arg_list); 如果我们希望传递给bind一个对象而又不拷贝它，就必须使用标准库ref函数，函数ref返回一个对象，包含给定的的引用，此对象是可以拷贝的。 front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。要注意这两个迭代器的区别。 通过使用迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。 当创建一个流迭代器时，必须指定迭代器将要读写的对象类型 我们还可以默认初始化迭代器，这样就创建了一个可以当做尾后值使用的迭代器 istream_iterator 允许使用懒惰求值 标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了 必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator 不能从一个forward_list或一个流迭代器创建反向迭代器 向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据 对于list和forward_list，应该优先使用成员函数版本的算法而不是通用算法 多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。","categories":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://www.pkubailu.cn/categories/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"https://www.pkubailu.cn/tags/C-%E5%9F%BA%E7%A1%80/"}]},{"title":"C++ Primer 第9章 顺序容器","slug":"C-Primer-第9章","date":"2021-12-18T15:19:07.000Z","updated":"2021-12-18T15:19:07.000Z","comments":true,"path":"2021/12/18/C-Primer-第9章/","link":"","permalink":"https://www.pkubailu.cn/2021/12/18/C-Primer-%E7%AC%AC9%E7%AB%A0/","excerpt":"","text":"第 9 章 顺序容器 第9章 顺序容器一个容器就是一些特定类型对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。 9.1 顺序容器概述所有顺序容器都提供了快速顺序访问元素的能力。 除了固定大小的array外，其他容器都提供高校、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策略对容器操作的效率有着固有的，有时是重大的影响。在某些情况下，存储策略还会影响特定容器是否支持特定操作。 新标准库的容器比旧版本快得多。现代C++程序应该使用标准库容器，而不是更原始的数据结构。 9.2 容器库概览容器均定义为模板类。例如对vector，我们必须提供额外信息来生成特定的容器类型。对大多数，但不是所有容器，我们还需要额外提供元素类型信息。 12list&lt;Sales_data&gt; // 保存 Sales_data对象的listdeque&lt;double&gt; // 保存double的deque 9.2.0 对容器可以保存的元素类型的限制顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另一个容器。 较旧的的编译器可能需要在两个尖括号之间键入空格。 虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。 例如，顺序容器构造函数的一个版本接收容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数。 123// 假定noDefault是一个没有默认构造函数的类型vector&lt;noDefault&gt; v1(10, init); // 正确：提供了元素初始化器vector&lt;noDefault&gt; v2(10); // 错误： 必须提供一个元素初始化器 9.2.1 迭代器forward_list 迭代器不支持递减运算符。 算术运算只能应用于string、vector、deque、array的迭代器。我们不能将它们用于其他任何容器类型的迭代器。 一个迭代器范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置。这两个迭代器通常被称为begin和end，他们标记了容器中元素的一个范围。 迭代器范围中的元素包含begin所表示的元素以及从begin开始直至end（但不包含end）之间的所有元素。 这种元素范围被称为左闭合区间。 迭代器begin和end必须指向相同的容器。end可以与begin指向相同的位置，但不能指向begin之前的位置。 如果满足如下条件，两个迭代器begin和end构成一个迭代器范围： 他们指向同一个容器中的元素，或者是容器最后一个元素之后的位置。 我们可以通过反复递增begin来到达end。换句话说，end不在begin之前。 使用左闭合范围蕴含的编程假定标准库使用左闭合范围是因为这种范围有三种方便的性质。 如果begin与end相等，则范围为空。 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素。 我们可以对begin递增若干次，使得begin==end 9.2.2 容器类型成员通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。 为了使用这些类型，我们必须显示使用其类名： 1234// iter是通过list&lt;string&gt;定义的一个迭代器类型list&lt;string&gt;::iterator iter;// count是通过vector&lt;int&gt;定义的一个difference_type类型vector&lt;int&gt;::difference_type count; 9.2.3 begin 和 end 成员begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围。 实际上有两个名为begin的成员。一个是const成员，返回容器的const_iterator类型。另一个是非常量成员，返回容器的iterator类型。 用c开头的版本是C++新标准库引入的，用以支持auto与begin和end函数结合使用。 123456// 显示指定类型list&lt;string&gt;::iterator it5 = a.begin();list&lt;string&gt;::const_iterator it6 = a.cbegin();// 是iterator还是const_iterator依赖于a的类型auto it7 = a.begin(); // 仅当a是const时，it7是const_iteratorauto it8 = a.cbegin(); // it8是const_iterator 当auto与begin和end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代毫不相干。但c开头的版本还是可以获得const_iterator的，而不管容器的类型是什么。 9.2.4 容器定义和初始化每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。 将一个容器初始化为另一个容器的拷贝将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，或者拷贝由一个迭代器对指定的元素范围。 为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器得元素类型即可。 1234567list&lt;string&gt; authors = &#123;&quot;Milton&quot;, &quot;Shakespeare&quot;, &quot;Austen&quot;&#125;;vector&lt;const char*&gt; articles = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;list&lt;string&gt; list2(authors); // 正确：类型匹配deque&lt;string&gt; authList(authors); // 错误：容器类型不匹配vector&lt;string&gt; words(articles); // 错误：容器元素类型不匹配// 正确： 可以将const char*元素转换为stringforward_list&lt;string&gt; words(articles.begin(), articles.end()); 当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。 当两个迭代器表示一个范围时，我们可以使用这种构造函数来拷贝一个容器中的子序列。 列表初始化在新标准中，我们可以对一个容器进行列表初始化 12list&lt;string&gt; authors = &#123;&quot;Milton&quot;, &quot;Shakespeare&quot;, &quot;Austen&quot;&#125;;vector&lt;const char*&gt; articles = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;; 当这样做时，我们就显示的指定了容器中每个元素的值。对于除array之外的容器类型，初始化列表还隐含的指定了容器的大小：容器将包含与初始值一样多的元素。 与顺序容器大小相关的构造函数除了与关联容器相同的构造函数外，顺序容器（array除外）还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器： 1234vector&lt;int&gt; ivec(10, -1); // 10个int元素，每个都初始化为-1list&lt;string&gt; svec(10, &quot;hi!&quot;); // 10个string，每个都初始化为&quot;hi!&quot;forward_list&lt;int&gt; ivec(10); // 10个int元素，每个都初始化为0deque&lt;string&gt; svec(10); // 10个元素，每个都初始化为空string 如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显示的元素初始值。 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。 标准库 array具有固定大小与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小： 12array&lt;int, 42&gt; // 类型为：保存42个int的数组array&lt;string, 10&gt; // 类型为：保存10个string的数组 为了使用array类型，我们必须同时指定元素类型和大小： 12array&lt;int, 10&gt;::size_type i; // 数组类型包括元素类型和大小array&lt;int&gt;::size_type j; // 错误：array&lt;int&gt;不是一个类型 与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化，就像一个内置数组一样。如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行： 123array&lt;int, 10&gt; ia1; // 10个默认初始化的intarray&lt;int, 10&gt; ia2 = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // 列表初始化array&lt;int, 10&gt; ia3 = &#123;42&#125;; // ia3[0]为42，剩余元素为0 值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制： 1234int digs[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int cpy[10] = digs; // 错误：内置数组不支持拷贝或赋值array&lt;int, 10&gt; digits = &#123;0,1,2,3,4,5,6,7,8,9&#125;;array&lt;int, 10&gt; copy = digits; // 正确：只要数组类型匹配即合法 与其他容器一样，array也要求初始值的类型必须与要创建的容器类型相同。此外，array还要求元素类型和大小也都一样，因为大小是array类型的一部分。 9.2.5 赋值和swap赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。 如果两个容器原来大小不同，赋值运算后两者的大小都与右边容器的原大小相同。 与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型。 由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持assign，也不允许用花括号包围的值列表进行赋值。 使用assign（仅顺序容器）赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元素拷贝到左边运算对象中。顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。 12345list&lt;string&gt; names;vector&lt;const char*&gt; oldstyle;names = oldstyle; // 错误：容器类型不匹配// 正确： 可以将const char*转换为stringnames.assign(oldstyle.cbegin(), oldstyle.cend()); 这段代码中对assign的调用将names中的元素替换为迭代器所指定的范围中的元素的拷贝。 由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器。 使用swapswap操作交换两个相同类型容器的内容。 123vector&lt;string&gt; svec1(10); // 10个元素的vectorvector&lt;string&gt; svec2(24); // 24个元素的vectorswap(svec1, svec2); 调用swap后，svec1将包含24个string元素，svec2将包含10个string。除array外，交换两个容器内容的操作保证会很快—元素本身并未交换，swap只是交换了两个容器的内部数据结构。 除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。 元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。例如，假定iter在swap之前指向svec1[3]的string，那么在swap之后它指向svec2[3]的元素。与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。 与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。 因此，对于array，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。 9.2.6 容器大小操作每个容器类型都有三个与大小相关的操作。成员函数size返回容器中元素的数目；empty当size为0时返回布尔值true，否则返回false；max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。forward_list支持max_size和empty，但不支持size。 9.2.7 关系运算符每个容器类型都支持（==和!=）；除了无序关联容器外的所有容器都支持关系运算符(&gt;,&gt;=,&lt;,&lt;=)。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。 比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似。 容器的关系运算符使用元素的关系运算符完成比较 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。 容器的相等运算符实际上是使用元素的==运算符实现比较的，而其他关系运算符是使用元素的&lt;运算符。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。 9.3 顺序容器操作9.3.1 向顺序容器添加元素除array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态的添加或删除元素来改变容器大小。 使用push_back除了array和forward_list之外，每个顺序容器（包括string）都支持push_back。 Note! 当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值得一个拷贝，而不是对象本身。 使用push_frontlist、forward_list和deque容器支持名为push_front的操作。 deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首尾进行插入和删除元素的操作都只花费常数时间。与vector一样，在deque首位之外的位置插入元素会很耗时。 在容器中的特定位置添加元素vector、deque、list、string支持insert成员。 虽然某些容器不支持push_front操作，但它们对于insert操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置。 插入范围内元素12// 运行时错误： 迭代器表示要拷贝的范围，不能指向与目的位置相同的容器slist.insert(slist.begin(), slist.begin(), slist.end()); 在新标准下，接受元素个数或范围的insert版本返回指向第一个新加入元素的迭代器。如果范围为空，不插入任何元素，insert操作会将第一个参数返回。 使用insert的返回值通过使用insert的返回值，可以在容器中一个特定位置反复插入元素： 1234list&lt;string&gt; lst;auto iter = lst.begin();while (cin &gt;&gt; word) iter = lst.insert(iter, word); // 等价于调用push_front 使用emplace操作当调用push或insert成员函数时，我们将元素类型的对象传递给他们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。 1234567// 在C的末尾构造一个Sales_data对象// 使用三个参数的Sales_data构造函数c.emplace(&quot;978-059232323&quot;, 25, 15.99);// 错误： 没有接受三个参数的push_back版本c.push_back(&quot;978-059232323&quot;, 25, 15.99);// 正确： 创建一个临时的Sales_data对象传递给push_backc.push_back(Sales_data(&quot;978-059232323&quot;, 25, 15.99)); 其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对象。在调用emplace_back时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。 emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。 9.3.2 访问元素 包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数。 1234567// 在解引用一个迭代器或调用front或back之前检查是否有元素if(!c.empty()) &#123; auto va1 = *c.begin(), va2 = c.front(); auto last = c.end(); auto va3 = *(--last); auto va4 = c.back();&#125; 对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误。 访问成员函数返回的是引用在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用。 1234567if (!c.empty()) &#123; c.front = 42; // 将42赋值给第一个元素 auto &amp;v = c.back(); // 获得指向最后一个元素的值 v = 1024; // 改变了c中元素的值 auto v2 = c.back(); // v2 不是一个引用，它是c.back()的一个拷贝 v2 = 0; // 未改变c中的元素&#125; 与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。 下标操作和安全的随机访问如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常： 123vector&lt;string&gt; svec; // 空vectorcout &lt;&lt; svec[0]; // 运行时错误：svec中没有元素cout &lt;&lt; svec.at(0); //抛出一个out_of_range异常 9.3.3 删除元素 删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它们是存在的。 与元素访问成员函数类似，不能对一个空容器执行弹出操作。 123// 删除两个迭代器表示的范围内的元素// 返回指向最后一个被删元素之后位置的迭代器elem1 = slist.erase(elem1, elem2); // 调用后，elem1 == elem2 迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置。 9.3.4 特殊的forward_list操作 9.3.5 改变容器大小我们可以用resize来增大或缩小容器，与往常一样，array不支持resize。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部： 1234list&lt;int&gt; ilist(10, 42); // 10个int：每个的值都是42ilist.resize(15); // 将5个只为0的元素添加到ilist的末尾ilist.resize(25, -1); // 将10个值为-1的元素添加到ilist的末尾ilist.resize(5); // 从ilist末尾删除20个元素 9.3.6 容器操作可能使迭代器失效向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题。 在向容器添加元素后： 如果容器是vector和string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。 对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。 当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，当我们删除一个元素后： 对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。 对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。 注意：当我们删除元素时，尾后迭代器总是会失效。 由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。 编写改变容器的循环程序添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步都更新迭代器、引用和指针。 不要保存end返回的迭代器当我们添加/删除vector或string的元素后，或在deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总是会失效。因此，添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代器，一直当做容器末尾使用。 123456789// 灾难：次循环的行为是未定义的auto begin = v.begin(), end = v.end();while(begin != end) &#123; // 做一些处理 // 插入新值，对begin重新赋值，否则的话它就会失效 ++begin; begin = v.insert(begin, 42); // 插入新值 ++begin; // 向前移动begin跳过我们刚刚加入的元素&#125; 此代码的行为是未定义的。在很多标准库实现上，此代码会导致无限循环。问题在于我们将end操作返回的迭代器保存在一个名为end的局部变量中。在循环体中，我们向容器中添加了一个元素，这个操作使保存在end中的迭代器失效了。 9.4 vector对象是如何增长的当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。 9.4.1 管理容量的成员函数 reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。 只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大） 如果需求大小小于或者等于当前容量，reserve什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用reserve之后，capacity将会大于或等于传递给reserve的参数。 调用reserve永远也不会减少容器占用的内存空间。类似的，resize成员函数只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。 在新标准库中，我们可以调用shrink_to_fit来要求deque、vector、string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。 capacity和size理解capacity和size的区别非常重要。容器的size是指他已经保存的元素的数量：而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。 实际上，只要没有操作需求超出vector的容量，vector就不能重新分配内存空间。 Note! 每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只有当迫不得已时才可以分配新的内存空间。 9.5 额外的string操作9.5.1 构造string的其他方法 这些构造函数接受一个string或一个const char*参数，还接受（可选的）指定拷贝多少个字符的参数。当我们传递给他们的是一个string时，还可以给定一个下标来指出从哪里开始拷贝。 通常当我们从一个const char*创建string时，指针指向的数据必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。如果我们未传递计数值且数组也未必以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。 substr操作 9.5.2 改变string的其他方法除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本。下标指出了开始删除的位置，或是insert到给定值之前的位置： 12s.insert(s.size(), 5, &#x27;!&#x27;); // 在s末尾插入5个感叹号s.erase(s.size() - 5, 5); // 从s删除最后5个字符 标准库string类型还提供了接受C风格字符数组的insert和assign版本。例如，我们可以将以空字符结尾的字符数组insert到或assign给一个string： 123const char *cp = &quot;Stately, plump Buck&quot;;s.assign(cp, 7); // s == &quot;Stately&quot;s.insert(s.size(), cp + 7); // s == &quot;Stately, plump Buck&quot; 我们也可以指定将来自其他string或子字符串的字符插入到当前string中或赋予当前string： 1234string s = &quot;Some string&quot;, s2 = &quot;Some other string&quot;;s.insert(0, s2); // 在s中位置0之前插入s2的拷贝// 在s[0]之前插入s2中s2[0]开始的s2.size()个字符s.insert(0, s2, 0, s2.size()); append 和 replace 函数 改变string的多种重载函数assign和append函数无需指定要替换string中哪个部分：assign总是替换string中的所有内容，append总是将新字符追加到string末尾。 9.5.3 string搜索操作这些搜索成员函数及其参数。每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为string::npos的static成员。标准库将npos定义为一个const string::size_type类型，并初始化为值-1。 9.5.4 compare函数 9.5.5 数值转换 9.6 容器适配器除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue、priorty_queue。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。 9.6.1 定义一个适配器每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。 1stack&lt;int&gt; stk(deq); // 从deq拷贝元素到stk 默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。 1234// 在vector上实现的空栈stack&lt;string, vector&lt;string&gt;&gt; str_stk;// str_stk2 在stack&lt;string, vector&lt;string&gt;&gt; str_stk2(svec); 对于一个给定的适配器，可以使用哪些容器是有限制的。所有的适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在array之上。类似的，我们也不能用forward_list来构造适配器，因为所有的适配器都要求容器具有添加、删除以及访问尾元素的能力。 9.6.2 栈适配器 每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作，而不能使用底层容器类型的操作。 9.6.3 队列适配器 9.7 总结 顺序容器为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。 虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了 forward_list 迭代器不支持递减运算符。 算术运算只能应用于string、vector、deque、array的迭代器。我们不能将它们用于其他任何容器类型的迭代器。 迭代器begin和end必须指向相同的容器。end可以与begin指向相同的位置，但不能指向begin之前的位置。 当auto与begin和end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代毫不相干。但c开头的版本还是可以获得const_iterator的，而不管容器的类型是什么。 当创建一个容器为另一个容器的拷贝时，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器得元素类型即可。 只有顺序容器（array除外）的构造函数才接受大小参数，关联容器并不支持 与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小 值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制，但要求两边类型相同 赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。 如果两个容器原来大小不同，赋值运算后两者的大小都与右边容器的原大小相同。 顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值 除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效 forward_list支持max_size和empty，但不支持size 每个容器类型都支持（==和!=）；除了无序关联容器外的所有容器都支持关系运算符(&gt;,&gt;=,&lt;,&lt;=) 容器的关系运算符使用元素的关系运算符完成比较 由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。 添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步都更新迭代器、引用和指针。 要保存end返回的迭代器 容器的size是指他已经保存的元素的数量：而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。 当我们从一个const char*创建string时，指针指向的数据必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。 标准库还定义了三个顺序容器适配器：stack、queue、priorty_queue 本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。 默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。 我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型","categories":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://www.pkubailu.cn/categories/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"https://www.pkubailu.cn/tags/C-%E5%9F%BA%E7%A1%80/"}]},{"title":"C++ Primer 第8章 IO库","slug":"C-Primer-第8章","date":"2021-12-11T13:32:49.000Z","updated":"2021-12-11T13:32:49.000Z","comments":true,"path":"2021/12/11/C-Primer-第8章/","link":"","permalink":"https://www.pkubailu.cn/2021/12/11/C-Primer-%E7%AC%AC8%E7%AB%A0/","excerpt":"","text":"第 8 章 IO库 第8章 IO库8.1 IO类标准库还定义了其他一些IO类型：iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型。 为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵wchar_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。 8.1.0 IO类型间的关系标准库使我们能忽略这些不同类型的流之间的差异，这是通过继承机制实现的。利用模板，我们可以使用具有继承关系的类，而不必了解继承机制如何工作的细节。 简单地说，继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类（继承类）对象当作其基类（所继承的类）对象来使用。 8.1.1 IO对象无拷贝或赋值 不能拷贝或对IO对象赋值： 1234ofstream out1, out2;out1 = out2; // 错误：不能对流对象赋值ofstream print(ofstream); // 错误：不能初始化ofstream参数out2 = print(out2); // 错误： 不能拷贝流对象 由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。 8.1.2 条件状态下表列出了IO类所定义的一些函数和标志，可以帮助我们访问和操纵流的条件状态。 一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用： 12while(cin &gt;&gt; word) // ok:读操作成功..... while循环检查&gt;&gt;表达式返回的流的状态。 查询流的状态IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用。IO库定义了4个iostate类型的constexpr值，表示特定的位模式。这些值用来表示特定类型的IO条件，可以与位运算符一起使用来一次性检验或设置多个标志位。 badbit表示系统级错误，如不可恢复的读写错误。一旦badbit被置位，流就无法再使用了。在发生可恢复错误后，failbit被置位。如果到达文件结束位置，eofbit和fail都会被置位 goodbit的值为0，表示流未发生错误。如果badbit、failbit、eofbit任一个被置位，则检测流状态的条件会失败。 使用good或fail是确定流的总体状态的正确方法。实际上，我们将流当做条件使用的代码就等价于!fail()。 管理条件状态流对象的rdstate成员返回一个iostate值，对应流当前状态。setstate操作将给定条件置位，表示发生了对应错误。clear成员是一个重载的成员：它有一个不接收参数的版本，而另一个版本接受一个iostate类型的参数。 clear不接收参数的版本清除（复位）所有错误标志位。执行clear()后，调用good会返回true。 12345// 记住cin的当前状态auto old_state = cin.rdstate(); // 记住cin当前状态cin.clear(); // 使cin有效process_input(cin); // 使用cincin.setstate(old_state); // 将cin置为原有状态 带参数的clear版本接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。 1cin.clear(cin.rdstate &amp; ~cin.failbit &amp; ~cin.badbit); 8.1.3 管理输出缓冲每个输出流都管理一个缓冲区，用来保存程序读写的数据。 1os &lt;&lt; &quot;please enter a value&quot;; 文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。 导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多： 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。 我们可以使用操作符如endl来显示刷新缓冲区。 在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区刷新。 刷新输出缓冲区123cout &lt;&lt; &quot;hi!&quot; &lt;&lt; endl; // 输出hi和一个换行，然后刷新缓冲区cout &lt;&lt; &quot;hi!&quot; &lt;&lt; flush; // 输出hi，然后刷新缓冲区，不附加任何额外字符cout &lt;&lt; &quot;hi!&quot; &lt;&lt; ends; // 输出hi和一个空字符，然后刷新缓冲区 unitbuf 操纵符如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制： 12cout &lt;&lt; unitbuf; // 所有输出操作后都会立即刷新缓冲区cout &lt;&lt; nounitbuf; // 回到正常的缓冲方式 Warning! 如果程序异常终止，输出缓冲区不会被刷新。它所输出的数据很可能停留在输出缓冲区中等待打印。 关联输入和输出流当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起。 12cin &gt;&gt; ival;// 导致cout的缓冲区被刷新 tie有两个重载的版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即x.tie(&amp;o)将x流关联到输出流o。 我们既可以将一个istream对象关联到另一个ostream，也可以将一个ostream关联到另一个ostream： 1234cin.tie(&amp;cout); // 标准库将cin和cout关联在一起ostream *old_tie = cin.tie(nullptr); // cin不再与其他流关联cin.tie(&amp;cerr); // 读取cin会刷新cerr而不是coutcin.tie(old_tie); // 重建cin和cout间的正常关联 为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了tie。为了彻底揭开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。 8.2 文件输入输出头文件fstream定义了三个类型来支持文件IO: ifstream从一个给定文件读取数据，ofstream向一个给定文件写入数据，以及fstream可以读写给定文件。 这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样。 除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。我们可以对fstream、ifstream和ofstream对象调用这些操作，但不能对其他IO类型调用这些操作。 8.2.1 使用文件流对象当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。 创建文件流对象时，我们可以提供文件名（可选的）。如果提供了一个文件名，则open会自动调用： 12ifsream in(ifile); // 构建一个ifstream并打开给定文件ofstream out; // 输出文件流未关联到任何文件 这段代码定义了一个输入流in，它被初始化为从文件读取数据，文件名由string类型的参数ifile指定。第二条语句定义了一个输出流out，未与任何文件关联。文件名既可以是库类型string对象，也可以是C风格字符数组。 用fstream代替iostream&amp;我们已经提到过。在要求使用基类型对象的地方，我们可以用继承类型的对象来替代。这意味着，接受一个iostream类型引用（或指针）参数的函数，可以用一个对应的fstream（或sstream）类型来调用。 例如：我们假定输入和输出文件的名字是通过传递给main函数的参数来指定的： 成员函数open和close如果我们定义了一个空文件流对象，可以随后调用open来将它与文件关联起来： 123ifstream in(ifile); // 构筑一个ifstream并打开给定文件ofstream out; // 输出文件流未与任何文件相关联out.open(ifile + &quot;.copy&quot;); // 打开指定文件 如果调用open失败，failbit会被置位。因为调用open可能失败，进行open是否成功的检测通常是一个好习惯： 12if (out) // 检查open是否成功 // open成功执行的操作 一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的文件流调用open会失败，并会导致failbit被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一但文件成功关闭，我们可以打开新的文件： 12in.close(); // 关闭文件in.open(ifile + &quot;2&quot;); // 打开另一个文件 如果open成功，则open会设置流的状态，使得good()为true。 自动构造和析构考虑这样一个程序，它的main函数接受一个要处理的文件列表。这种程序可能会有如下的循环： 12345678// 对每个传递给程序的文件执行循环操作for(auto p = argv + 1; p != argv + argc; ++p) &#123; ifstream input(*p); // 创建输出流并打开文件 if (input) &#123; // 如果文件打开成功，处理此文件 process(input); &#125; else cerr &lt;&lt; &quot;couldn&#x27;t open: &quot; + string(*p);&#125; // 每个循环步 input都会离开作用域，因此会被销毁 当一个fstream对象离开其作用域时，与之关联的文件会自动关闭。在下一步循环中，input会再次被创建。 当一个fstream对象被销毁时，close会自动被调用。 8.2.2 文件模式每个流都有一个关联的文件模式，用来指出如何使用文件。 无论用哪种方式打开文件，我们都可以指定文件模式，调用open打开文件时可以，用一个文件名初始化流来隐式打开文件时也可以。指定文件模式有如下限制： 只可以对ofstream或fstream对象设定out模式。 只可以对ifstream或fstream对象设定in模式。 只有当out也被设定时才可设定trunc模式。 只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显示指定out模式，文件也总是以输出方式被打开。 默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断。为了保留以out模式打开的文件的内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。 ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。 每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与ifstream关联的文件默认以in模式打开；与ofstream关联的文件默认以out模式打开；与fstream关联的文件默认以in和out模式打开。 以out模式打开文件会丢弃已有数据默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是同时指定app模式： 1234567// 在这几条语句中，file1都被截断ofstream out(&quot;file1&quot;) // 隐含以输出模式打开文件并截断文件ofstream out(&quot;file1&quot;, ofstream::out) // 隐含的截断文件ofstream out(&quot;file1&quot;, ofstream::out | ofstream::trunc)// 为了保留文件内容，我们必须显示指定app模式ofstream app(&quot;file2&quot;, ofstream::app) // 隐含为输出模式ofstream app(&quot;file2&quot;, ofstream::out | ofstream::app) 保留被ofstream打开的文件中已有数据的唯一方法是显示指定app或in模式 每次调用open时都会确定文件模式对于一个给定流，每当打开文件时，都可以改变其文件模式。 12345ofstream out; // 未指定文件打开模式out.open(&quot;file1&quot;); // 模式隐含设置为输出和截断out.close(); // 关闭out,以便我们将其用于其他文件out.open(&quot;file2&quot;, ofstream::app); // 模式为输出和追加out.close(); 第一个open调用未显示指定输出模式，文件隐式地以out模式打开。通常情况下，out模式意味着同时使用trunc模式。因此，当前目录下名为file1的文件的内容将被清空。当打开名为file2的文件时，我们制定了append模式。文件中已有的数据都得以保留，所有写操作都在文件末尾进行。 在每次打开文件时，都要设置文件模式，可能是显示设置，也可能是隐式的设置。当程序未指定模式时，就使用默认值。 8.3 string 流istringstream从string读取数据，ostringstream向string写入数据，而头文件stringstream即可从string读数据也可向string写数据。与fstream类型类似，头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。 可以对stringstream对象调用这些操作，但不能对其他IO类型调用这些操作。 8.3.1 使用istringstream当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。 8.3.2 使用ostringstream当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。例如，对比上一节的例子，我们可能想逐个验证电话号码并改变其格式。如果所有号码都是有效的，我们希望输出一个新的文件，包含改变格式后的号码。对于无效的号码，我们不会将它们输出到新文件中，而是打印一条包含人名和无效号码的错误信息。 8.4 总结 iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型。 继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类（继承类）对象当作其基类（所继承的类）对象来使用 不能拷贝或对IO对象赋值 由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。 一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据 每个输出流都管理一个缓冲区，用来保存程序读写的数据 文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印 导致缓冲刷新的原因有很多: 程序正常结束 缓冲区满 使用操纵符（endl、flush、unitbuf） 读写关联流（cin 与 cerr 都与cout关联） 如果程序异常终止，输出缓冲区不会被刷新。它所输出的数据很可能停留在输出缓冲区中等待打印 每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream 文件名既可以是库类型string对象，也可以是C风格字符数组 如果我们定义了一个空文件流对象，可以随后调用open来将它与文件关联起来 一旦一个文件流已经打开，它就保持与对应文件的关联 对一个已经打开的文件流调用open会失败，并会导致failbit被置位。随后的试图使用文件流的操作都会失败。 为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件 如果open成功，则open会设置流的状态，使得good()为true。 当一个fstream对象被销毁时，close会自动被调用 保留被ofstream打开的文件中已有数据的唯一方法是显示指定app或in模式 在每次打开文件时，都要设置文件模式，可能是显示设置，也可能是隐式的设置。当程序未指定模式时，就使用默认值 当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream 当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的","categories":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://www.pkubailu.cn/categories/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"https://www.pkubailu.cn/tags/C-%E5%9F%BA%E7%A1%80/"}]},{"title":"生日快乐？","slug":"生日快乐？","date":"2021-12-07T13:06:27.000Z","updated":"2021-12-07T13:06:27.000Z","comments":true,"path":"2021/12/07/生日快乐？/","link":"","permalink":"https://www.pkubailu.cn/2021/12/07/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%EF%BC%9F/","excerpt":"","text":"特别的？平淡无奇的？生日快乐？ 周六是我的生日，周五晚上其实我想出去吃海底捞，可是我感觉要是去了的话，应该会回来的很晚，这样就赶不上12点我期待的祝福，所以我就打消了念头，在家里安安稳稳的等待着期待着……..12点过后，我并没有收到祝福，其实想一想也能明白，也不是很意外，但就是不甘心吧。躺在床上辗转反侧的玩手机，玩到了很晚才睡觉，对明天依然抱有期待。周六一整天其实都没有什么兴致吧，所以吃的也都很简单，也不想把自己过生日的事情告诉别人，很怕乱，怕蒙蒙拉着我去外面吃什么去找仪式感，我就想自己静静的待着，静静地等。看“她”到底有没有给我准备点什么。等到晚上6点左右也没有任何消息，心渐渐沉下去了，应该是没有任何东西了。其实想一想也能明白为什么，但还是不甘心，毕竟生活是需要期待的，只有有期待才能让我们一直有动力走下去。终于决定出去走走，顺便给自己买一块蛋糕，我记得有人说过：“没吃蛋糕就没有长大一岁”。走在路上给你打了电话，我们聊了挺久的，你说了你自己的想法，其实我也知道你的所想所做都没有问题，可是终究意难平呀！晚上终究也还是收到了你迟来的礼物，虽然没有那么高兴了，但是还是高兴的，毕竟我期待了很久。晚上和我爸妈聊天的时候，居然意外收到你的电话，电话接通后你说的一句话让我挺高兴的，你猜是哪一句话呢？生日这天就这样有些遗憾、有些特别、有些平静、有点什么的过去了………","categories":[{"name":"private","slug":"private","permalink":"https://www.pkubailu.cn/categories/private/"}],"tags":[]},{"title":"C++ Primer 第7章 类","slug":"C-Primer-第7章","date":"2021-12-04T09:13:17.000Z","updated":"2021-12-04T09:13:17.000Z","comments":true,"path":"2021/12/04/C-Primer-第7章/","link":"","permalink":"https://www.pkubailu.cn/2021/12/04/C-Primer-%E7%AC%AC7%E7%AB%A0/","excerpt":"","text":"第 7 章 类 第7章 类7.1 定义抽象数据类型7.1.2 定义改进的 Sales_data 类定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，例如add、read和print等，它们的定义和声明都在类的外部。 12345678910111213// 改进的Sales_data类如下所示struct Sales_data &#123; std::string isbn() const &#123; return bookNo; &#125; Sales_data&amp; combine(const Sales_data&amp;); double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;;// Sales_data的非成员接口函数Sales_data add(const Sales_data&amp;, const Sales_data&amp;);std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;);std::istream &amp;read(std::istream&amp;, Sales_data&amp;); 定义在类内部的函数是隐式的inline函数 定义成员函数尽管所有成员都必须在类的内部声明，但是成员函数可以定义在类内也可以定义在类外。对于Sales_data类来说，isbn函数定义在了类内，而combine和avg_price定义在了类外。 1std::string isbn() const &#123; return bookNo; &#125; isbn函数是如何获得bookNo成员所依赖的对象的呢？ 引入this12// 调用isbn函数total.isbn() 当我们调用成员函数时，实际上是在替某个对象调用它。如果isbn指向Sales_data的成员(例如bookNo)，则它隐式地指向调用该函数的对象的成员。 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。 123total.isbn()// 编译器负责把total的地址传递给isbn的隐士形参this，可以认为编译器将该调用重写成了如下的形式Sales_data::isbn(&amp;total) 任何对类成员的直接访问都被看作this的隐式调用，也就是说，当isbn使用bookNo时，它隐式的使用this指向的成员，就像我们书写了this-&gt;bookNo一样。 对于我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或变量的行为都是非法的。我们可以在成员函数体内部使用this，因此尽管没有必要，但我们还是能把isbn定义成如下的形式： 1std::string isbn() const &#123; return this-&gt;bookNo; &#125; 因为this的目的总是指向“这个”对象，所以this是一个常量指针，我们不允许改变this中保存的地址。 引入const 成员函数isbn函数的另一个关键之处是紧随参数列表之后的const关键字，这里，const的作用是修改隐式this指针的类型。 默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales_data成员函数中，this的类型是Sales_data *const。尽管this是隐士地，但它仍然需要遵循初始化规则，意味着（在默认情况下）我们不能把this绑定到一个常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。 如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data *const。毕竟，在isbn的函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。 所以，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称为常量成员函数。 因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，isbn可以读取调用它的对象的数据成员，但是不能写入新值。 类作用域和成员函数编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体内可以随意使用类中的其他成员而无须在意这些成员出现的次序。 在类的外部定义成员函数如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员名字必须包含它所属的类名。 定义一个返回this对象的函数123456Sales_data&amp; Sales_data::combine(const Sales_data &amp;rhs)&#123; units_sold += rhs.units_sold; // 把rhs成员加到this对象的成员上 revenue += rhs.revenue; return *this; // 返回调用该函数的对象 // return语句解引用this指针以获得执行该函数的对象，换句话说，上面的这个调用返回total的引用&#125; 7.1.3 定义类相关的非成员函数类的作者常常需要定义一些辅助函数，比如add、read、和print等。尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。 我们定义非成员函数的方式与定义其它函数一样，通常把函数的声明和定义分离开来。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。 7.1.4 构造函数每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。 构造函数的名字和类名相同。和其他函数不一样的是，构造函数没有返回类型；类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。 不同于其他成员函数，构造函数不能被声明成const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。 合成的默认构造函数类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数。默认构造函数无须任何实参。 如果我们的类没有显式的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。 编译器创建的构造函数又被称为合成的默认构造函数。其初始化类的数据成员的规则如下： 如果存在类内的初始值，用它来初始化成员。 否则，默认初始化该成员。 因为Sales_data为units_sold和revenue提供了初始值，所以合成的默认构造函数将使用这些值来初始化对应的成员；同时，它把bookNo默认初始化成一个空字符串。 某些类不能依赖于合成的默认构造函数合成的默认构造函数只适合非常简单的类，对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三： 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。 对于某些类来说，合成的默认构造函数可能执行错误的操作。回忆我们之前介绍过的，如果定义在块中的内置类型或复合类型的对象被默认初始化，则他们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。 有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。 定义Sales_data的构造函数123456789101112struct Sales_data &#123; Sales_data() = default; Sales_data(const std::string &amp;s): bookNo(s) &#123;&#125; Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125; Sales_data(std::istream &amp;); std::string isbn() const &#123; return bookNo; &#125; Sales_data&amp; combine(const Sales_data&amp;); double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; =default的含义1Sales_data() = default; 因为该构造函数不接受任何实参，所以它是一个默认构造函数。我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。我们希望这个函数的作用完全等同于之前使用的合成默认构造函数。 构造函数初始值列表12Sales_data(const std::string &amp;s): bookNo(s) &#123;&#125;Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125; 花括号定义了（空的）函数体。 冒号和花括号之间的部分称为构造函数初始值列表，它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。 只有一个string类型参数的构造函数使用这个string对象初始化bookNo，对于units_sold和revenue则没有显示的初始化。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。在此例中，这样的成员使用类内初始值初始化。等价于 1Sales_data(const std::string &amp;s): bookNo(s), units_sold(0), revenue(0) &#123;&#125; 通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显示的初始化每个内置类型的成员。 在类的外部定义构造函数123Sales_data::Sales_data(std::istream &amp;is) &#123; read(is, *this); // 从is中读取一条交易记录然后存入this对象中&#125; 没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。 7.1.5 拷贝、赋值和析构除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。 如果我们不主动定义这些操作，则编译器将替我们合成他们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。 某些类不能依赖于合成的版本对于某些类来说，合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。管理动态内存的类通常不能依赖与上述操作的合成版本。 7.2 访问控制与封装7.2.0 封装目前为止，我们的类还没有封装。在C++语言中，我们使用访问说明符加强类的封装性： 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装（即隐藏了）类的实现细节。 123456789101112131415// 再一次定义Sales_data类，其新形式如下所示：class Sales_data &#123;public: Sales_data() = default; Sales_data(const std::string &amp;s): bookNo(s) &#123;&#125; Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125; Sales_data(std::istream &amp;); std::string isbn() const &#123; return bookNo; &#125; Sales_data&amp; combine(const Sales_data&amp;);private: double avg_price() const; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; 一个类包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。 使用class或struct关键字使用class和struct定义类的唯一区别是，struct和class的默认访问权限不太一样。 类可以在他的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。 使用class和struct定义类唯一的区别就是默认的访问权限。 7.2.1 友元既然Sales_data的数据成员是private的，我们的read、print和add函数也就无法正常编译了，这是因为尽管这几个函数是类的接口的一部分，但他们不是类的成员。 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元。如果类想把一个函数成为它的友元，只需要增加一条friend关键字开始的函数声明语句即可： 12345class Sales_data&#123; friend Sales_data add(const Sales_data&amp;， const Sales_data&amp;); friend std::istream &amp;read(std::istream&amp;, Sales_data&amp;); ...&#125; 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。 友元的声明友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。 为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中。 许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。 最好为友元函数提供一个独立的函数声明，这样即使更换了一个有强制要求的编译器，也不必改编代码。 7.3 类的其他特性7.3.1 类成员再探定义一个类型成员除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种： 12345678class Screen &#123;public: typedef std::string::size_type pos;private: pos cursor = 0; pos height = 0, width = 0; std::string contents;&#125; Screen 的用户不应该知道 Screen 使用了一个string对象来存放它的数据，因此通过把pos定义成public成员可以隐藏Screen实现细节。 用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别。因此，类型成员通常出现在类开始的地方。 Screen类的成员函数12345678910111213class Screen &#123;public: typedef std::string::size_type pos; Screen() = default; Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht*wd, c) &#123;&#125; char get() const &#123; return contents[cursor]; &#125; // 读取光标处的字符 隐士内联函数 inline char get(pos ht, pos wd) const; // 显式内联 Screen &amp;move(pos r, pos c); // 能在之后被设为内联private: pos cursor = 0; pos height = 0, width = 0; std::string contents;&#125; 第二个构造函数（接收三个参数）为cursor成员隐式地使用了类内初始值。如果类中不存在cursor的初始值，我们就需要像其他成员一样显示的初始化cursor了。 令成员作为内联函数定义在类内部的成员函数是自动inline的。因此，Screen的构造函数和返回光标所指字符的get函数默认是inline函数。 我们可以在类的内部把inline作为声明的一部分显式的声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义： 123456inlineScreen &amp;Screen::move (pos r, pos c) &#123; pos row = r * width; cursor = row + c; return *this;&#125; 重载成员函数和非成员函数一样，成员函数也可以被重载，只要在函数之间的参数的数量或类型上有所区别就行。 可变数据成员有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。 一个可变数据成员永远不会是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值。举个例子： 123456789class Screen &#123;public: void some_member() const;private: mutable size_t access_ctr; // 即使在一个const对象内也能被修改&#125;;void Screen::some_member() const &#123; ++access_ctr;&#125; 尽管some_member是一个const成员函数，它仍然能够改变access_ctr的值。该成员是个可变成员，因此任何成员函数，包括const函数在内都能改变它的值。 类数据成员的初始值定义好Screen类之后，我们将继续定义一个窗口类并用它表示显示器上的一组Screen。 123456class Window_mgr &#123;private: // 这个Window_mgr追踪的Screen // 默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen std::vector&lt;Screen&gt; screens&#123;Screen(24,80,&#x27;&#x27;)&#125;;&#125; 当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。在此例中，我们使用一个单独的元素值对vector成员执行了列表初始化。 如我们之前所知的，类内初始值必须使用=的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。 当我们提供一个类内初始值时，必须以符号=或者花括号表示。 7.3.2 返回*this的成员函数接下来我们继续添加一些函数，他们负责设置光标所在位置的字符或者其他任一给定位置的字符： 12345678910111213class Screen &#123;public: Screen &amp;set(char); Screen &amp;set(pos, pos, char);&#125;inline Scrren &amp;Scrren::set(char c) &#123; contents[cursor] = c; // 设置当前光标所在位置的新值 return *this; // 将this对象作为左值返回&#125;inline Scrren &amp;Scrren::set(pos r, pos c, char c) &#123; contents[r*width + col] = c; // 设置当前光标所在位置的新值 return *this; // 将this对象作为左值返回&#125; set成员的返回值是调用set的对象的引用。返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。 如果我们令move和set返回Screen而非Screen&amp;，则下述语句的行为将大不相同。 123// 如果move返回Screen而非Screen&amp;Screen temp = myScreen.move(4,0); // 对返回值进行拷贝temp.set(&#x27;#&#x27;); // 不会改变myScreen的contents 假如我们定义的返回类型不是引用，则move的返回值将是*this的副本，因此调用set只能改变临时副本，而不能改变myScreen的值。 从const成员函数返回*this从逻辑上来说，显示一个Screen并不需要改变它的内容，因此我们令display为一个const成员，此时，this将是一个指向const的指针而*this是const对象。由此推断，display的返回类型应该是const Sales_data&amp;。然而，如果真的令display返回一个const的引用，则我们将不能把display嵌入到一组动作序列中去： 123Screen myScreen;// 如果display 返回常量引用，则调用set将引发错误myScreen.display(cout).set(&#x27;#&#x27;); 即使myScreen是个非常量对象，对set的调用也无法通过编译。问题在于display的const版本返回的是常量引用，而我们显然无权set一个常量对象。 一个const成员函数如果以引用的形式返回*this，那么他的返回类型将是常量引用。 基于const的重载通过区分成员函数是否是const的，我们可以对其进行重载。 因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。 123456789101112class Screen &#123;public: // 根据对象是否是const 重载了display函数 Screen &amp;display(std::ostream &amp;os) &#123; do_display(os); return *this; &#125; const Screen &amp;display(std::ostream &amp;os) const &#123; do_display(os); return *this; &#125;private: // 该函数负责显示Screen的内容 void do_display(std::ostream &amp;os) const &#123; os &lt;&lt; contents; &#125;&#125;; 当do_display完成后，display函数各自返回解引用this所得的对象。在非常量版本中，this指向一个非常量对象，因此display返回一个普通的（非常量）引用；而const成员则返回一个常量引用。 当我们在某个对象上调用display时，该对象是否是const决定了应该调用display的哪个版本。 7.3.3 类类型每个类定义了唯一的类型。对于两个类来说，即使他们的成员完全一样，这两个类也是两个不同的类型。 我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class或struct后面： 123Sales_data item1;class Sales_data item1;// 两条声明完全等价 类的声明就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它。 这种声明被称为前向声明，他向程序中引入了类的名字（Screen）并且指明Screen是一种类类型，对于类型Screen来说，在它声明之后定义之前是一个不完全类型。 不完全类型只能在非常有限的情境下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。 7.3.4 友元再探类可以把普通的非成员函数定义成友元。类还可以把其他的类定义成友元，也可以把其他类的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。 类之间的友元关系我们的Window_mgr类的某些成员可能需要访问它管理的Screen类的内部数据。例如：Window_mgr类中的函数clear需要访问Screen的私有成员；要想令这种访问合法，Screen需要把Window_mgr指定成它的友元： 1234class Screen &#123; // Window_mgr 的成员可以访问Screen类的私有部分 friend class Window_mgr;&#125; 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 1234567891011class Window_mgr &#123;public: using ScreenIndex = std::vector&lt;Screen&gt;::size_type; void clear(ScreenIndex);private: std::vector&lt;Screen&gt; screens&#123;Screen(24, 80 ,&#x27;&#x27;)&#125;;&#125;void Window_mgr::clear(ScreenIndex) &#123; Screen &amp;s = screens[ScreenIndex]; s.contents = string(s.ht * s.wd, &#x27;&#x27;);&#125; 如果clear不是Screen的友元，上面的代码将无法通过编译，因为此时clear将不能访问Screen的成员。 必须要注意的一点是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元不能理所当然地具有访问Screen的特权。 令成员函数作为友元除了令整个Window_mgr作为友元之外，Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类： 12345class Screen &#123; // Windoew_mgr::clear 必须在Screen类之前被声明 friend void Windoew_mgr::clear(ScreenIndex); ....&#125; 要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序： 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。 接下来定义Screen，包括对于clear的友元声明。 最后定义clear，此时它才可以使用Screen的成员。 函数重载和友元尽管重载函数的名字相同，但它们仍然是不同的函数，因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。 友元声明和作用域类和非成员函数的声明不是必须在他们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的： 123456789struct X &#123; friend void f() &#123;/* 友元函数可以定义在类的内部 */&#125; X() &#123; f(); &#125; // 错误：f还没有被声明 void g(); void h();&#125;;void X::g() &#123;return f();&#125; // 错误：f还没有被声明void f(); // 声明那个定义在X中的函数void X::h() &#123; return f(); &#125; // 正确：现在f的声明在作用域中了 关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。 7.4 类的作用域每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。 7.4.0 作用域和定义在类外部的成员一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无须再次授权了。 另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。 123456789101112// 例如class Window_mgr &#123;public: // 向窗口添加一个Screen,返回它的编号 ScreenIndex addScreen(const Screen&amp;);&#125;;// 首先处理返回类型，之后我们才进入Window_mgr的作用域Window_mgr::ScreenIndexWindow_mgr::addScreen(const Screen&amp; s) &#123; screens.push_back(s); return screens.size() - 1;&#125; 因为返回类型出现在类名之前，所以事实上它是位于Window_mgr类的作用域之外的。 7.4.1 名字查找与类的作用域在目前为止，我们编写的程序中，名字查找（寻找与所用名字最匹配的声明的过程）的过程比较直截了当： 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。 如果没找到，继续查找外层作用域。 如果最终没有找到匹配的声明，则程序报错。 对于定义在类内部的成员函数来说，解析其中的名字的方式与上述的查找规则有所区别。类的定义分两步处理： 首先，编译成员的声明。 直到类全部可见后才编译函数体。 编译器处理完类中的全部声明后才会处理成员函数的定义。 用于类成员声明的名字查找这种两阶段的处理方式只适用于成员函数体中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。 123456789typedef double Money;string bal;class Account &#123;public: Money balance() &#123; return bal; &#125;private: Money bal; // .....&#125;; 当编译器看到balance函数的声明语句时，他将在Account类的范围内寻找对Money的声明。编译器只考虑Account中在使用Money前出现的声明，因为没找到匹配的成员，所以编译器会接着到Account的外层作用域中查找。另一方面，balance函数体在整个类可见后才被处理，因此，该函数的return语句返回名为bal的成员，而非外层作用域的string对象。 类型名要特殊处理一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字： 123456789typedef double Money;class Account &#123;public: Money balance() &#123; return bal; &#125; // 使用外层作用域中的名字private: typedef double Money; // 错误：不能重新定义Money Money bal; // .....&#125;; 需要特别注意的是，即使Account中定义的Money类型与外层作用域一致，上述代码仍然是错误的。 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。 成员定义中的普通块作用域的名字查找成员函数中使用的名字按照如下方式解析： 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。 一般来说不建议使用其他成员的名字作为某个成员函数的参数。 123456789101112// 通常情况下不建议为参数和成员使用同样的名字int height;class Screen &#123;public: typedef std::string::size_type pos; void dummy_fcn(pos height) &#123; cursor = width * height; // 哪个height? &#125;private: pos cursor = 0; pos height = 0, width = 0;&#125;; 当编译器处理dummy_fcn中的乘法表达式时，他首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此dummy_fcn函数体内用到的名字height指的是参数声明。 在上述代码中，height参数隐藏了同名的成员。如果想绕开上面的查找规则应该将代码变为： 1234void Screen::dummy_fcn(pos height) &#123; cursor = width * this-&gt;height; // 成员height cursor = width * Screen::height; // 成员height&#125; 尽管类的成员被隐藏了，但我们仍然可通过加上类的名字或显示的使用this指针来强制访问成员。 类作用域之后，在外围的作用域中查找如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。 如果，我们需要的是外层作用域中的名字，可以显示的通过作用域运算符来进行请求： 123void Screen::dummy_fcn(pos height) &#123; cursor = width * ::height // 哪个height?是那个全局的&#125; 在文件中名字的出现处对其进行解析当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。 1234567891011121314int height;class Screen &#123;public: typedef std::string::size_type pos; void setHeight(pos); pos height = 0; // 隐藏了外层作用域中的height&#125;;Screen::pos verify(Screen::pos);void Screen::setHeight(pos var) &#123; // var: 参数 // height: 类的成员 // verify: 全局函数 height = verify(var);&#125; 注意：全局函数verify的声明在Screen类的定义之前是不可见的。然后，名字查找的第三步包括了成员函数出现之前的全局作用域。 7.5 构造函数再探7.5.1 构造函数初始值列表如果没有在构造函数的初始值列表中显示的初始化成员，则该成员将在构造函数体之前执行默认初始化。 12345Sales_data::Sales_data(const string &amp;s, unsigned cnt, double price) &#123; bookNo = s; units_sold = cnt; revenue = cnt * price;&#125; 原来的版本（构造函数初始化版本）初始化了它的数据成员，而这个版本是对数据成员执行了赋值操作。 构造函数的初始值有时必不可少有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。 12345678class ConstRef &#123;public: ConstRef(int ii);private: int i; const int ci; int &amp;ri;&#125;; 和其他常量对象或者引用一样，成员ci和ri都必须初始化。 12345ConstRef::constRef(int ii)&#123; i = ii; // 正确 ci = ii; // 错误： 不能给const赋值 ri = i; // 错误：ri没被初始化&#125; 随着构造函数体一开始执行，初始化就完成了。我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此构造函数的正确形式应该是： 12// 正确：显示的初始化引用和const成员ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) &#123;&#125; Note! 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。 成员初始化的顺序构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。 成员的初始化顺序与他们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。 如果可能的话，最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是我们可以不必考虑成员的初始化顺序。 默认实参和构造函数12345class Sales_data &#123;public: Sales_data(std::string s = &quot;&quot;): bookNo(s) &#123;&#125; // ...&#125; 在上面这段程序中，当没有给定实参，或者给定了一个string实参时，两个版本的类创建了相同的对象。因为我们不提供实参也能调用上述的构造函数，所以该构造函数实际上为我们的类提供了默认构造函数。 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。 7.5.2 委托构造函数C++新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数。一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其它构造函数。 在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。 123456789class Sales_data &#123;public: // 非委托构造函数 Sales_data(std::string s, unsigned cnt, double price): bookNo(s), units_sold(cnt), revenue(cnt*price) &#123;&#125; // 其余构造函数全部委托给另一个构造函数 Sales_data(): Sales_data(&quot;&quot;, 0, 0) &#123;&#125; Sales_data(std::string s): Sales_data(s, 0, 0) &#123;&#125; Sales_data(std::istream &amp;is): Sales_data() &#123; read(is, *this); &#125;&#125; 除了第一个，其他三个构造函数全部委托第一个构造函数完成初始化。 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，执行完后控制权才会交还给委托者的函数体。 7.5.3 默认构造函数的作用当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生： 当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时。 当一个类本身含有类类型的成员且使用合成的默认构造函数时。 当类类型的成员没有在构造函数初始值列表中显示的初始化时。 值初始化在以下情况下发生： 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。 当我们不使用初始值定义一个局部静态变量时。 当我们通过书写形如T()的表达式显示的请求值初始化时，其中T()是类型名（vector的一个构造函数只接受一个实参用于说明vector大小，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。 类必须包含一个默认构造函数以便在上述情况下使用。 在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。 7.5.4 隐式的类类型转换我们也能为类定义隐式转换规则。如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐士转换机制，有时我们把这种构造函数称作转换构造函数。 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。 在Sales_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这两种类型向Sales_data隐式转换的规则。也就是说，在需要使用Sales_data的地方，我们可以使用string或者istream作为替代： 1234string null_book = &quot;9-999-9999-9&quot;;// 构造一个临时的Sales_data对象// 该对象的units_sold和revenue等于0,bookNo等于null_bookitem.combine(null_book); 这里我们用一个string实参调用了Sales_data的combine成员。该调用是合法的，编译器用给定的string自动创建了一个Sales_data对象。新生成的这个（临时）Sales_data对象被传递给combine。因为combine的参数是一个常量引用，所以我们可以给该参数传递一个临时变量。 只允许一步类类型转换编译器只会自动的执行一步类类型转换。 12// 因为下面的代码隐式的使用了两种转换规则，所以他是错误的item.combine(&quot;9-99-999&quot;); 抑制构造函数定义的隐式转换在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止： 1234567class Sales_data &#123;public: Sales_data() = default; Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125; explicit Sales_data(const std::string &amp;s): bookNo(s) &#123;&#125; explicit Sales_data(std::istream&amp;);&#125;; 此时，没有任何构造函数能用于隐式地创建Sales_data对象，之前的两种用法都无法通过编译。 12item.combine(null_book); // 错误：string构造函数是explicit的item.combine(cin); // 错误：istream构造函数是explicit的 关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复： 123explicit Sales_data::Sales_data(istream &amp;is) &#123; read(is, *this);&#125; explicit 构造函数只能用于直接初始化发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=）此时，我们只能使用直接初始化而不能使用explicit构造函数： 123Sales_data item1(null_book); // 正确：直接初始化// 错误：不能将explicit构造函数用于拷贝形式的初始化过程Sales_data item2 = null_book; 当我们使用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。 为转换显示地使用构造函数尽管编译器不会将explicit的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显示的强制进行转换： 1234// 正确： 实参是一个显示构造的Sales_data对象item.combine(Sales_data(null_book));// 正确： static_cast可以使用explicit的构造函数item.combine(static_cast&lt;Sales_data&gt;(cin)); 标准库中含有显示构造函数的类我们用过的一些标准库中的类含有单参数的构造函数： 接受一个单参数的const char*的string构造函数不是explicit的。 接受一个容量参数的vector构造函数是explicit的。 7.5.5 聚合类聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的： 所有成员都是public的。 没有定义任何构造函数。 没有类内初始值。 没有基类，也没有virtual函数。 12345// 这是一个聚合类struct Data &#123; int ival; string s;&#125;; 我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员： 12// val1.ival = 0; val1.s = string(&quot;Anna&quot;)Data val1 = &#123;0, &quot;Anna&quot;&#125;; 初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推。 与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。 值得注意的是，显示的初始化类的对象的成员存在三个明显的缺点： 要求类的所有成员都是public的 将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。 添加或删除一个成员之后，所有的初始化语句都需要更新。 7.5.6 字面值常量类constexpr 函数的参数和返回值必须是字面值类型。和其他类不同，字面值类型的类可能含有constexpr函数成员。 数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合以下要求，则它也是一个字面值常量类： 数据成员都必须是字面值类型。 类必须至少含有一个constexpr构造函数 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。 类必须使用析构函数的默认定义，该成员负责销毁类的对象。 constexpr 构造函数尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。 constexpr构造函数可以声明成=default的形式。否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句）。综合这两点可知，constexpr构造函数体一般来说应该是空的。 1234567891011121314class Debug &#123;public: constexpr Debug(bool b = true): hw(b), io(b), other(b) &#123;&#125; constexpr Debug(bool h, bool i, bool o): hw(h), io(i), other(o) &#123;&#125; constexpr bool any() &#123; return hw || io || other; &#125; void set_io(bool b) &#123; io = b; &#125; void set_hw(bool b) &#123; hw = b; &#125; void set_other(bool b) &#123; other = b; &#125;private: bool hw; bool io; bool other;&#125;; constexpr 构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。 constexpr 构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型。 7.6 类的静态成员有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。 7.6.1 静态成员概述声明静态成员我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态成员的类型可以是常量、引用、指针、类类型等。 1234567891011class Account &#123;public: void calculate() &#123; amount += amount * interestRate; &#125; static double rate() &#123; return interestRate; &#125; static void rate(double);private: std::string owner; double amount; static double interestRate; static double initRate();&#125;; 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。 类似的，静态成员函数也不与任何对象绑定在一起，他们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。这一限制既适用于this的显示使用，也对调用非静态成员的隐式使用有效。 使用类的静态成员我们使用作用域运算符直接访问静态成员： 12double r;r = Account::rate(); 虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员： 1234Account ac1;Account *ac2 = &amp;ac1;r = ac1.rate();r = ac2-&gt;rate(); 成员函数不用通过作用域运算符就能直接使用静态成员： 123456class Account &#123;public: void calculate() &#123; amount += amount * interestRate; &#125;private: static double interestRate;&#125; 定义静态成员和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句： 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。 因为静态数据成员不属于类的任何一个对象，所以他们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。 类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。 我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字： 1double Account::interestRate = initRate(); 这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以访问类Account中的所有成员。 静态成员的类内初始化通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以他们能用在所有适合于常量表达式的地方。 12345678class Account &#123;public: static double rate() &#123; return interestRate; &#125; static void rate(double);private: static constexpr int period = 30; double daily_tbl[period];&#125;; 如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr static不需要分别定义。相反，如果我们将它用于值不能替换的场景中，则该成员必须有一条定义语句。 例如：如果period的唯一用途就是定义daily_tbl的维度，则不需要在Account外面专门定义period。此时，如果我们忽略了这条定义，那么对程序非常微小的改动也可能造成编译错误，因为程序找不到该成员的定义语句。举个例子，当需要把Account::period传递给一个接受const int&amp;的函数时，必须定义period。 如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了： 1constexpr int Account::period; // 初始值在类的定义内提供 即使一个常量静态数据成员在类的内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 静态成员能用于某些场景，而普通成员不能某些非静态数据成员可能非法的场合，静态成员却可以正常使用。 静态数据成员可以是不完全类型。特别的，静态数据成员的类型可以就是他所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用： 12345678class Bar &#123;public: // ...private: static Bar mem1; // 正确： 静态成员可以是不完全类型 Bar *mem2; // 正确： 指针成员可以是不完全类型 Bar mem3; // 错误：数据成员必须是完全类型&#125; 静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参： 1234567class Screen &#123;public: // bkground 表示一个在类中稍后定义的静态成员 Screen&amp; clear(char = bkground);private: static const char bkground;&#125;; 非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。 7.7 总结 成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部。 定义在类内部的函数是隐式的inline函数 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。 123total.isbn()// 编译器负责把total的地址传递给isbn的隐士形参this，可以认为编译器将该调用重写成了如下的形式Sales_data::isbn(&amp;total) 任何对类成员的直接访问都被看作this的隐式调用 对于我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或变量的行为都是非法的 紧随参数列表之后的const关键字的作用是修改隐式this指针的类型。 默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales_data成员函数中，this的类型是Sales_data *const。这意味着（在默认情况下）我们不能把this绑定到一个常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。 如果我们把this声明成const Sales_data *const，则可以提高函数的灵活性。 所以，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称为常量成员函数。 因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体内可以随意使用类中的其他成员而无须在意这些成员出现的次序。 如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员名字必须包含它所属的类名。 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数 构造函数没有返回类型，类可以包含多个构造函数。 构造函数不能被声明成const的，当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。 类通过默认构造函数控制默认初始化过程。默认构造函数无须任何实参。 如果我们的类没有显式的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数 默认构造函数初始化类的数据成员的规则如下： 如果存在类内的初始值，用它来初始化成员。 否则，默认初始化该成员。 某些类不能依赖于合成的默认构造函数 定义默认构造函数： = default 冒号和花括号之间的部分称为构造函数初始值列表，它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。 在C++语言中，我们使用访问说明符加强类的封装性 一个类包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。 使用class和struct定义类的唯一区别是，struct和class的默认访问权限不太一样 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。 除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名 用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别。因此，类型成员通常出现在类开始的地方 我们可以在类的内部把inline作为声明的一部分显式的声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义 和非成员函数一样，成员函数也可以被重载，只要在函数之间的参数的数量或类型上有所区别就行 有时我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点 一个可变数据成员永远不会是const，即使它是const对象的成员 若某个成员是个可变成员，则任何成员函数，包括const函数在内都能改变它的值。 当我们提供一个类内初始值时，必须以符号=或者花括号表示。 一个const成员函数如果以引用的形式返回*this，那么他的返回类型将是常量引用 通过区分成员函数是否是const的，我们可以对其进行重载 每个类定义了唯一的类型。对于两个类来说，即使他们的成员完全一样，这两个类也是两个不同的类型 对于类型Screen来说，在它声明之后定义之前是一个不完全类型 不完全类型只能在非常有限的情境下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。 必须要注意的一点是，友元关系不存在传递性 要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系 如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明 即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的。类内的友元声明并非普通意义上的声明，还需要在类外进行声明。 一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体 另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外 声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见 然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字 成员函数中使用的名字按照如下方式解析： 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。 如果没有在构造函数的初始值列表中显示的初始化成员，则该成员将在构造函数体之前执行默认初始化 有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样，构造函数的初始值有时必不可少 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。 随着构造函数体一开始执行，初始化就完成了，常量对象便具有了“常量属性”。 成员的初始化顺序与他们在类定义中的出现顺序一致，构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序 如果可能的话，最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是我们可以不必考虑成员的初始化顺序。 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数 委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程 通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则 编译器只会自动的执行一步类类型转换 在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止 只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复 explicit 构造函数只能用于直接初始化，而不能用于拷贝初始化 我们通过在成员的声明之前加上关键字static使得其与类关联在一起 静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针 成员函数不用通过作用域运算符就能直接使用静态成员 我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句 通常我们不在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。 即使一个常量静态数据成员在类的内部被初始化了，通常情况下也应该在类的外部定义一下该成员 静态数据成员可以是不完全类型。特别的，静态数据成员的类型可以就是他所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用 静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参","categories":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://www.pkubailu.cn/categories/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"https://www.pkubailu.cn/tags/C-%E5%9F%BA%E7%A1%80/"}]},{"title":"C++ Primer 第6章 函数","slug":"C-Primer-第6章","date":"2021-11-27T15:23:11.000Z","updated":"2021-11-27T15:23:11.000Z","comments":true,"path":"2021/11/27/C-Primer-第6章/","link":"","permalink":"https://www.pkubailu.cn/2021/11/27/C-Primer-%E7%AC%AC6%E7%AB%A0/","excerpt":"","text":"第 6 章 函数 第6章 函数6.1 函数基础6.1.0 形参列表与返回类型函数有几个形参，我们就必须提供相同数量的实参。 函数的形参列表12void f1()&#123;&#125; // 隐式地定义空形参列表void f2(void) &#123;&#125; // 显式的定义空形参列表 函数返回类型函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。 6.1.1 局部对象自动对象我们把只存在于块执行期间的对象称为自动对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。 局部静态对象可以将局部变量定义成static类型从而获得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对他有影响。 如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。 6.1.2 函数声明函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称为函数原型 Note! 含有函数声明的头文件应该被包含到定义函数的原文件中。 6.2 参数传递6.2.3 const形参和实参和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。 调用fcn函数时，既可以传入const int也可以传入int。忽略掉形参的顶层const可能产生意想不到的结果: 12void fcn(const int i) &#123; // fcn 能够读取i，但是不能向i写值 &#125;void fcn(int i) &#123;&#125; // 错误：重复定义了fcn(int) 当重载函数fcn时发生错误，因为顶层const被忽略掉了，所以在上面的代码中传入两个fcn函数的参数可以完全一样，所以第二个fcn是错误的。 尽量使用常量引用把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。 6.2.4 数组形参数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是： 不允许拷贝数组 使用数组时（通常）会将其转换成指针 尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式： 12345// 尽管形式不同，但这三个print函数是等价的// 每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]); // 可以看出来，函数的意图是作用于一个数组void print(const int[10]); // 这里的维度表示我们期望数组含有多少元素，实际不一定 Warning! 和其他使用数组的代码一样，以数组为形参的函数也必须确保使用数组时不会越界。 使用标记指定数组长度管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。 1234567void print(const char *cp) &#123; if(cp)&#123; // 若cp不是一个空指针 while(*cp)&#123; // 只要指针所指的字符不是空字符 cout &lt;&lt; *cp++; &#125; &#125;&#125; 使用标准库规范管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库的启发。 12345void print (const int *beg, const int *end) &#123; while(beg != end) &#123; cout &lt;&lt; *beg++; &#125;&#125; 显示传递一个表示数组大小的形参第三种管理数组实参的方法是专门定义一个表示数组大小的形参。 1234567// const int ia[] 等价于const int *ia// size 表示数组的大小void print(const int ia[],size_t size) &#123; for (size_t i = 0; i &lt; size; ++i) &#123; cout &lt;&lt; ia[i]; &#125;&#125; 数组形参和const三个print函数都把数组形参定义成了指向const的指针。当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。 数组引用形参形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上。 12345// 正确： 形参是数组的引用，维度是类型的一部分void print(int (&amp;arr)[10]) &#123; for (auto elem : arr) cout &lt;&lt; elem;&#125; &amp;arr 两端的括号必不可少 f(int &amp;arr[10]) // 错误： 将arr声明成了引用的数组 f(int (&amp;arr)[10]) //正确： arr是具有10个整数的整型数组的引用 但是，这一用法也无形中限制了print函数的可用性，我们只能将函数作用于大小为10的数组。 传递多维数组12void print(int (*matrix)[10], int rowSize) &#123;&#125;// 上述语句将 matrix 声明成指向含有10个整数的数组的指针 Note! *matrix 两端的括号必不可少： *int matrix[10]; // 10个指针构成的数组 *int (matrix)[10]; // 指向含有10个整数的数组的指针 1void print(int matrix[][10], int rowSize) &#123;&#125; matrix 的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。 6.2.5 main: 处理命令行选项1int main(int argc, char *argv[]) &#123;&#125; 第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。 当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。 123456789// 当命令行输入prog -d -o ofile data0// argv 应该包含如下的C风格字符串：argv[0] = &quot;prog&quot;;argv[1] = &quot;-d&quot;;argv[2] = &quot;-o&quot;;argv[3] = &quot;ofile&quot;;argv[4] = &quot;data0&quot;;argv[5] = 0; 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入。 6.2.6 含有可变形参的函数initializer_list 形参如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。 和vector一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型： 12initializer_list&lt;string&gt; ls; // initializer_list 的元素类型是stringinitializer_list&lt;int&gt; li; // initializer_list的元素类型是int 和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法修改其中的值。 12345678910void error_msg(initializer_list&lt;string&gt; ls) &#123; for (auto beg = ls.begin(); beg != ls.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; endl;&#125;// 想向initializer_list形参中传递一个值序列，则必须把序列放在一对花括号内// expected和actual是string对象if (expected != actual) error_msg(&#123;&quot;functionX&quot;, expected, actual&#125;);else error_msg(&#123;&quot;functionX&quot;, &quot;okay&quot;&#125;) 省略符形参省略符形参应该仅仅用于C和C++通用的类型。特别注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝 省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种： 12void foo(parm_list,...);void foo(...); 第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参所对应的实参无需类型检查。 6.3 返回类型和 return 语句6.3.2 有返回值函数不要返回局部对象的引用或指针函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域： 1234567const string &amp;manip() &#123; string ret; if (!ret.empty()) return ret; // 错误：返回局部对象的引用！ else return &quot;Empty&quot;; // 错误： &quot;Empty&quot;是一个局部临时变量&#125; 第一条return 语句来说，显然它返回的是局部对象的引用。 第二条return 语句中，字符串字面值转换成一个局部临时string对象，该对象和ret一样都是局部的。 6.3.3 返回数组指针声明一个返回数组指针的函数123int arr[10]; //arr 是一个含有10个整数的数组int *p1[10]; // p1是一个含有10个指针的数组int (*p1)[10]; // p2 是一个指针，它指向含有10个整数的数组 和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示： 12Type (*function(parameter_list))[dimension]// (*function(parameter_list))两端的括号必须存在。 具体的例子： 1int (*func(int i))[10]; 可以按照以下的顺序来逐层理解该声明的含义： func(int i) 表示调用func函数时需要一个int类型的实参。 (*func(int i)) 意味着我们可以对函数调用的结果执行解引用操作 (*func(int i))[10] 表示解引用func的调用将得到一个大小为10的数组 int (*func(int i))[10] 表示数组中的元素是int类型 使用尾置返回类型简化上述func声明的方法，还可以使用尾置返回类型。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto: 12// func 接受一个int 类型的实参，返回一个指针，该指针指向含有10个整数的数组auto func(int i) -&gt; int(*)[10]; 因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。 使用 decltype如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。 123456int odd[] = &#123;1,3,5,7,9&#125;;int event[] = &#123;0,2,4,6,8&#125;;// 返回一个指针，该指针指向含有5个整数的数组decltype(odd) *arrPtr(int i)&#123; return (i % 2) ? &amp;odd : &amp;even; //返回一个指向数组的指针&#125; 因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个*符号。 6.4 函数重载如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载函数。 6.4.0 重载基础定义重载函数对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外其他所有的要素都相同。 判断两个形参的类型是否相异有时候两个形参列表看起来不一样，但实际上是相同的： 123// 声明的是同一个函数Record lookup(const Account &amp;acct);Record lookup(const Account &amp;); // 省略了形参的名字 重载和const形参顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来： 12345Record lookup(Phone);Record lookup(const Phone);Record lookup(Phone*);Record lookup(Phone* const); 另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的： 1234567// 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同// 定义了4个独立的重载函数Record lookup(Account &amp;); // 函数作用于Account的引用Record lookup(const Account &amp;); // 新函数，作用于常量引用Record lookup(Account *); // 新函数，作用于指向Account的指针Record lookup(const Account *); // 新函数，作用于指向常量的指针 const_cast 和重载const_cast 在重载函数的情景中最有用。举个例子： 1234// 比较两个string对象的长度，返回较短的那个引用const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125; 这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string 的引用。因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点： 1234string &amp;shorterString(string &amp;s1, string &amp;s2)&#123; auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1),const_cast&lt;const string&amp;&gt;(s2)); return const_cast&lt;string&amp;&gt;r;&#125; 在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的string&amp;，这显然是安全的。 调用重载的函数调用重载函数时有三种可能的结果： 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。 有多余一个函数可以匹配，但是每一个都不是最明显的最佳选择。此时也将发生错误，成为二义性调用。 6.4.1 重载与作用域重载对作用域的一般性质并没有什么改变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。 Note! 在C++语言中，名字查找发生在类型检查之前。 6.5 特殊用途语言特性6.5.1 默认实参我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，他后面的所有形参都必须有默认值。 12typedef string::size_type sz;string screen(sz ht = 24, sz wid = 80, char background = &#x27; &#x27;); 函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参，例如：要想覆盖background的默认值，必须为ht和wid提供实参： 12window = screen(,,&#x27;?&#x27;); // 错误：只能省略尾部的实参window = screen(&#x27;?&#x27;); // 调用screen(&#x27;?&#x27;,80,&#x27; &#x27;) 当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。 默认实参声明一个函数通常只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值得形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。 1234string screen(sz,sz,char = &#x27;&#x27;);string screen(sz,sz,char = &#x27;*&#x27;); // 错误：重复声明// 但是可以按照如下形式添加默认实参：string screen(sz = 24, sz = 80, char); //正确：添加默认实参 默认实参初始值局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参： 123456// wd、def、ht的声明必须出现在函数之外sz wd = 80;char def = &#x27; &#x27;;sz ht();string screen(sz = ht(), sz = wd, char = def);string window = screen(); //调用 screen(ht(),80,&#x27; &#x27;) 用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时： 12345void f2()&#123; def = &#x27;*&#x27;; // 改变默认实参的值 sz wd = 100; // 隐藏了外层定义的wd，但是没有改变默认值 window = screen(); // 调用了screen(ht(),80,&#x27;*&#x27;);&#125; 6.5.2 内联函数和 constexpr 函数内联函数可避免函数调用的开销将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。 假设我们把shorterString函数定义成内联函数，则如下调用 1cout &lt;&lt; shorterString(s1,s2) &lt;&lt; endl; 将在编译过程中展开成类似下面的形式 1cout &lt;&lt; (s1.size() &lt; s2.size() ? s1 : s2) &lt;&lt; endl; 从而消除了shorterString函数的运行时开销。 在shorterString函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了: 1234inline const string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt; s2.size() ? s1 : s2;&#125; 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。 constexpr 函数constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句： 12constexpr int new_sz() &#123;return 42;&#125;constexpr int foo = new_sz(); // 正确： foo是一个常量表达式 执行该初始化任务时，编译器把对constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐士地指定为内联函数。 我们允许constexpr函数的返回值并非一个常量： 123456// 如果arg是常量表达式，则scale(arg)也是常量表达式constexpr size_t scale(size_t cnt) &#123;return new_sze() * cnt; &#125;// 当scale的实参是常量表达式时，它的返回值也是常量表达式：反之则不然：int arr[scale(2)]; // 正确： scale(2)是常量表达式int i = 2; // i 不是常量表达式int a2[scale(i)] // 错误：scale(i)不是常量表达式 Note! constexpr 函数不一定返回常量表达式 把内联函数和constexpr 函数放在头文件内对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。 6.5.3 调试帮助assert 预处理宏assert是一种预处理宏。所谓预处理宏其实是一个预处理变量，他的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件： 1assert(expr); 首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。 和预处理变量一样，宏名字在程序内必须唯一。含有cassert头文件的程序不能再定义名为assert的变量、函数或者其他实体。在实际编译过程中，即使我们没有包含cassert头文件，也最好不要为了其他目的使用assert。很多头文件都包含了cassert，这就意味着即使你没有直接包含cassert，它也很有可能通过其他途径包含在你的程序中。 12// assert宏常用于检查“不能发生”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时，程序可以包含一条如下所示的语句：assert(word.size() &gt; threshold)； NDEBUG预处理变量assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。 我们可以使用一个#define 语句定义NDEBUG，从而关闭调试状态。 除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码：如果定义了NDEBUG，这些代码将被忽略。 6.6 函数匹配6.6.0 寻找匹配方法确定候选函数和可行函数 选定本次调用对应的重载函数集。 考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数。 从候选函数中选择与本次调用最匹配的函数。 寻找最佳匹配（如果有的话）基本思想是：实参类型与形参类型越接近，他们匹配的越好。 Note! 调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。 6.6.1 实参类型转换为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级。 精确匹配，包括以下情况： 实参类型和形参类型相同。 实参从数组类型或函数类型转换成对应的指针类型。 向实参添加顶层const或者从实参中删除顶层const。 通过const转换实现的匹配。 通过类型提升实现的匹配。 通过算术类型转换或指针转换实现的匹配。 通过类类型转换实现的匹配。 函数匹配和const实参1234567Record lookup(Account&amp;);Record lookup(const Account&amp;);const Account a;Account b;lookup(a); // 调用lookup(const Account&amp;)lookup(b); // 调用lookup(Account&amp;) 在第一个调用中，我们传入的是const 对象a。因为不能把普通引用绑定到const对象上，所以此例中唯一可行的函数是以常量引用作为形参的那个函数。 在第二个调用中，两个函数都是可行的，因为我们既可以使用b初始化常量引用也可以用它初始化非常量引用。然而，用非常量对象初始化常量引用需要类型转换。 指针也同样如此！ 6.7 函数指针6.7.1 函数指针函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参共同决定，与函数名无关。 12// 比较两个string对象的长度bool lengthCompare(const string &amp;,const string &amp;); 该函数的类型是bool（const string&amp;, const string&amp;）。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可： 12// pf 指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型bool (*pf) (const string &amp;,const string &amp;); // 未初始化 从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。 Note! *pf 两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数。 使用函数指针当我们把函数名作为一个值使用时，该函数自动的转换成指针。例如，按照如下形式我们可以将lengthCompare的地址赋给pf： 12pf = lengthCompare; // pf 指向名为lengthCompare的函数pf = &amp;lengthCompare; // 等价的赋值语句：取地址符是可选的 此外，我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针： 123bool b1 = pf(&quot;hello&quot;,&quot;goodbye&quot;); // 调用lengthCompare函数bool b2 = (*pf)(&quot;hello&quot;,&quot;goodbye&quot;); // 一个等价的调用bool b3 = lengthCompare(&quot;hello&quot;,&quot;goodbye&quot;); // 另一个等价的调用 在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何一个函数。 123456string::size_type sumLength(const string&amp;, const string&amp;);bool cstringCompare(const char*, const char*);pf = 0; // 正确：pf不指向任何函数pf = sumlength; // 错误：返回类型不匹配pf = cstringCompare; // 错误：形参类型不匹配pf = lengthCompare; // 正确：函数和指针的类型精确匹配 重载函数的指针当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。如果定义了指向重载函数的指针 1234void ff(int*);void ff(unsigned int);void (*pf1)(unsigned int) = ff; // pf1 指向 ff(unsigned) 编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配 12void (*pf2)(int) = ff; // 错误：没有任何一个ff与该形参列表匹配double (*pf3)(int*) = ff; // 错误： 返回类型不匹配 函数指针形参和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用： 123456// 第三个形参是函数类型，它会自动地转换成指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;));// 等价的声明：显示的将形参定义成指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;));// 我们可以直接把函数作为实参使用，此时它会自动转换成指针：useBigger(s1,s2,lengthCompare); 正如useBigger的声明语句所示，直接使用函数指针类型显得冗余而繁琐。类型别名和decltype能让我们简化使用了函数指针的代码： 1234567// Func 和 Func2 是函数类型typedef bool Func(const string&amp;, const string&amp;);typedef decltype(lengthCompare) Func2; // 等价的类型// FuncP 和 FuncP2 是指向函数的指针typedef bool(*FuncP)(const string&amp;, const string&amp;);typedef decltype(lengthCompare) *FuncP2; // 等价的类型// 因为 decltype 的结果是函数类型，所以只有在结果前面加上*才能得到指针。 123// useBigger 的等价声明，其中使用了类型别名void useBigger(const string&amp;, const string&amp;, Func);void useBigger(const string&amp;, const string&amp;, FuncP2); 这两个声明语句声明的是同一个函数，在第一条语句中，编译器自动的将 Func 表示的函数类型转换成指针。 返回指向函数的指针和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而， 我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要向声明一个返回函数指针的函数，最简单的办法是使用类型别名： 12using F = int(int*, int); // F是函数类型，不是指针using PF = int(*)(int*, int); // PF是指针类型 必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针，我们必须显示的将返回类型指定为指针： 123PF f1(int); // 正确： PF 是指向函数的指针，f1返回指向函数的指针F f1(int); // 错误：F是函数类型，f1不能返回一个函数F *f1(int); // 正确：显示的指定返回类型是指向函数的指针 当然，我们也能用下面的形式直接声明f1: 12int (*f1(int))(int*, int);// 按照由内向外的顺序阅读这条声明语句：我们看到f1有形参列表，所以f1是一个函数：f1前面有*，所以f1返回一个指针，进一步观察发现，指针的类型本身也含有形参列表，因此指针指向函数，该函数的返回类型是int 我们还可以使用尾置返回类型的方式 1auto f1(int) -&gt; int (*)(int*, int); 将auto和decltype用于函数指针类型如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。 1234string::size_type sumLength(const string&amp;, const string&amp;);string::size_type largeLength(const string&amp;, const string&amp;);// 根据其形参的取值，getFcn函数返回指向 sumLength 或者 largeLength的指针decltype(sumLength) *getFcn(const string &amp;); 声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。因此，我们需要显示的加上*以表明我们需要返回指针。 6.8 总结 函数有几个形参，我们就必须提供相同数量的实参 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针 可以将局部变量定义成static类型从而获得局部静态对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。 如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0 和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了 尽量使用常量引用 数组形参 12345// 尽管形式不同，但这三个print函数是等价的// 每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]); // 可以看出来，函数的意图是作用于一个数组void print(const int[10]); // 这里的维度表示我们期望数组含有多少元素，实际不一定 管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。 管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库的启发。 第三种管理数组实参的方法是专门定义一个表示数组大小的形参。 当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针 形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。 和vector一样，initializer_list也是一种模板类型。和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法修改其中的值。 省略符形参应该仅仅用于C和C++通用的类型。特别注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝 省略符形参只能出现在形参列表的最后一个位置，省略符形参所对应的实参无需类型检查。 不要返回局部对象的引用或指针 声明返回数组指针的函数 1int (*func(int i))[10]; 可以按照以下的顺序来逐层理解该声明的含义： func(int i) 表示调用func函数时需要一个int类型的实参。 (*func(int i)) 意味着我们可以对函数调用的结果执行解引用操作 (*func(int i))[10] 表示解引用func的调用将得到一个大小为10的数组 int (*func(int i))[10] 表示数组中的元素是int类型 简化上述func声明的方法，还可以使用尾置返回类型。 12// func 接受一个int 类型的实参，返回一个指针，该指针指向含有10个整数的数组auto func(int i) -&gt; int(*)[10]; 如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。 如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载函数。 顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同 如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。 我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，他后面的所有形参都必须有默认值 函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。而且只能省略尾部的实参。 一个函数通常只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值得形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。 局部变量不能作为默认实参 用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时 将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。内联函数可避免函数调用的开销。 在shorterString函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了 constexpr函数定义：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句 在编译过程中，constexpr函数被隐士地指定为内联函数。 对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。 精确匹配，包括以下情况： 实参类型和形参类型相同。 实参从数组类型或函数类型转换成对应的指针类型。 向实参添加顶层const或者从实参中删除顶层const。 通过const转换实现的匹配。 通过类型提升实现的匹配。 函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参共同决定，与函数名无关。 当我们把函数名作为一个值使用时，该函数自动的转换成指针 此外，我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针 在指向不同函数类型的指针间不存在转换规则 和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针 和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而， 我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理","categories":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://www.pkubailu.cn/categories/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"https://www.pkubailu.cn/tags/C-%E5%9F%BA%E7%A1%80/"}]},{"title":"C++ Primer 第5章 控制语句","slug":"C-Primer-第5章","date":"2021-11-27T13:41:05.000Z","updated":"2021-11-27T13:41:05.000Z","comments":true,"path":"2021/11/27/C-Primer-第5章/","link":"","permalink":"https://www.pkubailu.cn/2021/11/27/C-Primer-%E7%AC%AC5%E7%AB%A0/","excerpt":"","text":"第 5 章 控制语句 第5章 语句5.3 控制语句5.3.2 switch语句case关键字和它对应的值一起被称为case标签。case标签必须是整型常量表达式： 123456char ch = getVal();int ival = 42;switch(ch) &#123; case 3.14: // 错误：case标签不是一个整数 case ival: // 错误：case标签不是常量&#125; 请记住整型常量这四个字，不满足这个特性的不能作为case值，编译会报错。这也决定了switch的参数必须是整型的。整型，意味着浮点数是不合法的，如case 3.14：不可以；常量，意味着变量是不合法的，如case ival： ival不能是变量。 C++中的const int，注意仅限于C++中的const，C中的const是只读变量，不是常量； 单个字符，如case ‘a’: 是合法的，因为文字字符是常量，被转成ASCII码，为整型； 使用#define定义的整型，#define定义的一般为常量，比如#define pi 3.14，但是也必须是整型才可以； 使用enum定义的枚举成员。因为枚举成员是const的，且为整型。如果不手动指定枚举值，则默认枚举值为从0开始，依次加1。如下这段代码正常运行： 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;enum color&#123;red,yellow,green&#125;;int main()&#123; int co = 2; switch(co) &#123; case red: cout&lt;&lt;&quot;red&quot;&lt;&lt;endl; break; case yellow: cout&lt;&lt;&quot;yellow&quot;&lt;&lt;endl; break; case green: cout&lt;&lt;&quot;green&quot;&lt;&lt;endl; break; default: cout&lt;&lt;&quot;no match color&quot;&lt;&lt;endl; break; &#125; return 0;&#125; 5.6 try语句块和异常处理在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。 寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch字句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。 如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数，一般情况下，执行该函数将导致程序非正常退出。 如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。","categories":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://www.pkubailu.cn/categories/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"https://www.pkubailu.cn/tags/C-%E5%9F%BA%E7%A1%80/"}]},{"title":"2021/11/14","slug":"2021-11-22","date":"2021-11-22T12:19:07.000Z","updated":"2021-11-22T12:19:07.000Z","comments":true,"path":"2021/11/22/2021-11-22/","link":"","permalink":"https://www.pkubailu.cn/2021/11/22/2021-11-22/","excerpt":"","text":"我觉得我有做菜的天赋！ 时间点倒回到周五：迫不及待回到家，打开包装看看我的小煲，不禁越看越喜欢，终于可以上手实操了，而且此时正好饥肠辘辘，啥也不说了，先来个黑米粥暖暖胃！黑米粥比例：1杯米 ： 5杯水。做出来的黑米粥是真的香，整个屋都是米香味，我直接来了三碗！周六早上起得有些晚了，而且红烧肉的材料也不齐，红烧肉计划泡汤了，我直接掏出手机打开抖音，滑到最上面找到咖喱煲仔饭，欣赏完视频记下食材，直奔门口超市，买好食材后，回家请出小煲，这时我和蒙蒙双线程开工，一小会便做出来了咖喱煲仔饭和可乐鸡翅。我的咖喱煲仔饭真的太香了，怎么也没想到能做出来这么好吃的饭，而且还是第一次真正意义上的做饭，这碗煲仔饭给了我很大的自信！晚上我终于做了丫头很喜欢吃的西红柿炒蛋，在抖音上学习了一下做法，感觉还是比较简单的，实际做的时候也没遇到什么困难，不过有几个地方是值得优化的 可以先用热水给西红柿去一下皮，这样口感更好。 家里没有准备白糖，临时拿冰糖代替的，做的时候冰糖没有完全化开，影响了口感。 我们的锅会一直控温，一开始炒鸡蛋的时候弄了半天没弄好，不过鸡蛋炒出来色泽很好也很嫩！蒙蒙做的苦瓜炒腊肉也很好吃，腊肉实在太香了，这个食材是个神器，不过苦瓜真的有点苦，我吃的不多。白天加完班后，晚上和蒙蒙商量好了来一手麻辣香锅，食材买的太多了，绿色蔬菜种类不够多，下在锅里满满一锅炒起来不是很方便，我听了丫头的话把腊肉先炒了一下，感觉可以不用炒的，腊肉炒完了太老吃起来很费劲。这个件事告诉我和丫头做饭和开车一样，只能自己来，不能听旁边人瞎指挥！麻辣香锅整体还是很不错的，金针菇有一点咸了，其他的食材都还不错，麻辣香锅的食材不太好买，很难控制量，特别容易买多！我焖的米饭中加了一点黑米，最后出来的效果很好，开盖满屋香味！又是饱饱的一顿！ 文章的最后，我必须感谢我的丫头让我挖掘出了做饭是如此的有意思。 我立志学会丫头喜欢的每一种饭，以后做给你吃！","categories":[{"name":"private","slug":"private","permalink":"https://www.pkubailu.cn/categories/private/"}],"tags":[]},{"title":"C++ Primer 第4章 表达式","slug":"C-Primer-第4章","date":"2021-11-20T14:55:26.000Z","updated":"2021-11-20T14:55:26.000Z","comments":true,"path":"2021/11/20/C-Primer-第4章/","link":"","permalink":"https://www.pkubailu.cn/2021/11/20/C-Primer-%E7%AC%AC4%E7%AB%A0/","excerpt":"","text":"第 4 章 表达式 第 4 章 表达式4.1 基础4.1.1 重载运算符当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为重载运算符 4.1.2 左值和右值当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。例如： 假定p的类型是int ，因为解引用运算符生成左值，所以decltype(*p)的结果是int&amp;。另一方面，因为取地址运算符生成右值，所以decltype(&amp;p)的结果是int*,也就是说，结果是一个指向整型指针的指针。 4.2 算术运算符在除法运算中，如果两个运算对象的符号相同则商为正（如果不为0的话），否则商为负。C++新标准规定商一律向0取整（即直接切除小数部分）。 C++新标准规定：(-m)/n 和 m/(-n)都等于-(m/n), m%(-n)等于m%n, (-m)%n等于-(m%n)。 4.6 成员访问运算符点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr-&gt;mem等价于(*p).mem 4.7 条件运算符条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算表达式时，通常需要在它的两端加上括号。 4.8 位运算符左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位。 4.9 sizeof运算符sizeof运算符返回一条表达式或一个类型名字所占的字节数。 1234// 运算符的运算对象有两种形式sizeof (type)sizeof expr// 在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值。 因为sizeof不会实际求运算对象的值，所以即使p是一个无效(即未初始化)的指针也不会有什么影响。sizeof不需要真的解引用指针也能知道它所指对象的类型。 sizeof运算符的结果部分地依赖于其作用的类型： 对char或者类型为char的表达式执行sizeof运算，结果得1. 对引用类型执行sizeof运算得到被引用对象所占空间的大小。 对指针执行sizeof运算得到指针本身所占空间的大小。 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次siezof运算并将所得结果求和，注意，sizeof运算不会把数组转换成指针来处理。 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。 123// sizeof(ia)/sizeof(*ia)返回ia的元素数量constexpr size_t sz = sizeof(ia)/sizeof(*ia);int arr2[sz]; //正确：sizeof返回一个常量表达式 4.11 类型转换在下面这些情况下，编译器会自动地转换运算对象的类型： 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。 在条件中，非布尔值转换成布尔类型。 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。 函数调用时也会发生类型转换。 4.11.1 算数转换 首先执行整型提升。如果结果的类型匹配，无需进行进一步的转换。如果两个运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。假设两个类型分别是unsigned int 和 int，则int类型的运算对象转换成unsigned int 类型。需要注意的是，如果int型的值恰好为负值，则采用取模的方式转换。 剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。 4.11.2 其他隐式类型转换数组转换成指针在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针 12int ia[10];int *ip = ia; //ia 转换成指向数组首元素的指针 当数组被用作decltype关键字、取地址符(&amp;)、sizeof及typeid等运算符的参数时，不会发生转换。 指针的转换常量整数值0或者字面值nullptr能转换成任意指针类型 指向任意非常量的指针能转换成void* 指向任意对象的指针能转换成const void* 转换成布尔类型存在一种从算术类型或指针类型向布尔类型自动转换的机制。 123char *cp = get_string();if (cp) //如果指针cp不是0，条件为真while(*cp) // 如果*cp不是空字符，条件为真 转换成常量允许将指向非常量类型的指针转换成指向相应常量类型的指针，对于引用也是这样。 1234int i;const int &amp;j = i; // 非常量转换成const int 的引用const int *p = &amp;i; //非常量的地址转换成const的地址int &amp;r = j, *q = p; //错误：不允许const转换成非常量 类类型定义的转换12string s, t = &quot;a value&quot;; // 字符串字面值转换成string类型while(cin &gt;&gt; s) // while 的条件部分把cin转换成布尔值 4.11.3 显示转换命名的强制类型转换12345// 一个命名的强制类型转换具有如下形式：cast-name&lt;type&gt;(expression);// type 是转换的目标类型// expression 是要转换的值// cast-name 是 static_cast、dynamic_cast、const_cast、reinterpret_cast中的一种 static_cast任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。 12// 进行强制类型转换以便执行浮点数除法double slope = static_cast&lt;double&gt;(j) / i; 当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。 static_cast对于编译器无法自动执行的类型转换也非常有用。 1234// 使用static_cast找回存在于void*指针中的值void* p = &amp;d; // 正确：任何非常量对象的地址都能存入void*double *dp = static_cast&lt;double*&gt;(p); //正确：将void*转换回初始的指针类型// 我们必须确保转换后所得的类型就是指针所指的类型 const_castconst_cast只能改变运算对象的底层const 12const char *pc;char *p = const_cast&lt;char*&gt;(pc); // 正确：但是通过p写值是未定义的行为 只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。 reinterpret_castreinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。例如： 12int *ip;char *pc = reinterpret_cast&lt;char*&gt;(ip); 我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。 4.12 总结 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 在除法运算中，如果两个运算对象的符号相同则商为正（如果不为0的话），否则商为负。C++新标准规定商一律向0取整（即直接切除小数部分）。 C++新标准规定：(-m)/n 和 m/(-n)都等于-(m/n), m%(-n)等于m%n, (-m)%n等于-(m%n)。 点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr-&gt;mem等价于(*p).mem 条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算表达式时，通常需要在它的两端加上括号。 左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位。 sizeof运算符返回一条表达式或一个类型名字所占的字节数 因为sizeof不会实际求运算对象的值，所以即使p是一个无效(即未初始化)的指针也不会有什么影响。sizeof不需要真的解引用指针也能知道它所指对象的类型。 sizeof运算符的结果部分地依赖于其作用的类型： 对char或者类型为char的表达式执行sizeof运算，结果得1. 对引用类型执行sizeof运算得到被引用对象所占空间的大小。 对指针执行sizeof运算得到指针本身所占空间的大小。 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次siezof运算并将所得结果求和，注意，sizeof运算不会把数组转换成指针来处理。 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。 首先执行整型提升，将小类型的运算对象转换成较大的类型 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针 当数组被用作decltype关键字、取地址符(&amp;)、sizeof及typeid等运算符的参数时，不会发生转换 指向任意非常量的指针能转换成void*，指向任意对象的指针能转换成const void* 存在一种从算术类型或指针类型向布尔类型自动转换的机制。 允许将指向非常量类型的指针转换成指向相应常量类型的指针，对于引用也是这样。 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。 当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。 static_cast对于编译器无法自动执行的类型转换也非常有用。 const_cast只能改变运算对象的底层const","categories":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://www.pkubailu.cn/categories/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"https://www.pkubailu.cn/tags/C-%E5%9F%BA%E7%A1%80/"}]},{"title":"2021/11/14","slug":"2021-11-14","date":"2021-11-14T14:22:28.000Z","updated":"2021-11-14T14:22:28.000Z","comments":true,"path":"2021/11/14/2021-11-14/","link":"","permalink":"https://www.pkubailu.cn/2021/11/14/2021-11-14/","excerpt":"","text":"鸿雁在云鱼在水，惆怅此情难寄。 11月11日，周四，又是一年一度的双十一狂欢节，精心挑选了三件商品，踏踏实实的扔给了丫头帮我购买，不用操心价钱是否全网最低，不用关心物流，知道丫头都会帮我考虑全面的，这个时候明白幸福就是不管自己在外面有多么忙碌，家里都会有个人帮你处理好生活的琐事，让你心安！时间：11月12日中午。地点：软件园23号楼5楼食堂。丫头：可是很多时候鱼与熊掌不可兼得，你会选哪个？我：选鱼。丫头：为什么选鱼？我：因为余生有你！与往常一样的中午，平平淡淡的对话，心之所想，口之所言，便发生了最美的共鸣！幸福就是：你之所想，我之所言！11月13日，周六，早上起来躺着缓神之际想给丫头点点东西吃，也不知道为什么就是觉得你最近胃口一般，我就点了个可以开胃的菜，想打电话和你说一声，结果电话恰好没人接，我顿时感到天时地利，便直接付款！中午丫头饱餐了一顿“老昌春饼”,我和蒙蒙做了最豪华的面！我们都美美的！下午和丫头开始视频后，便觉得越来越想你，特别希望你能在我身边，这种思念的感觉非常强烈，我不知如何用文字诉说，整个下午我都反反复复的说“我好想你呀！”，不知道我的心情你能体会多少，但我确实实在在的思你想你不得闲！晚上我们终于有时间一起game了一会，好久都没有一起happy了，玩的也是真的开心，合欢树上合欢果，合欢树下你和我！","categories":[{"name":"private","slug":"private","permalink":"https://www.pkubailu.cn/categories/private/"}],"tags":[]},{"title":"C++ Primer 第3章 字符串、向量和数组","slug":"C-Primer-第3章","date":"2021-11-13T11:51:59.000Z","updated":"2021-11-13T11:51:59.000Z","comments":true,"path":"2021/11/13/C-Primer-第3章/","link":"","permalink":"https://www.pkubailu.cn/2021/11/13/C-Primer-%E7%AC%AC3%E7%AB%A0/","excerpt":"","text":"第3章 字符串、向量和数组 第3章 字符串、向量和数组3.1 命名空间的using声明有了using声明就无需专门的前缀（形如命名空间::）也能使用所需的名字了。 using声明具有如下的形式： 12using namespace::name;// 一旦声明了上述语句，就可以直接访问命名空间中的名字 WARNING !头文件不应包含using声明 3.2 标准库类型 string3.2.1 定义和初始化string对象 直接初始化和拷贝初始化如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化。 3.2.2 string对象上的操作 读写string对象123456789int main()&#123; string s; cin &gt;&gt; s; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125;// 在执行读取操作时，string对象会自动忽略开头的空白（即空格、换行、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。// 如果输入是&quot; hello world! &quot;则输出将是&quot;hello&quot; 使用getline读取一整行如果希望在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的 &gt;&gt; 运算符。 getline从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，如果一开始输入的是换行符，那么所得的结果是个空string。 比较 string 对象字典序规则！ 3.2.3 处理string对象中的字符 处理每个字符？使用基于范围的for语句语法形式： 12for (declaration : expression) statement 3.3 标准库类型 vector编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。 vector 是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector 3.3.1 定义和初始化vector对象 列表初始化vector对象在大多数情况下这些初始化方式可以相互等价的使用，不过也并非一直如此。两种例外情况如下： 使用拷贝初始化时（即使用=时）只能提供一个初始值； 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。 第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化。 值初始化通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。 12vector&lt;int&gt; ivec(10); //10个元素 每个都初始化为0vector&lt;string&gt; svec(10) // 10个元素，每个都是空的string对象 对这种初始化的方式有两个特殊限制： 有些类要求必须明确的提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始化的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化： 1vector&lt;int&gt; vi = 10; // 错误：必须使用直接初始化的形式指定向量大小 列表初始值还是元素数量 3.3.2 向vector对象中添加元素可以先创建一个空的vector对象，然后在运行时再利用vector的成员函数push_back向其中添加元素。 ! 范围for语句体内不应该改变其所遍历序列的大小。 3.3.3 其他vector操作 Note：要使用size_type，需要先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型 12vector&lt;int&gt;::size_type // 正确vector::size_type // 错误 两个vector对象相等当且仅当他们所含的元素个数相同，而且对应位置的元素值也相同。 关系运算符依照字典顺序进行比较：如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。 只有当元素的值可比较时，vector对象才能被比较。 3.4 迭代器介绍有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。 3.4.1 使用迭代器和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器，end成员则负责返回指向容器”尾元素的下一位置“的迭代器，简称为尾迭代器。 迭代器运算符 将迭代器从一个元素移动到另外一个元素迭代器使用递增（++）运算符来从一个元素移动到下一个元素。 Note：因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。 迭代器类型迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型 const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。 begin和end运算符1234vector&lt;int&gt; v;const vector&lt;int&gt; cv;auto it1 = v.begin(); // it1 的类型是vector&lt;int&gt;::iteratorauto it2 = cv.begin(); // it2 的类型是vector&lt;int&gt;::const_iterator 为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend： 1auto it3 = v.cbegin(); // it3 的类型是vector&lt;int&gt;::const_iterator 不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。 结合解引用和成员访问操作12(*it).empty() // 解引用it，然后调用结果对象的empty()成员*it.empty() //错误： 试图访问it的名为empty的成员，但it是个迭代器，没有empty成员 为了简化上述表达式，C++语言定义了箭头运算符(-&gt;)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说it-&gt;mem和(*it).mem表达的意思相同。 某些对vector对象的操作会使迭代器失效 谨记！，但凡是使用了迭代器的循环体，都不要向迭代其所属的容器添加元素。 3.4.2 迭代器运算 迭代器的算术运算对于string或vector的迭代器来说，除了判断是否相等，还能使用关系运算符(&lt;、&lt;=、&gt;、&gt;=)对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（或者尾元素的下一位置）。例如，假设it和mid是同一个vector对象的两个迭代器，可以用下面的代码来比较他们所指的位置谁前谁后： 12if (it &lt; mid) // 处理vector前半部分的元素 3.5 数组3.5.1 定义和初始化内置数组默认情况下，数组的元素被默认初始化 Warning! 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。 显示初始化数组 字符数组的特殊性 不允许拷贝和赋值 理解复杂的数组声明定义数组的指针和数组的引用： 对于数组而言，由内向外阅读要比从右向左好多了。例如：首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。 3.5.2 访问数组元素最好的办法是使用范围for语言。 使用数组下标的时候，通常将其定义为size_t类型。 数组除了大小固定这一特点外，其他用法与vector基本类似。 3.5.3 指针和数组 Note： 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。 这一结论有很多隐含的意思： 当使用数组作为一个auto变量的初始值时。推断得到的类型是指针而非是数组： 123int ia[] = &#123;0,1,2,3,4&#125;; // ia 是一个含有5个整数的数组auto ia2(ia); // ia2是一个整型指针,指向ia的第一个元素ia2 = 42; // 错误：ia2是一个指针，不能用int值给指针赋值 必须指出的是，当使用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组： 1234// ia3 是一个含有5个整数的数组decltype(ia) ia3 = &#123;0,1,2,3,4&#125;;ia3 = p; // 错误：不能用整形指针给数组赋值ia3[4] = i; //正确：把i的值赋给ia3的一个元素 指针也是迭代器允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上： 123int arr[] = &#123;0,1,2,3,4&#125;;int *p = arr; // p指向arr的第一个元素++p; // p指向arr[1] 利用指针的循环 123int *e = &amp;arr[10];for (int *b = arr; b != e; ++b) cout &lt;&lt; *b &lt;&lt;endl; 标准库函数begin和endC++新标准引入了两个名为begin和end的函数 123int ia[] = &#123;0,1,2,3,4&#125;; // ia是一个含有5个整数的数组int *beg = begin(ia); //指向ia首元素的指针int *last = end(ia); // 指向arr尾元素的下一位置的指针 Note：一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。 指针运算指向数组元素的指针可以执行所有的迭代器运算。例如：解引用、递增、比较、与整数相加、两个指针相减等。 给指针加（减）一个整数，得到的新指针仍需要指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置。 1234//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置int *p = arr + sz; //使用警告:不要解引用！int *p2 = arr + 10; // 错误：arr只有5各元素，p2的值未定义// 如果计算所得的指针超出了上述范围就将产生错误，而且这种错误编译器一般发现不了。 如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针也允许彼此相减，结果当然是0； 解引用和指针运算的交互12int ia[] = &#123;0,2,4,,6,8&#125;; //含有5个整数的数组int last = *(ia + 4); //正确：把last初始化成8，也就是ia[4]的值 下标和指针对数组执行下标运算其实是对指向数组元素的指针执行下标运算： 1234int i = ia[2]; //ia转换成指向数组首元素的指针 //ia[2]得到(ia + 2)所指的元素int *p = ia; // p指向ia的首元素i = *(p + 2) // 等价于i = ia[2] 只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算： 123int *p = &amp;ia[2]; // p指向索引为2的元素int j = p[1]; // p[1]等价于 *(p+1),就是ia[3]表示的那个元素int k = p[-2]; // p[-2]是ia[0]表示的那个元素 虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。 3.5.4 C风格字符串C标准库String函数 传入此类函数的指针必须指向以空字符作为结束的数组： 12char ca[] = &#123;&#x27;c&#x27;,&#x27;+&#x27;,&#x27;+&#x27;&#125;; // 不以空字符结束cout &lt;&lt; strlen(ca) &lt;&lt; endl; // 严重错误：ca没有以空字符结束 比较字符串比较C风格的字符串和比较标准库string对象的方法大相径庭。 string对象的比较可以用关系运算符，而C风格字符串用关系运算符比较的是指针所指对象的地址。 123456string s1 = &quot;A string example&quot;;string s2 = &quot;A different example&quot;;if (s1 &lt; s2) // false: s2 小于 s1const char ca1[] = &quot;A string example&quot;;const char ca2[] = &quot;A different example&quot;;if (ca1 &lt; ca2) // 未定义的：试图比较两个无关地址 3.5.5 与旧代码的接口混用string对象和C风格字符串允许使用字符串字面值来初始化string对象: 1string s(&quot;hello world&quot;); // s的内容是hello world 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代： 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值。 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）;在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。 上述性质反过来不成立！ 不能使用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数: 12char *str = s; //错误: 不能用string对象初始化char*const char *str = s.c_str(); // 正确 使用数组初始化vector对象不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。 12int int_arr[] = &#123;0,1,2,3,4&#125;;vector&lt;int&gt; ivec(begin(int_arr), end(int_arr)); 在上述代码中，用于创建ivec的两个指针实际上指明了用来初始化的值在数组int_arr中的位置，其中第二个指针应指向待拷贝区域尾元素的下一位置。 应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。 3.6 多维数组C++语言中的多维数组其实是数组的数组。 1234567size_t cnt = 0;for (auto &amp;row : ia) &#123; for (auto &amp;col : row) &#123; col = cnt; cnt++; &#125;&#125; Note! 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。 3.6.1 指针和多维数组当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。 Note! 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。 123// 在下述声明中，圆括号必不可少int *ip[4]; // 整型指针的数组int (*ip)[4]; // 指向含有4个整数的数组 12345678//输出ia中每个元素的值，每个内层数组各占一行// p指向含有4个整数的数组for (auto p = ia; p != ia + 3; ++p) &#123; for (auto q = *p; q != *p + 4; ++q) &#123; cout &lt;&lt; *q &lt;&lt; &#x27;&#x27;; &#125; cout &lt;&lt; endl;&#125; 使用标准库函数begin和end也能实现同样的功能。 123456for (auto p = begin(ia); p != end(ia); ++p) &#123; for (auto q = begin(*p); q != end(*p); ++q) &#123; cout &lt;&lt; *q &lt;&lt; &#x27;&#x27;; &#125; cout &lt;&lt; endl;&#125; 3.7 总结 如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化。 在执行读取操作时，string对象会自动忽略开头的空白（即空格、换行、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。如果输入是” hello world! “则输出将是”hello” getline从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，如果一开始输入的是换行符，那么所得的结果是个空string。 String 对象的比较遵循字典序规则 编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。 列表初始化与值初始化： 大多数情况下这些初始化方式可以相互等价的使用，不过也并非一直如此。两种例外情况如下： 使用拷贝初始化时（即使用=时）只能提供一个初始值； 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化。 值初始化的两个特殊限制： 有些类要求必须明确的提供初始值，对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化 范围for语句体内不应该改变其所遍历序列的大小。 要使用size_type，需要先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型 12vector&lt;int&gt;::size_type // 正确vector::size_type // 错误 关系运算符依照字典顺序进行比较：如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。 只有当元素的值可比较时，vector对象才能被比较。 有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。 因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。 C++语言定义了箭头运算符(-&gt;)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说it-&gt;mem和(*it).mem表达的意思相同。 谨记！，但凡是使用了迭代器的循环体，都不要向迭代其所属的容器添加元素 参与比较的两个迭代器必须合法而且指向的是同一个容器的元素。通过比较可以决定两个迭代器的先后位置。 默认情况下，数组的元素被默认初始化。如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。 数组不允许拷贝和赋值 需要理解复杂的数组声明（3.5.1节） 使用数组下标的时候，通常将其定义为size_t类型。 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针 当使用数组作为一个auto变量的初始值时。推断得到的类型是指针而非是数组 当使用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组 允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上 指向数组元素的指针可以执行所有的迭代器运算。例如：解引用、递增、比较、与整数相加、两个指针相减等 给指针加（减）一个整数，得到的新指针仍需要指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置 对数组执行下标运算其实是对指向数组元素的指针执行下标运算 虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。 传入C风格字符串的函数的指针必须指向以空字符作为结束的数组 string对象的比较可以用关系运算符，而C风格字符串用关系运算符比较的是指针所指对象的地址 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代： 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值。 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）;在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。 不能使用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数: 12char *str = s; //错误: 不能用string对象初始化char*const char *str = s.c_str(); // 正确 不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。 12int int_arr[] = &#123;0,1,2,3,4&#125;;vector&lt;int&gt; ivec(begin(int_arr), end(int_arr)); 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型 当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组","categories":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://www.pkubailu.cn/categories/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"https://www.pkubailu.cn/tags/C-%E5%9F%BA%E7%A1%80/"}]},{"title":"2021/11/06","slug":"2021-11-06","date":"2021-11-06T07:46:15.000Z","updated":"2021-11-06T07:46:15.000Z","comments":true,"path":"2021/11/06/2021-11-06/","link":"","permalink":"https://www.pkubailu.cn/2021/11/06/2021-11-06/","excerpt":"","text":"0082a7e0c83ebf901f977394e654d43789a4ffb1424139c5c301df05f4e14bbeeb58b19d9995becaa9edef5abeb4bd37f64ecdb767065eb1f89b6f1da75d8b1634043112af789e1cf01de0285ff4cbc6a39a89e3b47f433eb7ff1c93642efe492b8cb53d2f859725988258787a775c7ee9b4e7d7bda6aca2b063a62af3d67cb3f7e7edfcdf1ae0f591ebeaccb476bfe3c591ce9bcd2e50045392ae066b3fb75430657b52bed258d85cdb3c5a2a41f780634a40e5e1062f9cae078a7007ba0f673662a50f3aac3340161039ce2a95cfa73d54f83402243faa5e2377a53a9744b6067905d997c6499eb5e1dadba6995e30793445a4cc1841b88829be0c88c07bc8c2286930b7ce4266b8f569d1ae091bc59d02a433428b463093a93285bd249386f08c3fa0e6e1b6874f30ea347c4661605a4d033f88eb8c466967dacd75b7c4cf25757590391a9f67567dc2764db38dc381c1b254c93dca339eee8de80be47f6042bdee351212d9ac6e19b812ac6620933a32060294f9788a14b073fe5a1c060b42c0f1377ef3b402d0d827419a4a604b57cb1737867186131633d535f1c7eacc62354f4dc60a41285d20d82cfe523934512dcaf655f2377211a3ccd07ea932848126f5af3bea85ee5bff2dc76e482c475c26a4dc8a0be9c345f56364f2fec70d252d04b100b8051d4474bd8e12ed7fd6eb5a458ca09b893544c2d2d914fa7446eee03cdb926d1e3162848cde09b2ef64a750c48b49c638f9dd701a9d3f48bc6828221dccc1e0f1b434d4f2accb7f4bd160e238162408fcf9b894b2cb8ddb9e2906d0f2c8890e35d5a8fd3e5fefbc2ca06931c5a29218e3bc1920ab6d2fc70efe2705387bfbb45e6deeb86690ca46e8bfb105584f2cc73e42d6b12921a1923410fd5ec6d96f47aeb6d2af94a28f9a9a6339f30fc0fd09c0da6b1ae9cb4eeeb5e8f0d373ab87e9fc65f7840d7c97b4fd525a166fc81af85d7fed31cab95e14f2919dad21d0ee5786af4917989f87955e223240c7b43eaba0489d9b317e584bb5e1f07fcced254a05541140cae780be64f724c4875d6f4567f28ed96ffb2c94a7ff8e81813c98825afb04eb0a1895176b33484aee43f1547e56a75b1e70fe0554b761c9854ea0f4702267430d158571dd45ce706e22a0a0266ba8bf229bffa5929bbb397ef161a94473b3bcbe8fc0f85023cf2232ff0d4ceb099d93f0c7550e596978a1646df1b531c96da5ffdbb2ac994bc556f724b568075f2caf264d867f08f593ea575ad3c32d618e2b131d61b65634d6d8547f235a20ec42ca1957c1c024f0abd46e0f3e78a3b8138f9680e2a72404cbe3fbb99d917001b021b5252c873458906d8889e42139f40c18b75118c49185a795bd8713566b496bbc1b8ab6a0cba9b58e107b7a258b70ceba683ebab7b82e62a21c208b477ee8d883950c2469281b0695146780b7baa2995ba973b8dc3e49e35d018e534e741f9ac75afd5b6848598cfa7d60f2bfab6514d5d8a01714fc328d4715e4abdb5d8565ee3a2236ccd910ef339f8e52a6a766e98acc1ddc83f0353698d5929a745b29a77d6132aab700b1d31c512c8a7a1fe11320c9bc6190515bbc12fd2cbb16cee4c8f04bab2e1447bf070cc5b855809a09ef14d41c49b59d1bafc5f18c4d2c35564d4a18fd042189ab928530e130e5dd57938ef2ef2f0e0b277325ecc9e88b8c5ff60e7d67fd69a69d1f9ab55c8cca2fe9b1d4b4e59a1dff084162aa0984e037a020bebde85732d6c65810e9b68c0bb6b5d40ee6f0efe6e65e5e0727aee8d5f4b9c93234df260d03a0df1dce7a7a0f7ec9cac1f2d3d7e6c5b70276aa03cd958c2fc66dc3cb519686287104e55041d747f2411badb0cec1a467299838321d8172921f9275990f6e21136b800a0ef361efe2ffd75de84b5eaff0cc0126bd21bb1b789ea281fb332c7d3184117e142aebc11dd2348291079d10198e07b1907b64af52714c0bc4b0ef933b03ea9c4e7d29a5a132766311cbf1ffe104baa12c07fd538360886108ba33834c2c3ed0dbb5b52deac153e322f1ef414c2b1b894112449404d86704211dfb187f34e3c4234112157924b93a0038d6164fa605ad2c9bb9363573351bdc03fd1bd2bccdf394d97f602e2b64122893f2a450cdf8d5f636a49f0b4b96f0e47d5dbc2acef81acfbfd912a00a7b61354d6db88155a2248601eaf73c82a7f7c8b3f2fab41ed1f74458eb35fa9544265528bd09ac8091d7938de3edf8b013d3b465aab180f327124a2c2321132115fea7cef9e798453f1fccc1f4e1c10b9a33008f1aa8db7218788e113ed350c5d628822a3b861271ddc0c2b54f1051ae57b4bda52b0ca449b6e0d11553c73dad2c125d5656117eee905169b43b1269502956254d1cd21037b3da0cc82b0c8201044e45556804c0dd1d02f9d19425fe8407568091e9bcd1ea0ea296c4acaacb4a3356ec777830b7063724acccdf07a44a503a97d4429172598669cc35fe74834527d035f757b6783cc2aada64c3afd7fb80a6f6ddc77110eeecc720249158e4ade19eb0fff1e6bc35ecaaedd74c179ed214c7eca3b65736c45dd5e7847b600aa001025a61086f95612b1421e8d6c340dc0365eece7f16ce3084ea1d4457387ad16c97b7f2736050fac4f3e3d18843db64214cface6a7b47976600a02271423426966f6fb5458e275d672b6de7441a4f44ee25085a28c36136eaeb3b21ec6771dc1451a07c2101aa44e2ddad6717e9439f7790105f56619452be94bdc321284ee2bf2cd7c37f38822cab22c3bddf03041075bde615ed2e706c3f9a2ac547c3b36502d07078cd1966e2544c2fd26d7defa8af832dc7b18e72a51fb955e0770ce699b6b8afadfa80de6037cfa024d8113f73c0e2c5b97f35577cb9ca65f28d5c5b6889e72bae0e437ac720e6d4f68cc5a9971b76ea796b242b9b17648b154542379f926c02b44cc081a4899950a00f28e3f545d71b1507547eb6efcc736399f3b7177b3e7f4b41b057d36fbe35fc865137942fcefbc115718620b0b285a7ab697cc0c18f8a85c248efc6dea7ed6c7437ad143d14fbe5155bec08c733891b37005494112a2fc2f88a77fcd6c21f1d52fd43c4ad422f86e87023ccfdaa00e777923ebed5a43ad2cb272e1cf5f34ab1fa44765ddbf45e0aeb6c3904e5947f76876c52056698be7236be8aa18d5788f4ef46cf95be6db7efb2bffb7b70856a5d85a61c52fe196d60eef6eb4a5fd1e02c8047325ce15beac2e0769d7ded51c903e1dd13f1278e6a130add3ac94891fadcda2ee3408d6fe4ec477a3a713fca0ecfe63c26a038548e5b525eeb85a77513e0ccf66c1ec4150bc465e452d47d3ade37221260e6500e1a4a4d30fea4a2e344532c9224b6a9499a05a9f0daa1416c732e18e1de454f2e4404157546b079cf95a8cda65faf1b5d933e57ca1226dfa94d894e539b9ff6570285eb6aac76a836665d9827332ca66672309c64d2b5bccba08fbc05d161a6fbe17a5f9500aee8778563e2609d45df914e919c70a9cc42cde21d5542d946abe1eaa54597ec5f4dade0aea8c37caa198ce1e698aa67b9266d57f3efb51bf06412e4d044bf910db6fa7d9eea8fcd0dc144bfac2a120ecda254571a712a0252ea4e116df860859bfe2cc5126cbdd9abb5395952da7233aedfdfe4957315288657c188dfe1c54ca6a18d9957ab6d235e6a8403eec50610b255803cc70bb7264a192cc3e3969fdc6fac3358a1f21ad03e0ca7207f147b79c4257b25f6aea740ec6c7e42bf6ce86c1169e64386fb4b8e6852b65e5288d24349874cfe011477276c21a2e6e1189ee7d430227005fe89e75f4e478e67bf86ace4532cdaac6e0715695885bb03d8cf948b77cf9092aa80488291f664c73fad3a6431bc79eec4b12c25fe3aedfa135f3604e2078b6d001ecfe829717e5f68f457c22cd9f099030d89c41335c525e23c0e7cf57bea1dfffed71fd7aeedb9bb4f766a03b6be200793cc735a2a6b4a07b51aa42c65fd909310f0754771dbb717fa3833efb134d3a3ab7b60c521fcb7315a6173e8f639c4f4b7e6c9d372353536114fe3078eaa16b49836694da5852b81aa542d394c46371e900fec007696b7fe9f143a6df4cb38a43e58c7316b8159f5c6eabe6363a331e9d693fcdd7a622b8b2f5891c2c2e37d991c83377887b7e7fb7d98808e3328d59ee2e33ce90748e41fa71805644a63b8e5a16713fe5cd1ef1d4fe46b9d0b7e9d5ea5ff4d440f6ff30e13783551d8c36faa571bbbdd9551552a61c7381405a92fde1fae44e6d74bd7973d8f0ced761595f72ee2d58f3c388bc2004d23a6a4d29026d0622cb0e6677ffb0f0def73fd81d9bf172d0f25340227e03128c7ea529bec748e1928d16a60b672b862 丫头，你猜密码是什么！","categories":[],"tags":[{"name":"private","slug":"private","permalink":"https://www.pkubailu.cn/tags/private/"}]},{"title":"C++ Primer 第2章 变量和基本类型","slug":"C-Primer-第2章","date":"2021-11-06T06:55:53.000Z","updated":"2022-11-06T06:55:53.000Z","comments":true,"path":"2021/11/06/C-Primer-第2章/","link":"","permalink":"https://www.pkubailu.cn/2021/11/06/C-Primer-%E7%AC%AC2%E7%AB%A0/","excerpt":"","text":"第2章 变量和基本类型 第2章 变量和基本类型2.1 基本内置类型C++定义了一套包括算术类型和空类型在内的基本数据类型。 算术类型： 字符、整型数、布尔值、浮点数。 空类型不对应具体的值。 2.1.1 算术类型算术类型分为两类：整型（包括字符和布尔类型在内）和浮点型。 2.1.2 类型转换切勿混用带符号类型和无符号类型 Note! 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号类型数。 2.1.3 字面值常量一个形如42的值被称作字面值常量，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。 整型和浮点型字面值整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数。十进制字面值的类型是int、long和long long中尺寸最小的那个。 默认的，浮点型字面值是一个double。 字符和字符串字面值由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。 字符串字面值的类型实际上是由常量字符构成的数组。 2.2 变量2.2.1 变量初始化列表初始化12345// 初始化方式int units_sold = 0;int units_sold = &#123;0&#125;;int units_sold&#123;0&#125;;int units_sold(0); 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错： 123long double ld = 3.1415926;int a&#123;ld&#125;, b = &#123;ld&#125;; // 错误：转换未执行，因为存在丢失信息的危险int c(ld), d = ld; // 正确：转换执行，且确实丢失了部分值 默认初始化如果是内置类型的变量未被显示初始化，他的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。 类的对象如果没有显示的初始化，则其值由类决定。 2.2.2 变量的声明和定义的关系变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示的初始化变量： 12extern int i; // 声明i而非定义iint j; // 声明并定义j 任何包含了显示初始化的声明即成为定义。 1extern double pi = 3.1416; // 定义 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 2.3 复合类型2.3.1 引用 程序把引用和它的初始值绑定到一起，而不是将初始值拷贝给引用。一但初始化完成，引用将和它的初始值对象一直绑定到一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。 引用并非对象，相反的它只是为一个已经存在的对象所起的另外一个名字。 引用的类型都要和与之绑定的对象严格匹配。（但有两种例外情况） 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定到一起。 2.3.2 指针 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 指针无须在定义的时候赋初值。和其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 指针的类型都要和它所指向的对象严格匹配。（但有两种例外情况） 空指针空指针不指向任何对象。 12345# 生成空指针的方法int *p = nullptr;int *p = 0;//需要首先#include cstdlibint *p = NULL; void* 指针void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址追踪到底是个什么类型的对象并不了解。 利用void* 指针能做的事比较有限：拿他和别的指针比较、作为函数的输入输出、或者赋值给另外一个void*指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。 2.3.3 理解复合类型的声明指向指针的指针通过*的个数可以区分指针的级别。也就是说，**表示指向指针的指针，***表示指向指针的指针的指针，以此类推： 123int ival = 1024;int *pi = &amp;ival; // pi指向一个int型的数int **ppi = &amp;pi; // ppi指向一个int型的指针 解引用int型指针会得到一个int型的数，同样，解引用指向指针的指针会得到一个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用。 指向指针的引用引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用： 123456int i = 42;int *p = 0; // p是一个int型指针int *&amp;r = p; // r是对指针p的引用r = &amp;i; // 给r赋值&amp;i就是让p指向i*r = 0; // 解引用r得到i,也就是p指向的对象，将i的值改为0 2.4 const限定符如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字 2.4.1 const的引用 把引用绑定到const对象上，我们称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象： 1234const int ci = 1024;const int &amp;r1 = ci;r1 = 0; // 错误：ri是对常量的引用，常量无法被修改。int &amp;r2 = ci; // 错误：试图让一个非常量引用指向一个常量对象。他们的类型不一致！ 引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况是：在初始化常量引用的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式 12345int i = 42;const int &amp;r1 = i; // 允许将const int&amp;绑定到一个普通int对象上;const int &amp;r2 = 42; // 正确：r2是一个常量引用;const int &amp;r3 = r1 * 2; // 正确： r3是一个常量引用;int &amp;r4 = r1 * 2; // 错误：r4是一个普通的非常量引用; 对const的引用可能引用一个并非const的对象 必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值： 12345int i = 42;int &amp;r1 = i; // 引用r1绑定对象iconst int &amp;r2 = i; // r2也绑定对象i,但是不允许通过r2来修改i的值;r1 = 0; // r1并非常量,i的值修改为0;r2 = 0; // 错误：r2是一个常量引用，不可以做修改操作; 2.4.2 指针和const与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能用于改变其所指对象的值。 指针的类型必须与其所指向对象的类型一致，但是有两个例外。第一种例外的情况是允许令一个指向常量的指针指向一个非常量对象。 123456const double pi = 3.14; //pi是一个常量，他的值不能改变;double *ptr = &amp;pi; // 错误：ptr 是一个普通指针;const double *cptr = &amp;pi; // 正确：cptr可以指向一个双精度常量;*cptr = 42; // 错误：cptr指向的是一个常量，不能给cptr赋值;double dval = 3.14;cptr = &amp;dval; // 正确：但是不能通过cptr改变dval的值; 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量，所为指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。 所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以觉得不去改变所指对象的值。 2.4.3 顶层const顶层const：表示指针本身是个常量。 底层const：表示指针所指对象是一个常量。 当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显，其中顶层const不受什么影响。顶层const只是标注了变量本身是const不允许改变，而底层const表示了变量所指的对象的类型，在拷贝时要求拷贝对象和被拷贝对象类型一致！ 2.4.4 constexpr 和常量表达式常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式。 一个对象或表达式是不是常量表达式由他的数据类型和初始值共同决定。 字面值类型常量表达式的值需要在编译时就得到计算，因此对声明 constexptr 时用到的类型必须有所限制，因为这些类型一般比较简单，值也显而易见、容易得到，就称之为“字面值类型” 算术类型、引用和指针都属于字面值类型。 一个 constexpr 指针的初始值必须是 nullptr 或者0，或者是存储在某个固定地址中的对象。 函数体外的对象其地址固定不变，能用来初始化constexpr指针。 函数体内定义的变量一般来说并非存放在固定地址中，不能初始化 constexpr 指针，但是函数体内也可以定义一类有效范围超出函数本身的变量，这类变量也有固定地址。 12const int *p = nullptr; //p是一个指向整型常量的指针;constexpr int *q = nullptr; // q是一个指向整型的常量指针 2.5 处理类型2.5.1 类型别名有两种方法可用于定义类型别名： 1234// 1.传统方法typedef:typedef double wages; // wages是double的同义词// 2.别名声明:using SI = Sales_item; // SI是Sales_item的同义词 指针、常量和类型别名如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。 123typedef char *pstring; // pstring 是类型 char* 的别名const pstring cstr = 0; // cstr 是指向char的常量指针const pstring *ps; // ps 是一个指针，它的对象是指向char的常量指针 遇到一条使用了类型别名的声明语句时，人们往往会错误的尝试把类型别名替换成它本来的样子，以理解该语句的含义： 1const char *cstr = 0; // 是对 const pstring cstr 的错误理解 这种理解是错误的！声明语句中用到pstring时，其基本数据类型是指针。可是用char*重写了声明语句后，数据类型就变成了char，*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。 2.5.2 auto类型说明符auto类型说明符能让编译器通过初始值来推算变量的类型，显然auto定义的变量必须有初始值。 auto一般会忽略掉顶层const，同时底层const则会保留下来。变量b、c是案例。 设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留！变量g是案例。 例子： 12345678int i = 0, &amp;r = i; auto a = r; // auto = int a是整数 const int ci = i, &amp;cr = ci; auto b = ci; // auto = int b是整数 auto c = cr; // auto = int c是整数 auto d = &amp;i; // auto = int d是i的地址值 auto e = &amp;ci; // auto = int e是i的地址值 auto &amp;g = ci; // auto = const int g是整型常量引用 绑定到ci上 2.5.3 decltype 类型指示符decltype：它的作用是选择并返回操作数的数据类型。 decltype处理顶层const和引用的方式与auto有些不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内） 1234const int ci = 0, &amp;cj = ci;decltype(ci) x = 0; // x的类型是const intdecltype(cj) y = x; // y的类型是const int&amp;, y绑定到变量xdecltype(cj) z; // 错误：z是一个引用，必须初始化 需要指出的是，引用从来都是作为其所指对象的同义词出现，只有用在decltype处是一个例外 decltype和引用如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。 r是个引用，所以decltype(r)的结果是引用类型，如果想让结果类型是r所指对象的类型，可以把r作为表达式的一部分，例如r+0. 如果表达式的内容是解引用操作，则decltype将得到引用类型. 123int i = 42, *p = &amp;i, &amp;r = i;decltype(r + 0) b; // 正确：加法的结果是int,因此b是一个（未初始化的）intdecltype(*p) c; // 错误：c是int&amp;,必须初始化 如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式，decltype就会得到引用类型： 12decltype((i)) d; //错误： d是int&amp;,必须初始化decltype(i) e; // 正确：e是一个（未初始化的）int !切记：decltype((variable))（注意是双层括号）的结果永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用时才是引用。 2.6 自定义数据结构2.6.3 编写自己的头文件预处理器概述预处理变量有两种状态：已定义和未定义。 #define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef当且仅当变量已定义时为真，ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到#endif**指令为止。 预处理变量无视C++语言中关于作用域的规则。 头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符 2.7 总结 基本数据类型： 算术类型：字符、整型数、布尔值、浮点数 空类型：不对应具体的值 切勿混用带符号类型和无符号类型： 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号类型数。 一个形如42的值被称作字面值常量，这样的值一望而知。 由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。 如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错 如果是内置类型的变量未被显示初始化，他的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化。 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。 任何包含了显示初始化的声明即成为定义。 引用： 一但初始化完成，引用将和它的初始值对象一直绑定到一起。引用必须初始化。 引用并非对象。 引用的类型都要和与之绑定的对象严格匹配。（但有两种例外情况） 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定到一起。 指针： 指针本身就是一个对象，允许对指针赋值和拷贝。 指针无须在定义的时候赋初值。 指针的类型都要和它所指向的对象严格匹配。（但有两种例外情况） void* 是一种特殊的指针类型，可用于存放任意对象的地址。 利用void* 指针能做的事比较有限：拿他和别的指针比较、作为函数的输入输出、或者赋值给另外一个void*指针。不能直接操作void*指针所指的对象。 引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字 引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况是：在初始化常量引用的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式 对const的引用可能引用一个并非const的对象 与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能用于改变其所指对象的值。 指针的类型必须与其所指向对象的类型一致，但是有两个例外。第一种例外的情况是允许令一个指向常量的指针指向一个非常量对象。 顶层const： 表示指针本身是个常量。 底层const：表示指针所指对象是一个常量。 常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式。 有两种方法可用于定义类型别名： 1234// 1.传统方法typedef:typedef double wages; // wages是double的同义词// 2.别名声明:using SI = Sales_item; // SI是Sales_item的同义词 auto 和 decltype 类型说明符 #define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef当且仅当变量已定义时为真，ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到#endif**指令为止。","categories":[{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://www.pkubailu.cn/categories/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"https://www.pkubailu.cn/tags/C-%E5%9F%BA%E7%A1%80/"}]},{"title":"判断JS数据类型的方法","slug":"判断JS数据类型的方法","date":"2021-11-02T03:50:44.000Z","updated":"2021-11-02T03:50:44.000Z","comments":true,"path":"2021/11/02/判断JS数据类型的方法/","link":"","permalink":"https://www.pkubailu.cn/2021/11/02/%E5%88%A4%E6%96%ADJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"JS判断数据类型的四种方法 前言ECMAScript 规范中，共定义了 7 种数据类型，分为基本类型和引用类型两大类基本类型：String、Number、Boolean、Symbol、Undefined、Null引用类型：Object 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，按值访问。 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。 下面介绍常用的4种方法，并对各个方法存在的问题进行简单的分析。 1. typeoftypeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。 12345678910typeof &#x27;&#x27;; // string 有效typeof 1; // number 有效typeof Symbol(); // symbol 有效typeof true; //boolean 有效typeof undefined; //undefined 有效typeof null; //object 无效typeof [] ; //object 无效typeof new Function(); // function 有效typeof new Date(); //object 无效typeof new RegExp(); //object 无效 有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值： 对于基本类型，除 null 以外，均可以返回正确的结果。 对于引用类型，除 function 以外，一律返回 object 类型。 对于 null ，返回 object 类型。 对于 function 返回 function 类型。 其中，null 有属于自己的数据类型 Null ，引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型。 2. instanceofinstanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，我们用一段代码来模拟其内部执行过程： 12345678910111213141516function new_instance_of(leftVaule, rightVaule) &#123; if(typeof leftVaule !== &#x27;object&#x27; || leftVaule === null) &#123; return false &#125; let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值 leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值 while (true) &#123; if (leftVaule === null) &#123; return false; &#125; if (leftVaule === rightProto) &#123; return true; &#125; leftVaule = leftVaule.__proto__ &#125;&#125; 从上述过程可以看出，当 A 的 __proto__ 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们再来看几个例子： 12345678910[] instanceof Array; // true&#123;&#125; instanceof Object;// truenew Date() instanceof Date;// truefunction Person()&#123;&#125;;new Person() instanceof Person; // true[] instanceof Object; // truenew Date() instanceof Object;// truenew Person instanceof Object;// true 我们发现，虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例，为什么呢？ 我们来分析一下 [ ]、Array、Object 三者之间的关系： 从 instanceof 能够判断出 [].__proto__ 指向 Array.prototype，而 Array.prototype.__proto__ 又指向了Object.prototype，最终 Object.prototype.__proto__ 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：从原型链可以看出，[] 的__proto__ 直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。 12345var iframe = document.createElement(&#x27;iframe&#x27;);document.body.appendChild(iframe);xArray = window.frames[0].Array;var arr = new xArray(1,2,3); // [1,2,3]arr instanceof Array; // false 针对数组的这个问题，ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。 123if (Array.isArray(value))&#123; //对数组执行某些操作&#125; Array.isArray() 本质上检测的是对象的 [[Class]] 值，[[Class]] 是对象的一个内部属性，里面包含了对象的类型信息，其格式为 [object Xxx] ，Xxx 就是对应的具体类型 。对于数组而言，[[Class]] 的值就是 [object Array] 。 3. constructor当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。如下所示： 当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 F 原型上的 constructor 传递到了 f 上，因此 f.constructor == F 可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。 同样，JavaScript 中的内置对象在内部构建时也是这样做的： 细节问题null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object 为什么变成了 Object？ 因为 prototype 被重新赋值的是一个 { }， { } 是 new Object() 的字面量，因此 new Object() 会将 Object 原型上的 constructor 传递给 { }，也就是 Object 本身。 因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。 4. toStringtoString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。 12345678910111213Object.prototype.toString.call(&#x27;&#x27;) ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.pkubailu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://www.pkubailu.cn/tags/JS/"},{"name":"数据类型","slug":"数据类型","permalink":"https://www.pkubailu.cn/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"跨域资源共享 CORS","slug":"跨域资源共享-CORS","date":"2021-11-01T07:06:00.000Z","updated":"2021-11-01T07:06:00.000Z","comments":true,"path":"2021/11/01/跨域资源共享-CORS/","link":"","permalink":"https://www.pkubailu.cn/2021/11/01/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-CORS/","excerpt":"","text":"跨域知识点学习笔记 一、同源1995年，同源策略由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。 所谓\"同源\"指的是\"三个相同\"协议相同域名相同端口相同 For example:http://www.pkubailu.com/index.html 这个网址，协议是http://，域名是www.pkubailu.com，端口是80（默认端口可以省略）。它的同源情况如下。 http://www.pkubailu.com/other.html：同源http://cdn.pkubailu.com/index.html：不同源（域名不同）https://www.pkubailu.com/index.html：不同源（协议不同）http://www.pkubailu.com:81/index.html：不同源（端口不同） 二、跨域一个HTTP请求的URL的协议、域名、端口三者中的任何一个与当前源不同，则视为跨域请求。如果不做处理，我们会看到chrome抛出一个错误：而在实际的场景中，我们在很多情况下需要进行跨域请求，下面讲解几种常见的跨域方案。 CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 本文详细介绍CORS的内部机制。 三、跨域方法1.JSONPJSONP：这是跨域请求的一个经典方案，其主要原理是通过JS动态创建&lt;script&gt;标签获取指定资源，然后前后端约定一个callback来获取json数据，&lt;script&gt;、&lt;iframe&gt;这些具有src属性的标签都是可直接跨域获取资源的，这种方式其实只是巧妙地绕过跨域限制，而且有其局限性，比如很明显的，只能发送GET请求，而且要判断请求是否失败也比较棘手。 123456789101112131415161718192021222324252627282930313233343536373839// 客服端代码&lt;script&gt; //获取input元素 const input = document.querySelector(&#x27;input&#x27;); const p = document.querySelector(&#x27;p&#x27;); //声明 handle 函数 function handle(data)&#123; //修改边框颜色 input.style.border = &quot;solid 1px #f00&quot;; //修改 p 标签的提交文本 p.innerHTML = data.msg; &#125; //绑定事件 input.onblur = function () &#123; //获取用户的输入值 let username = this.value; //向服务端发送请求 检测用户名是否存在 //1. 创建 script 标签 const script = document.createElement(&#x27;script&#x27;); //2. 设置 script 标签的src属性 script.src = &#x27;http://127.0.0.1:8000/check-username&#x27;; //3. 将 script 插入到文档中 document.body.appendChild(script); &#125;&lt;/script&gt;// 服务端代码app.all(&#x27;/check-username&#x27;, (request, response) =&gt;&#123; // response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;); const data = &#123; exist: 1, msg: &#x27;用户名已经存在&#x27; &#125;; //将数据转化为字符串 let str = JSON.stringify(data); //返回结果形式 是一个函数调用，而函数的实参就是我们想给客户端返回的结果数据 response.end(`handle($&#123;str&#125;)`);&#125;); 2.Proxy代理Proxy代理：由于同源策略只是浏览器的限制，服务器端并没有这个限制，所以只要A域客户端将请求发送一个代理服务器，然后由代理服务器去请求B域服务器就行了，比如前后端分离的工程，本地调试的时候我们启用nodejs代理服务、线上部署通过nginx代理转发等，都属于这个跨域模式。同样的，这个本质上也只是绕过浏览器的跨域限制而已。 3.CORS（Cross-Origin Resource Sharing）：跨域资源共享标准3.1简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 3.2两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一：HEADGETPOST（2）HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的。 3.3简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(FooBar)可以返回FooBar字段的值。 上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 1Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 3.4非简单请求预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 12345var url = &#x27;http://api.alice.com/cors&#x27;;var xhr = new XMLHttpRequest();xhr.open(&#x27;PUT&#x27;, url, true);xhr.setRequestHeader(&#x27;X-Custom-Header&#x27;, &#x27;value&#x27;);xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是OPTIONSPUT。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 1Access-Control-Allow-Origin: * 如果服务器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常CORS请求。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.pkubailu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://www.pkubailu.cn/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"CORS","slug":"CORS","permalink":"https://www.pkubailu.cn/tags/CORS/"}]},{"title":"2021/10/30","slug":"2021-10-30","date":"2021-10-30T16:35:06.000Z","updated":"2021-10-30T16:35:06.000Z","comments":true,"path":"2021/10/31/2021-10-30/","link":"","permalink":"https://www.pkubailu.cn/2021/10/31/2021-10-30/","excerpt":"","text":"0082a7e0c83ebf901f977394e654d43789a4ffb1424139c5c301df05f4e14bbeeb58b19d9995becaa9edef5abeb4bd37c9058aad3c5e61a1b08eeca725c5daa6e993c223c96509d08597abbc42383eecb0b05cfa0fa4c1a6693c9c4b82f56796027b8d0cc6804ad0ca047ea35c2023196fa8ddfc793222d49c0cff1ee16c0f6dc31a1d6a5863f0ae634dfc44c63db5e26145f30272ce143dad00beb6e39eff0001046ef05c53737a63e393d6722e39e635ffa6b5b29ce7c81e6673c0385ab58dc983d392f42c7a9b01a950a7a4d3dcf84e0bdef9f06c3bd7a8e8897a56265c603b431dd4816def2e8c4fc63ff11d0d2cd7f7e85662422ae4dbbfed538ff52486a348e1fbee1ba4c6df406bd80df1b524d30a64be8f797ea41ce73e116ed7a04775d38339c84a23d95c41d194c6466e9c95da82a71fea2d819f1d96e6b401cf2ce0a8114b00bdefb6a6fa4744332eb8800357aad333943fdc3d06e5fd6d485414bfa54990cbd546426b404ec9de6c6e715ff006de07d4e8dd11f7f4023d3bce3b95477012418145907eb4b83b895e0054ca9f88711cb14576788efd03e1333d7cdd80eb71d42ea13cdd68b9d0c4d5cc2ade863e6cfd8100b0b9a373961985cb87e47920e5369ec48c8d3237e35434b8ea52e93d2ab9eda3c6b4d77fb7e9d36e2af4ed7d1d103fc9bc7468329b4b135f09c06f399dc4a063771c845eee16015e169ad371c885e697fb68ae0d22c21ef17b0cb6ba4a3d51932c16936071be296baeacbf901817d4f43b8efe1705e7fd6f7576f84dfd7973d5f9041d3c3891c4f96386dadac84a8162e745142a43189a8cbdece4386824d2249c8a528e0d52d93492043ddd6ab4ef3131bec615454f5d5a150dddc4cbad7c6024c3c50e82efa1b29528016cd6e0bdaa1ae62287b2caf11b183b65b4edd69140603c856ed633eef7d6cf83bae549e8c082a6850992aec7dec7b80da4b94d400410d613762bfefb27a5e81da28150b7fce061d3d8618806bb60aba56ffa7ae04b0535746386c099c57cffb4f57c3ab1bc5f375b0f723f99a95e4d9f0aa97ce4a564eae248c1c3d904dbe81a1d1d477ed8bf131201987a9ff9645fd7c62563844e28256d0bc242eeb97b9bacb29ee8f01c739c8c0449abb11faa8605b9c81dc93feb4367bad5288a8c598f8c66d5468efa8a240f9ddf7b23c1d136322a0f0cd69284c105ec3497cfe857acdb305f4c71a433908dd2cea00dcd28b03c96b63b6c4872efa2ee5249457e516d54e604c46baff845fba8ed7db99231f7d0e6eb46a1e6a99352a7f0120ab963572aaaca42f144cf9a0b7f8b1fa8bcf1f4853b83b29169f0a01b121494ce1bdd4a7100595f6fea00c3cfc6626dbe471cdaa24a81a914da4d03d44cca5d66dcb787a98f3046fcce476e2aeaa688d97a330f412d8ec3bb3a257f3f147ce92d0b7fd09a1041608a0bc2ca1fcab52aac6480b3a5f24fb50909162cbe4cef7e72bd0b581d15c306db5f332cf13392243b80070cb883d2211d8f21fa315c1077818f6f8fd4064c82a78300400cc72ce74b81205db5eb0baf5a72dede9283a13e31564e4feb19fbc8e7f8b94db2236c0c7358ed9f46b188ff0e061803820b6214abe123705d404e4abac52d81616aad5fc333ada17512f6ef87fa3cff285110cd7be88892295c475c30a989314dd19b2e45f4692a1f32a679f6fafa80069cb339bb5cbcac4e91b3c1f2c100d79174151946ac629c73cba4a58be9c1af1038ba0a82b9d61e678d5112610baa795d54dc28d8ce52caf24966466ea14c9de50f50abe7412f3bd59ff456fe1e5e081f930db5ce6447b69ed9fee2dc2b003717f33916a92d35eb06819209eefd40ba7efd0cb6673aa4a88378d97d5639863b66365b34361cac6d3993820ef03ac3560c1d0a350dbeca3f3c15c2bd5bc56dda9ece86dd0f2dcdff24143abc95f7cbc43da5bf7642bbab9bb749ba03eeac9350f7e4c22cfceb216691820a9d0bcd839639d645a66c9ed8d7ece70aeba9e1e45ad2bad3d74a74ef36fa399abf20eb76ad050675ddb08b380878b4c64297d733ea97387772815cf29a57346ceee0d47f2ca5ce509fcb482c2172cf57f7b906d9dd74276adb6d6c97c3949437807382e4b814cd53b4598a544bc734e66e34b58bf139c5643c9e97e94f852248a5cef8fba4a2120343145218355e9ca18826612841cb9ffb68e9608755a978b5671a1c0b8cba325f6ceeba9420bf895d493c9c056abc17871ec589d9771f3a23eb0be273f7699f9322e1d8444c9df92f4d2f65d65b3eea337e136fcc4e2b6cc29ca9b2812a4fe6f2ce007113 丫头，你猜密码是什么！","categories":[],"tags":[{"name":"private","slug":"private","permalink":"https://www.pkubailu.cn/tags/private/"}]},{"title":"七牛云 + PicGo 搭建图床","slug":"七牛云-PicGo-搭建图床","date":"2021-10-29T07:43:13.000Z","updated":"2021-10-29T07:43:13.000Z","comments":true,"path":"2021/10/29/七牛云-PicGo-搭建图床/","link":"","permalink":"https://www.pkubailu.cn/2021/10/29/%E4%B8%83%E7%89%9B%E4%BA%91-PicGo-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"赶快搭建起自己的图床，实现行云流水的markdown笔记吧 背景无论大家使用Typora等markdown笔记软件记笔记还是搭建自己的个人博客，其实都离不开图床，markdown对于图片只会记录它的链接。所以一旦笔记文件与本地图片的相对位置发生改变，图片就会裂开了，如果我们在笔记中记录的是图片的网络地址就不会发生这样的事了。 1.创建七牛云图床1.创建七牛云账号2.进行实名认证3.创建对象存储空间存储空间名字自己命名一个即可。存储区域选择离自己所在地较近的就行，访问控制选择公开空间，毕竟wiki也说了要带有外链服务以供分享，填写完后点击确定创建即可。创建完成后主页如下所示。点击图中的绑定域名，绑定自己的域名，七牛云提供的免费域名只有30天，这里建议绑定自己的域名。如果勾选了https选项，会要求你上传ssl证书,这里你可以购买七牛云的证书，也可以上传自有证书。如果你选择上传自有证书的话，一定要注意下面这个地方，我当初上传时浪费了不少时间。添加成功后七牛云会提供CNAME地址,并会有配置CNAME的教程，按照教程配置去域名提供商配置即可。添加解析记录后回到主页，点击内容管理，修改外链默认域名并保存。 2.下载并配置PicGo1.下载地址： https://github.com/Molunerfinn/PicGo/releases ，还可以使用 Homebrew 来安装 PicGo: brew install picgo –cask。2.下载安装后打开，在图床设置中对七牛图床进行设置，设置图如下存储区域对照表 存储区域 地域简称 华东 z0 华北 z1 华南 z2 北美 na0 东南亚 as0 两个Key作为连接凭证，可以在七牛云的个人面板-秘钥管理中查看，复制过来即可。设定访问网址必须添加http://或https://，不然无效。输入完后点击确定并设为默认图床。 总结至此，配置的整个流程就算结束了，操作起来并不复杂，还是比较简单的，但是用起来就非常爽了，心动不如行动！","categories":[{"name":"教程","slug":"教程","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/"},{"name":"图床","slug":"教程/图床","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://www.pkubailu.cn/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"git push 时出现 your current branch is behind","slug":"git-push-时出现-your-current-branch-is-behind","date":"2021-10-29T07:07:26.000Z","updated":"2021-10-29T07:07:26.000Z","comments":true,"path":"2021/10/29/git-push-时出现-your-current-branch-is-behind/","link":"","permalink":"https://www.pkubailu.cn/2021/10/29/git-push-%E6%97%B6%E5%87%BA%E7%8E%B0-your-current-branch-is-behind/","excerpt":"","text":"Updates were rejected because the tip of your current branch is behind 出现问题的原因某次在将本地仓库的代码push到远程仓库时，由于本地仓库与远程仓库文件不一致，push的时候出现 hint: Updates were rejected because the tip of your current branch is behind 的报错。 123456789parkin@wangyan:~/duapp/consignment$ git pushTo code.aliyun.com:xxx/xxxxxx.git ! [rejected] wy -&gt; wy (non-fast-forward)error: failed to push some refs to &#x27;git@code.aliyun.com:xxx/xxxxxx.git&#x27;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details. 这种情况下，由于我确定我本地仓库的代码是我想要的，所以我采取了强制推送的方法，让远程仓库和本地仓库的代码保持一致。 1git push -u origin 分支名 -f","categories":[{"name":"实践中的问题","slug":"实践中的问题","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"},{"name":"Git","slug":"实践中的问题/Git","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/Git/"}],"tags":[{"name":"git push","slug":"git-push","permalink":"https://www.pkubailu.cn/tags/git-push/"}]},{"title":"使用 Nginx 搭建图片服务器","slug":"使用-Nginx-搭建图片服务器","date":"2021-10-29T05:29:05.000Z","updated":"2021-10-29T05:29:05.000Z","comments":true,"path":"2021/10/29/使用-Nginx-搭建图片服务器/","link":"","permalink":"https://www.pkubailu.cn/2021/10/29/%E4%BD%BF%E7%94%A8-Nginx-%E6%90%AD%E5%BB%BA%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"搭建图片服务器，直接可以访问网络图片 1.在linux服务器上安装nginx安装nginx的方法很多，大家可以自行google一下安装完成之后执行以下命令,可以看到nginx的运行信息 1ps -ef | grep nginx 2.测试是否能成功访问若出现下图所示就表示能够成功访问 3.找到图片文件夹路径在服务器上新建一个image文件夹用来存放图片，或者找到你要存放图片文件夹的路径。例如我将图片存放在image文件夹下，路径如下 4.配置nginx的nginx.conf文件该文件的位置可以通过以下命令来找到 12ps -ef | grep nginx## 第一行就会显示nginx.conf文件的路径，打开该文件进行编辑 5.配置nginx的nginx.conf文件完整的nginx.conf文件代码 123456789101112131415161718192021222324252627282930http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location /images/ &#123; root /opt/myapp/; autoindex on; &#125; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125;## 解释：## 1)root则是将images映射到/opt/ormis/images/## 2)autoindex on便是打开浏览功能。 6.保存nginx.conf配置，使用下面命令刷新配置123456789## 进入到/usr/local/nginx/sbin目录下 执行nginx -t## nginx: the configuration file /www/server/nginx/conf/nginx.conf syntax is ok## nginx: configuration file /www/server/nginx/conf/nginx.conf test is successful## 显示以上信息表明配置文件正确## 执行刷新配置命令nginx -s reload 7.浏览器直接访问图片浏览器输入http://xxx.xxx.xxx.xxx/images/***.png即可访问到图片","categories":[{"name":"教程","slug":"教程","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/"},{"name":"Nginx图片服务器","slug":"教程/Nginx图片服务器","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/Nginx%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.pkubailu.cn/tags/Nginx/"},{"name":"图片服务器","slug":"图片服务器","permalink":"https://www.pkubailu.cn/tags/%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"一台电脑同时配置github与gitlab","slug":"一台电脑同时配置github与gitlab","date":"2021-10-28T13:20:09.000Z","updated":"2021-10-28T13:20:09.000Z","comments":true,"path":"2021/10/28/一台电脑同时配置github与gitlab/","link":"","permalink":"https://www.pkubailu.cn/2021/10/28/%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEgithub%E4%B8%8Egitlab/","excerpt":"","text":"想要在一台电脑上同时玩转github和gitlab的小伙伴请仔细阅读本文喔！ 公司的电脑上默认都会配置好gitlab，而我们在日常摸鱼的时候又难免用到github，这个时候一直手动切换账户便会很繁琐，所以我们就需要在电脑上同时配置好二者，让其在拉取和上传的时候自动识别。首先安装好git，当前git无论是哪个账户都可以，下面开始正式配置。 0.准备工作 学校或公司给的Gitlab账号的邮箱地址 学校或公司给的Gitlab账号的账号名称 你自己的Github账号的的邮箱地址 1.生成SSH密钥并配置进入.ssh文件夹，如果没有就创建一个 1cd ~/.ssh 1.这里我们先配置Gitlab，写入命令 1ssh-keygen -t rsa -C &quot;Gitlab账号的邮箱地址&quot; 此时文件夹中生成了对应的Gitlab密钥的私钥id_rsa和公钥id_rsa_pub。 2.配置Gitlab公钥id_rsa_pub中的内容到学校或公司的Gitlab上,步骤如下：打开Gitlab -&gt; 点击自己的头像 -&gt; 下拉菜单有个Settings点进去 -&gt; 点击左侧菜单中的SSH Keys -&gt; 点击绿色按钮Add Key -&gt; 用记事本打开公钥文件，全选复制 -&gt; Title是对密钥的描述（可以随便起名字，但是建议有标识性一些，不然时间久了不知道这个秘钥对应着哪里）；复制内容粘贴到多行文本框 -&gt; 确定完了你就能看到下方显示的Your SSH keys，配置成功！ 3.接下来我们配置Github，写入命令 1ssh-keygen -t rsa -C &#x27;github登录的邮箱&#x27; -f ~/.ssh/id_rsa_github 同样在文件夹中生成了Github私钥id_github_rsa和公钥id_github_rsa.pub 4.配置Github公钥github_rsa.pub中的内容到自己的Github上过程和上述Gitlab公钥配置一样。 2.配置config文件两边公钥都分别配置成功后，在.ssh文件夹中，创建一个config文件，没有后缀，添加如下配置： 1234567891011Host github AddKeysToAgent yes HostName github.com User **@qq.com ## 你github的邮箱地址 PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_githubHost gitlab HostName http://git.corp.***.com ## 填公司或学校的gitlab的Host User **@qq.com ## 填公司或学校的邮箱地址 PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa 保存文件 3.测试连接12## 执行命令ssh -T git@github.com 如下图所示则表示连接成功 至此，你的电脑上github和gitlab便同时配置好啦！","categories":[{"name":"教程","slug":"教程","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/"},{"name":"同时配置github与gitlab","slug":"教程/同时配置github与gitlab","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEgithub%E4%B8%8Egitlab/"}],"tags":[{"name":"github","slug":"github","permalink":"https://www.pkubailu.cn/tags/github/"},{"name":"gitlab","slug":"gitlab","permalink":"https://www.pkubailu.cn/tags/gitlab/"}]},{"title":"git commit 不规范导致报错","slug":"git-commit-不规范导致报错","date":"2021-10-28T12:39:37.000Z","updated":"2021-10-28T12:39:37.000Z","comments":true,"path":"2021/10/28/git-commit-不规范导致报错/","link":"","permalink":"https://www.pkubailu.cn/2021/10/28/git-commit-%E4%B8%8D%E8%A7%84%E8%8C%83%E5%AF%BC%E8%87%B4%E6%8A%A5%E9%94%99/","excerpt":"","text":"要养成git commit 规范的良好习惯！ 某次提交(commit)代码的时候，突然报了一个有意思的错误，之前并没有遇到过，懵了一下。× subject may not be empty [subject-empty] × type may not be empty [type-empty] 参考网上的一些资料，最后发现报这个错误有2种可能的情况 下方图片红色框中冒号后面少一个空格 下方图片红色框中是中文冒号要改为英文","categories":[{"name":"实践中的问题","slug":"实践中的问题","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"},{"name":"Git","slug":"实践中的问题/Git","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/Git/"}],"tags":[{"name":"git commit 规范","slug":"git-commit-规范","permalink":"https://www.pkubailu.cn/tags/git-commit-%E8%A7%84%E8%8C%83/"}]},{"title":"git 将本地项目关联到远程仓库","slug":"git-将本地项目关联到远程仓库","date":"2021-10-28T12:26:28.000Z","updated":"2021-10-28T12:26:28.000Z","comments":true,"path":"2021/10/28/git-将本地项目关联到远程仓库/","link":"","permalink":"https://www.pkubailu.cn/2021/10/28/git-%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%85%B3%E8%81%94%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"","text":"git 将本地项目与远程仓库相关联的方法 1.首先在项目目录下初始化本地仓库1$ git init 2.添加所有文件( . 表示所有)1$ git add . 3.提交所有文件到本地仓库1$ git commit -m &quot;备注信息&quot; 4.连接到远程仓库1$ git remote add origin 你的远程仓库地址 5.将项目推送到远程仓库1$ git push -u origin master","categories":[{"name":"实践中的问题","slug":"实践中的问题","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"},{"name":"Git","slug":"实践中的问题/Git","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/Git/"}],"tags":[{"name":"git关联远程仓库","slug":"git关联远程仓库","permalink":"https://www.pkubailu.cn/tags/git%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"}]},{"title":"git撤销已推送到远端仓库的提交信息","slug":"git撤销已推送到远端仓库的提交信息","date":"2021-10-28T11:47:18.000Z","updated":"2021-10-28T11:47:18.000Z","comments":true,"path":"2021/10/28/git撤销已推送到远端仓库的提交信息/","link":"","permalink":"https://www.pkubailu.cn/2021/10/28/git%E6%92%A4%E9%94%80%E5%B7%B2%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%AB%AF%E4%BB%93%E5%BA%93%E7%9A%84%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF/","excerpt":"","text":"git撤销已推送(push)到远端仓库的提交(commit)信息的方法 1.首先通过 git log 查看提交信息，以获得需要回退的版本号1$ git log 2.回退指定版本号通过git reset -soft &lt;版本号&gt; 重置至指定版本的提交，达到撤销提交的目的。 123$ git reset -soft &lt;版本号&gt;## 参数 soft 指的是: 保留当前工作区，以便重新提交。## 还可以选择参数hard，会撤销相应工作区的修改！！ 3.通过git log 确认是否成功撤销1$ git log 4.修改远程仓库12## 通过 git push origin master -force 强制提交当前版本号，以达到撤销版本号的目的$ git push origin master -force 5.修改代码，重新提交和推送执行完第4步，本地和远程仓库便已经回退到指定的版本号了，可以继续修改代码进行开发了。","categories":[{"name":"实践中的问题","slug":"实践中的问题","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"},{"name":"Git","slug":"实践中的问题/Git","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/Git/"}],"tags":[{"name":"git分支","slug":"git分支","permalink":"https://www.pkubailu.cn/tags/git%E5%88%86%E6%94%AF/"}]},{"title":"开发新需求-拉取新的git分支","slug":"开发新需求-拉取新的git分支","date":"2021-10-28T10:17:19.000Z","updated":"2021-10-28T10:17:19.000Z","comments":true,"path":"2021/10/28/开发新需求-拉取新的git分支/","link":"","permalink":"https://www.pkubailu.cn/2021/10/28/%E5%BC%80%E5%8F%91%E6%96%B0%E9%9C%80%E6%B1%82-%E6%8B%89%E5%8F%96%E6%96%B0%E7%9A%84git%E5%88%86%E6%94%AF/","excerpt":"","text":"从master分支拉取新分支（dev）开发新需求 1.切换到被copy的分支（master），并从远端拉取最新代码12$ git checkout master ## 这里切换到线上分支，master分支一般为线上分支$ git pull 2.从master分支check出新的开发分支1$ git checkout -b dev ## dev表示你新建的分支名 3.把新建的分支(dev)push到远端仓库1$ git push origin dev ## dev表示你新建的分支名 4.拉取远端分支12$ git pull## 这个时候会报错，是因为你本地分支还没有与远端分支相关联的原因，git给与了你提示，按照提示操作即可 5.将本地分支与远端分支相关联1$ git branch --set-upstream-to=origin/gitStudy ## 将&lt;branch&gt;替换为自己的分支 6.再次拉取验证12$ git pull## 这个时候就成功建立了自己的分支，可以进行新的开发了","categories":[{"name":"实践中的问题","slug":"实践中的问题","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"},{"name":"Git","slug":"实践中的问题/Git","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/Git/"}],"tags":[{"name":"git分支","slug":"git分支","permalink":"https://www.pkubailu.cn/tags/git%E5%88%86%E6%94%AF/"}]},{"title":"hexo写作手册","slug":"hexo写作手册","date":"2021-10-25T06:43:05.412Z","updated":"2021-10-28T02:59:01.149Z","comments":true,"path":"2021/10/25/hexo写作手册/","link":"","permalink":"https://www.pkubailu.cn/2021/10/25/hexo%E5%86%99%E4%BD%9C%E6%89%8B%E5%86%8C/","excerpt":"","text":"front-matterfront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量。更多请见 Hexo 官方文档：#front-matter 字段 含义 值类型 默认值 layout 布局模版 String - title 页面标题 String - seo_title 网页标题 String page.title short_title 页面标题（在group列表中显示） String page.title date 创建时间 Date 文件创建时间 updated 更新日期 Date 文件修改时间 link 外部文章网址 String - music 内部音乐控件 [Object] - robots robots String - keywords 页面关键词 String - description 页面描述、摘要 String - cover 是否显示封面 Bool true top_meta 是否显示文章或页面顶部的meta信息 Bool true bottom_meta 是否显示文章或页面底部的meta信息 Bool true sidebar 页面侧边栏 Bool, Array theme.layout.*.sidebar body 页面主体元素 Array theme.layout.on_page.body thumbnail 缩略图 String false icons 图标 Array [] pin 是否置顶 Bool false headimg 文章头图 url - layout:post 时特有的字段： 字段 含义 值类型 默认值 author 文章作者 [Object] config.author categories 分类 String, Array - tags 标签 String, Array - toc 是否生成目录 Bool true music 字段 是否必须 值类型 server 是 netease, tencent, kugou, xiami, baidu type 是 song, playlist, album, search, artist id 是 song id / playlist id / album id / search keyword 文章置顶在 front-matter 中设置以下值： front-matter1pin: true 文章分类多个分类有两种关系，一种是层级（等同于文件夹），一种是并列（等同于标签）。 多级分类： front-matter123---categories: [分类A, 分类B]--- 或者 front-matter12345---categories: - 分类A - 分类B--- 并列分类 front-matter123categories: - [分类A] - [分类B] 多级+并列分类 front-matter123categories: - [分类A, 分类B] - [分类C, 分类D] 文章摘要在文章中插入 &lt;!-- more --&gt;，前面的部分即为摘要。 某篇文章源码1234567---title: xxxdate: 2020-02-21---这是摘要&lt;!-- more --&gt;这是正文 注意： &lt;!-- more --&gt; 前后一定要有空行，不然可能导致显示错位。 设置文章作者Volantis 支持多个作者在一个站点发布文章，其他作者信息需要写在数据文件中，例如： blog/source/_data/author.yml12345678Jon: name: Jon Snow avatar: https://cn.bing.com/th?id=AMMS_fc8f99fd41ebd737a71c4e13806db9a0&amp;w=110&amp;h=110&amp;c=7&amp;rs=1&amp;qlt=80&amp;pcl=f9f9f9&amp;cdv=1&amp;dpr=2&amp;pid=16.1 url: https://gameofthrones.fandom.com/wiki/Jon_SnowDany: name: Daenerys Targaryen avatar: https://tse1-mm.cn.bing.net/th?id=OIP.Yax4wLzIFbcBVUa_RsKywQHaLH&amp;w=80&amp;h=80&amp;c=8&amp;rs=1&amp;qlt=90&amp;dpr=2&amp;pid=3.1&amp;rm=2 url: https://gameofthrones.fandom.com/wiki/Daenerys_Targaryen 在文章的 front-matter 中新增 author 即可： front-matter1234---title: Jon Snow | Game of Thrones Wiki | Fandomauthor: Jon--- 引入外部文章利用 link，搭配自定义的文章作者信息，你可以在文章列表中显示外部文章或者网址，例如： blog/source/_data/author.yml1234xaoxuu: name: xaoxuu avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png url: https://xaoxuu.com front-matter1234567891011---layout: postdate: 2017-07-05title: [转]如何搭建基于Hexo的独立博客categories: [Dev, Hexo]tags: - Hexoauthor: xaoxuulink: https://xaoxuu.com/blog/2017-07-05-hexo-blog/---![](https://img.vim-cn.com/d9/a9af7dc49fc0af8ca3e6dd2450a2f7095a87db.png) 置顶对于任何文章或者页面，设置 pin: true 即可置顶在首页。 front-matter123---pin: true--- 这会导致一个小问题：首页 post 卡片数量多于设定值，如果有强迫症希望每一个分页数量一致，可以安装插件来实现，详见：#421 不归档存放在 _posts 文件夹下的文章一般都会出现在归档页，如果某篇文章不希望出现在归档页面： front-matter123---archive: false--- Volantis布局模板 取值 含义 page 独立页面 post 文章页面 docs 文档页面 category 分类页面 tag 标签页面 friends 友链页面 list 列表页面 page &amp; post &amp; docs这三种页面相同，但是有以下细微区别： post 文章有 title 时，向下滚动网页，导航栏会向上移出屏幕显出文章标题，而 page 和 docs 不会。 post 文章末尾最多可以显示「参考资料」、「相关文章」、「版权标识」、「打赏」四个模块。 docs 文章末尾最多可以显示「参考资料」一个模块。 标签插件text效果源码带 下划线 的文本；带 着重号 的文本；带 波浪线 的文本；带 删除线 的文本 键盘样式的文本：⌘ + D 密码样式的文本：这里没有验证码12345带 &#123;% u 下划线 %&#125; 的文本；带 &#123;% emp 着重号 %&#125; 的文本；带 &#123;% wavy 波浪线 %&#125; 的文本；带 &#123;% del 删除线 %&#125; 的文本键盘样式的文本：&#123;% kbd ⌘ %&#125; + &#123;% kbd D %&#125;密码样式的文本：&#123;% psw 这里没有验证码 %&#125; span语法效果源码参数本插件最后更新于 5.0 版本1&#123;% span 样式参数::文本内容 %&#125;各种颜色的标签，包括：红色、黄色、绿色、青色、蓝色、灰色。 超大号文字： Volantis A Wonderful Theme for Hexo12345各种颜色的标签，包括：&#123;% span red::红色 %&#125;、&#123;% span yellow::黄色 %&#125;、&#123;% span green::绿色 %&#125;、&#123;% span cyan::青色 %&#125;、&#123;% span blue::蓝色 %&#125;、&#123;% span gray::灰色 %&#125;。超大号文字：&#123;% span center logo large::Volantis %&#125; &#123;% span center small::A Wonderful Theme for Hexo %&#125; 属性 可选值 字体 logo, code 颜色 red, yellow, green, cyan, blue, gray 大小 small, h4, h3, h2, h1, large, huge, ultra 对齐方向 left, center, right p参数效果源码参数本插件最后更新于 5.0 版本1&#123;% p 样式参数::文本内容 %&#125;红色 黄色 绿色 青色 蓝色 灰色 Volantis A Wonderful Theme for Hexo123456789&#123;% p red::红色 %&#125;&#123;% p yellow::黄色 %&#125;&#123;% p green::绿色 %&#125;&#123;% p cyan::青色 %&#125;&#123;% p blue::蓝色 %&#125;&#123;% p gray::灰色 %&#125;&#123;% p center logo large::Volantis %&#125;&#123;% p center small::A Wonderful Theme for Hexo %&#125; 属性 可选值 字体 logo, code 颜色 red, yellow, green, cyan, blue, gray 大小 small, h4, h3, h2, h1, large, huge, ultra 对齐方向 left, center, right noteNoteBlock 是 Blockquote 的增强版，在左边显示图标，并且可以自定颜色。而 Note 是 NoteBlock 的简便写法。 最后更新于 5.0 版本1&#123;% note 样式参数::文本内容 %&#125; 演示效果经典用法可以在配置文件中设置默认样式，为简单的一句话提供最的简便写法。 note quote 适合引用一段话 note info 默认主题色，适合中性的信息 note warning 默认黄色，适合警告性的信息 note error/danger 默认红色，适合危险性的信息 note done/success 默认绿色，适合正确操作的信息 更多图标这些都是默认样式，可以手动加上颜色： note radiation 默认样式 note radiation yellow 可以加上颜色 note bug red 说明还存在的一些故障 note link green 可以放置一些链接 note paperclip blue 放置一些附件链接 note todo 待办事项 note guide clear 可以加上一段向导 note download 可以放置下载链接 note message gray 一段消息 note up 可以说明如何进行更新 note undo light 可以说明如何撤销或者回退 上述示例的源码example:1234567891011121314151617181920###### 经典用法&#123;% note::可以在配置文件中设置默认样式，为简单的一句话提供最的简便写法。 %&#125;&#123;% note quote::note quote 适合引用一段话 %&#125;&#123;% note info::note info 默认主题色，适合中性的信息 %&#125;&#123;% note warning::note warning 默认黄色，适合警告性的信息 %&#125;&#123;% note danger::note error/danger 默认红色，适合危险性的信息 %&#125;&#123;% note success::note done/success 默认绿色，适合正确操作的信息 %&#125;###### 更多图标这些都是默认样式，可以手动加上颜色：&#123;% note radiation::note radiation 默认样式 %&#125;&#123;% note radiation yellow::note radiation yellow 可以加上颜色 %&#125;&#123;% note bug red::note bug red 说明还存在的一些故障 %&#125;&#123;% note link green::note link green 可以放置一些链接 %&#125;&#123;% note paperclip blue::note paperclip blue 放置一些附件链接 %&#125;&#123;% note todo::note todo 待办事项 %&#125;&#123;% note guide clear::note guide clear 可以加上一段向导 %&#125;&#123;% note download::note download 可以放置下载链接 %&#125;&#123;% note message gray::note message gray 一段消息 %&#125;&#123;% note up::note up 可以说明如何进行更新 %&#125;&#123;% note undo light::note undo light 可以说明如何撤销或者回退 %&#125; 可以支持的参数样式参数位置可以写图标和颜色，多个样式参数用空格隔开。 图标彩色的1quote, info, warning, done/success, error/danger 灰色的，也可以指定颜色1radiation, bug, idea, link, paperclip, todo, message, guide, download, up, undo 颜色指定颜色1clear, light, gray, red, yellow, green, cyan, blue noteblockNoteBlock 是 Blockquote 的增强版，在左边显示图标，并且可以自定颜色。而 Note 是 NoteBlock 的简便写法。 最后更新于 5.0 版本123&#123;% noteblock 样式参数（可选）::标题（可选） %&#125;文本段落&#123;% endnoteblock %&#125; 演示效果可以在区块中放置一些复杂的结构，支持嵌套。 标题（可选）Windows 10不是為所有人設計,而是為每個人設計嵌套测试： 请坐和放宽，我正在帮你搞定一切… Folding 测试： 点击查看更多 不要说我们没有警告过你我们都有不顺利的时候 上述示例的源码example:123456789101112&#123;% noteblock::标题（可选） %&#125;Windows 10不是為所有人設計,而是為每個人設計&#123;% noteblock done %&#125;嵌套测试： 请坐和放宽，我正在帮你搞定一切...&#123;% endnoteblock %&#125;&#123;% folding yellow::Folding 测试： 点击查看更多 %&#125;&#123;% note warning::不要说我们没有警告过你 %&#125;&#123;% noteblock bug red %&#125;我们都有不顺利的时候&#123;% endnoteblock %&#125;&#123;% endfolding %&#125;&#123;% endnoteblock %&#125; 可以支持的参数样式参数位置可以写图标和颜色，多个样式参数用空格隔开。 图标彩色的1quote, info, warning, done/success, error/danger 灰色的，也可以指定颜色1radiation, bug, idea, link, paperclip, todo, message, guide, download, up, undo 颜色指定颜色1clear, light, gray, red, yellow, green, cyan, blue checkbox最后更新于 5.0 版本1&#123;% checkbox 样式参数（可选）::文本（支持简单md） %&#125; 演示效果 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 青色 + 默认选中 蓝色 + 默认选中 增加 减少 叉 上述示例的源码example:12345678910&#123;% checkbox 纯文本测试 %&#125;&#123;% checkbox checked::支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;&#123;% checkbox red::支持自定义颜色 %&#125;&#123;% checkbox green checked::绿色 + 默认选中 %&#125;&#123;% checkbox yellow checked::黄色 + 默认选中 %&#125;&#123;% checkbox cyan checked::青色 + 默认选中 %&#125;&#123;% checkbox blue checked::蓝色 + 默认选中 %&#125;&#123;% checkbox plus green checked::增加 %&#125;&#123;% checkbox minus yellow checked::减少 %&#125;&#123;% checkbox times red checked::叉 %&#125; 可以支持的参数颜色1red, yellow, green, cyan, blue 样式1plus, minus, times 选中状态1checked radio最后更新于 5.0 版本1&#123;% checkbox 样式参数（可选）::文本（支持简单md） %&#125; 演示效果 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 黄色 青色 蓝色 上述示例的源码example:1234567&#123;% radio 纯文本测试 %&#125;&#123;% radio checked::支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;&#123;% radio red::支持自定义颜色 %&#125;&#123;% radio green::绿色 %&#125;&#123;% radio yellow::黄色 %&#125;&#123;% radio cyan::青色 %&#125;&#123;% radio blue::蓝色 %&#125; 可以支持的参数颜色1red, yellow, green, cyan, blue 选中状态1checked timeline最后更新于 3.0 版本12345678&#123;% timeline 时间线标题（可选） %&#125;&#123;% timenode 时间节点（标题） %&#125;正文内容&#123;% endtimenode %&#125;&#123;% timenode 时间节点（标题） %&#125;正文内容&#123;% endtimenode %&#125;&#123;% endtimeline %&#125; 演示效果 2020-07-24 2.6.6 -&gt; 3.0 如果有 hexo-lazyload-image 插件，需要删除并重新安装最新版本，设置 lazyload.isSPA: true。2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 use_cdn: true 则需要删除。2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。2.x 版本的置顶 top: true 改为了 pin: true，并且同样适用于 layout: page 的页面。如果使用了 hexo-offline 插件，建议卸载，3.0 版本默认开启了 pjax 服务。 2020-05-15 2.6.3 -&gt; 2.6.6 不需要额外处理。 2020-04-20 2.6.2 -&gt; 2.6.3 全局搜索 seotitle 并替换为 seo_title。group 组件的索引规则有变，使用 group 组件的文章内，group: group_name 对应的组件名必须是 group_name。group 组件的列表名优先显示文章的 short_title 其次是 title。 上述示例的源码example:1234567891011121314151617&#123;% timeline %&#125;&#123;% timenode 2020-07-24 [2.6.6 -&gt; 3.0](https://github.com/volantis-x/hexo-theme-volantis/releases) %&#125;1. 如果有 `hexo-lazyload-image` 插件，需要删除并重新安装最新版本，设置 `lazyload.isSPA: true`。2. 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 `use_cdn: true` 则需要删除。3. 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。4. 2.x 版本的置顶 `top: true` 改为了 `pin: true`，并且同样适用于 `layout: page` 的页面。5. 如果使用了 `hexo-offline` 插件，建议卸载，3.0 版本默认开启了 pjax 服务。&#123;% endtimenode %&#125;&#123;% timenode 2020-05-15 [2.6.3 -&gt; 2.6.6](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6) %&#125;不需要额外处理。&#123;% endtimenode %&#125;&#123;% timenode 2020-04-20 [2.6.2 -&gt; 2.6.3](https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3) %&#125;1. 全局搜索 `seotitle` 并替换为 `seo_title`。2. group 组件的索引规则有变，使用 group 组件的文章内，`group: group_name` 对应的组件名必须是 `group_name`。2. group 组件的列表名优先显示文章的 `short_title` 其次是 `title`。&#123;% endtimenode %&#125;&#123;% endtimeline %&#125; link最后更新于 5.0 版本1&#123;% link 标题::链接::图片链接（可选） %&#125; 演示效果如何参与项目https://volantis.js.org/contributors/ 上述示例的源码example:1&#123;% link 如何参与项目::https://volantis.js.org/contributors/::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png %&#125; button这个页面的标签将会在不久后重构 基础按钮请将您的 Volantis 升级至 2.4 版本以上使用。 语法格式参数列表示例写法示例效果1&#123;% btn 样式参数（可选）::标题::链接::图标（可选） %&#125; 可选的参数可以省略，但是前后顺序不能乱。样式参数 1regular, large, center 图标 第1个或者第2个参数包含 fa- 的那个被识别为图标。example.md:12345不设置任何参数的 &#123;% btn 按钮:: / %&#125; 适合融入段落中。regular 按钮适合独立于段落之外：&#123;% btn regular::示例博客::https://xaoxuu.com::fas fa-play-circle %&#125;large 按钮更具有强调作用，建议搭配 center 使用：&#123;% btn center large::开始使用::https://volantis.js.org/v3/getting-started/::fas fa-download %&#125;行内按钮 不设置任何参数的 按钮 适合融入段落中。 空心按钮 示例博客 示例博客 示例博客 示例博客 居中： 开始使用 实心按钮 示例博客 示例博客 示例博客 示例博客 居中： 开始使用 富文本按钮请将您的 Volantis 升级至 2.3 版本以上使用。 语法格式参数列表示例写法示例效果1234&#123;% btns 样式参数 %&#125;&#123;% cell 标题::链接::图片或者图标 %&#125;&#123;% cell 标题::链接::图片或者图标 %&#125;&#123;% endbtns %&#125;样式参数位置可以写图片样式、布局方式，多个样式参数用空格隔开。 圆角样式 默认为方形 1rounded, circle 布局方式 默认为自动宽度，适合视野内只有一两个的情况。 参数 含义 wide 宽一点的按钮 fill 填充布局，自动铺满至少一行，多了会换行。 center 居中，按钮之间是固定间距。 around 居中分散 grid2 等宽最多2列，屏幕变窄会适当减少列数。 grid3 等宽最多3列，屏幕变窄会适当减少列数。 grid4 等宽最多4列，屏幕变窄会适当减少列数。 grid5 等宽最多5列，屏幕变窄会适当减少列数。 增加文字样式 可以在容器内增加 &lt;b&gt;标题&lt;/b&gt; 和 &lt;p&gt;描述文字&lt;/p&gt;如果需要显示类似「团队成员」之类的一组含有头像的链接： example.md:1234567&#123;% btns circle grid5 %&#125;&#123;% cell xaoxuu::https://xaoxuu.com::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;&#123;% cell xaoxuu::https://xaoxuu.com::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;&#123;% cell xaoxuu::https://xaoxuu.com::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;&#123;% cell xaoxuu::https://xaoxuu.com::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;&#123;% cell xaoxuu::https://xaoxuu.com::https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;&#123;% endbtns %&#125; 或者含有图标的按钮： example.md:1234&#123;% btns rounded grid5 %&#125;&#123;% cell 下载源码::/::fas fa-download %&#125;&#123;% cell 查看文档::/::fas fa-book-open %&#125;&#123;% endbtns %&#125; 圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中 example.md:1234567891011121314&#123;% btns circle center grid5 %&#125;&lt;a href=&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;&gt; &lt;i class=&#x27;fab fa-apple&#x27;&gt;&lt;/i&gt; &lt;b&gt;心率管家&lt;/b&gt; &#123;% p red::专业版 %&#125; &lt;img src=&#x27;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_pro.png&#x27;&gt;&lt;/a&gt;&lt;a href=&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;&gt; &lt;i class=&#x27;fab fa-apple&#x27;&gt;&lt;/i&gt; &lt;b&gt;心率管家&lt;/b&gt; &#123;% p green::免费版 %&#125; &lt;img src=&#x27;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_lite.png&#x27;&gt;&lt;/a&gt;&#123;% endbtns %&#125;如果需要显示类似「团队成员」之类的一组含有头像的链接： xaoxuu xaoxuu xaoxuu xaoxuu xaoxuu 或者含有图标的按钮： 下载源码 查看文档 圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中 心率管家 专业版 心率管家 免费版 ghcard最后更新于 5.0 版本12&#123;% ghcard 用户名::其它参数（可选） %&#125;&#123;% ghcard 用户名/仓库::其它参数（可选） %&#125; 用户信息卡片 上述示例的源码： example:12345| &#123;% ghcard xaoxuu %&#125; | &#123;% ghcard xaoxuu::theme=vue %&#125; || -- | -- || &#123;% ghcard xaoxuu::theme=buefy %&#125; | &#123;% ghcard xaoxuu::theme=solarized-light %&#125; || &#123;% ghcard xaoxuu::theme=onedark %&#125; | &#123;% ghcard xaoxuu::theme=solarized-dark %&#125; || &#123;% ghcard xaoxuu::theme=algolia %&#125; | &#123;% ghcard xaoxuu::theme=calm %&#125; | 仓库信息卡片 上述示例的源码： example:12345| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis::theme=vue %&#125; || -- | -- || &#123;% ghcard volantis-x/hexo-theme-volantis::theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis::theme=solarized-light %&#125; || &#123;% ghcard volantis-x/hexo-theme-volantis::theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis::theme=solarized-dark %&#125; || &#123;% ghcard volantis-x/hexo-theme-volantis::theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis::theme=calm %&#125; | 更多参数选择GitHub 卡片 API 参数https://github-readme-stats.vercel.app site网站卡片可以显示网站截图、logo、标题、描述，使用方法和友链标签一模一样，唯一的区别是数据文件名称为 sites.yml，可以和友链数据混用，通过分组过滤实现不一样的效果。 示例写法1&#123;% sites only:community_team %&#125; sites only:community_team dropmenu这个页面的标签将会在不久后重构 下拉菜单请将您的 Volantis 升级至 3.0 版本以上使用。 语法格式示例写法示例效果容器 123&#123;% menu 前缀（可省略）::标题::后缀（可省略） %&#125;菜单内容&#123;% endmenu %&#125; 菜单内容 菜单项 1&#123;% menuitem 文本::链接::图标 %&#125; 分割线 1&#123;% menuitem hr %&#125; 子菜单 123&#123;% submenu 嵌套菜单::图标 %&#125;菜单内容&#123;% endsubmenu %&#125;示例1 12345678910&#123;% menu 下拉菜单 %&#125;&#123;% menuitem 主题源码::https://github.com/volantis-x/hexo-theme-volantis/::fas fa-file-code %&#125;&#123;% menuitem 更新日志::https://github.com/volantis-x/hexo-theme-volantis/releases/::fas fa-clipboard-list %&#125;&#123;% menuitem hr %&#125;&#123;% submenu 有疑问？::fas fa-question-circle %&#125;&#123;% menuitem 看 FAQ::/faqs/ %&#125;&#123;% menuitem 看 本站源码::https://github.com/volantis-x/volantis-docs/ %&#125;&#123;% menuitem 提 Issue::https://github.com/volantis-x/hexo-theme-volantis/issues/ %&#125;&#123;% endsubmenu %&#125;&#123;% endmenu %&#125; 示例2 123&#123;% menu 这个是::下拉菜单 %&#125;（同上）&#123;% endmenu %&#125; 示例3 123&#123;% menu 这个是::下拉菜单::的示例效果。 %&#125;（同上）&#123;% endmenu %&#125;示例1 下拉菜单 主题源码 更新日志 有疑问？ 看 FAQ 看 本站源码 提 Issue 示例2 这个是 下拉菜单 主题源码 更新日志 有疑问？ 看 FAQ 看 本站源码 提 Issue 示例3 这个是 下拉菜单 主题源码 更新日志 有疑问？ 看 FAQ 看 本站源码 提 Issue 的示例效果。 tab此插件移植自 NexT #tabs 最后更新于 2.1 版本12345678&#123;% tabs 页面内不重复的ID %&#125;&lt;!-- tab 栏目1 --&gt;内容&lt;!-- endtab --&gt;&lt;!-- tab 栏目2 --&gt;内容&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 演示效果栏目1栏目2。。。！！！ 上述示例的源码example:12345678&#123;% tabs tab-id %&#125;&lt;!-- tab 栏目1 --&gt;。。。&lt;!-- endtab --&gt;&lt;!-- tab 栏目2 --&gt;！！！&lt;!-- endtab --&gt;&#123;% endtabs %&#125; folding最后更新于 5.0 版本123&#123;% folding 参数（可选）::标题 %&#125;![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg)&#123;% endfolding %&#125; 演示效果 查看图片测试 查看默认打开的折叠框 这是一个默认打开的折叠框。 查看代码测试 12345&#123;% folding green::查看代码测试 %&#125;查看代码测试&#123;% endfolding %&#125; 查看列表测试 hahahehe 查看嵌套测试 查看嵌套测试2 查看嵌套测试3 hahaha 上述示例的源码example:12345678910111213141516171819&#123;% folding 查看图片测试 %&#125;![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg)&#123;% endfolding %&#125;&#123;% folding cyan open::查看默认打开的折叠框 %&#125;这是一个默认打开的折叠框。&#123;% endfolding %&#125;&#123;% folding green::查看代码测试 %&#125;&#123;% endfolding %&#125;&#123;% folding yellow::查看列表测试 %&#125;- haha- hehe&#123;% endfolding %&#125;&#123;% folding red::查看嵌套测试 %&#125;&#123;% folding blue::查看嵌套测试2 %&#125;&#123;% folding 查看嵌套测试3 %&#125;hahaha &lt;span&gt;&lt;img src=&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27; style=&#x27;height:24px&#x27;&gt;&lt;/span&gt;&#123;% endfolding %&#125;&#123;% endfolding %&#125;&#123;% endfolding %&#125; 可以支持的参数参数位置可以填写颜色和状态，多个参数用空格隔开。 颜色1blue, cyan, green, yellow, red 状态状态填写 open 代表默认打开。 inlineimageInlineimage 标签是一种行内图片标签，可以用来在一段话中间插入表情。 本插件最后更新于 5.0 版本1&#123;% inlineimage 图片链接::height=高度（可选） %&#125; 演示效果这是 一段话。 这又是 一段话。 上述示例的源码example:12这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif::height=40px %&#125; 一段话。 可以支持的参数高度1height=20px imageImage 标签是一种针对单个图片应用场景的标签，支持图片描述文字和指定宽度。 本插件最后更新于 5.0 版本1&#123;% image 链接::width=宽度（可选）::height=高度（可选）::alt=描述（可选）::bg=占位颜色（可选） %&#125; 演示效果添加描述： 每天下课回宿舍的路，没有什么故事。 指定宽度： 指定宽度并添加描述： 每天下课回宿舍的路，没有什么故事。 设置占位背景色： 优化不同宽度浏览的观感 上述示例的源码example:12345678添加描述：&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg::alt=每天下课回宿舍的路，没有什么故事。 %&#125;指定宽度：&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg::width=400px %&#125;指定宽度并添加描述：&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg::width=400px::alt=每天下课回宿舍的路，没有什么故事。 %&#125;设置占位背景色：&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg::width=400px::bg=#1D0C04::alt=优化不同宽度浏览的观感 %&#125; 可以支持的参数图片宽高度example:1width=300px::height=32px 图片描述example:1alt=图片描述 占位背景色example:1bg=#f2f2f2 galleryGallery 标签是一种针对一组图片应用场景的标签。 本插件最后更新于 5.0 版本1234&#123;% gallery 参数::列数::分组 %&#125;![图片描述](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/B18FCBB3-67FD-48CC-B4F3-457BA145F17A.jpeg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/67239FBB-E15D-4F4F-8EE8-0F1C9F3C4E7C.jpeg)&#123;% endgallery %&#125; 演示效果一行一个图片 图片描述 一行多个图片（不换行） 图片描述图片描述图片描述 多行多个图片（每行2～8个图片） 上述示例的源码一行一个图片 example.md:123&#123;% gallery %&#125;![图片描述](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg)&#123;% endgallery %&#125; 一行多个图片（不换行） example.md:12345&#123;% gallery::::one %&#125;![图片描述](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/B18FCBB3-67FD-48CC-B4F3-457BA145F17A.jpeg)![图片描述](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/67239FBB-E15D-4F4F-8EE8-0F1C9F3C4E7C.jpeg)![图片描述](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/00E0F0ED-9F1C-407A-9AA6-545649D919F4.jpeg)&#123;% endgallery %&#125; 多行多个图片（每行2～8个图片） example.md:1234567891011121314151617181920212223242526&#123;% gallery stretch::6::two %&#125;![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/007.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/008.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/009.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/010.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/011.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/013.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/014.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/015.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/017.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/018.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/020.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/021.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/022.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/023.jpg)![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/024.jpg)&#123;% endgallery %&#125; 可以支持的参数对齐方向1left::center::right 缩放1stretch 列数::后面直接写列数，支持 2 ～ 8 列。设定列数之后就是「多行多图」布局，此时图片默认左对齐。为了避免图片大小不一，建议搭配 stretch 来时图片放大填充。 测试中 设定列数之后 不会产生 累积布局偏移; 没有设定列数 产生了累积布局偏移 分组相同内容的会被归档在一个分组中。 audio本插件最后更新于 2.4 版本1&#123;% audio 音频链接 %&#125; 演示效果Your browser does not support the audio tag. 上述示例的源码example:1&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125; video本插件最后更新于 5.0 版本1&#123;% video 视频链接 %&#125; 演示效果100%宽度 Your browser does not support the video tag. 50%宽度 Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. 25%宽度 Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. 上述示例的源码100%宽度 example.md:1&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125; 50%宽度 example.md:123456&#123;% videos::2 %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% endvideos %&#125; 25%宽度 example.md:12345678910&#123;% videos::4 %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;&#123;% endvideos %&#125; 可以支持的参数对齐方向1left::center::right 列数::后面直接写列数，支持 1 ～ 4 列。 frame这是一个能够将图片或者视频套入设备框架中的标签，可以用来更优雅地显示截图、录屏。 本插件最后更新于 5.0 版本12&#123;% frame 框架名::img=图片链接::alt=图片描述（可选）::part=top/bottom（可选） %&#125;&#123;% frame 框架名::video=视频链接::part=top/bottom（可选） %&#125; 1&#123;% frame iphone11::img=https://7.dusays.com/2020/09/28/baa33914a34ec.jpg::video=https://7.dusays.com/2020/09/28/39db723f1e200.mp4::part=top %&#125; 在这个示例中同时出现了 img 和 video 那么它就是一个带有封面的视频，在视频加载完成之前会先显示视频封面。 设备框架目前支持的有： 1iphone11 如果您有以下其它设备框架图(svg)，欢迎 PR 兼容。 1android, ipad, macbook, watch 剪裁通过设置 part=top 或者 part=bottom 来显示上半部分或者下半部分，否则将显示完整的框架及其中的图片/视频。 aplayer主题对 APlayer 插件的样式进行了兼容。安装插件： 1npm i -S hexo-tag-aplayer 使用方法： hexo-tag-aplayerhttps://github.com/MoePlayer/hexo-tag-aplayer issuesissues 标签在5.0版本移除 被 sites标签 friends标签 contributors标签 替代 友链标签您可以在任何位置插入友链，支持静态数据和动态数据，静态数据需要写在数据文件中： blog/source/_data/friends.yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455volantis_developer: title: description: items: - title: xaoxuu url: https://github.com/xaoxuu avatar: https://avatars.githubusercontent.com/u/16400144?s=60&amp;v=4 - title: MHuiG url: https://github.com/MHuiG avatar: https://avatars.githubusercontent.com/u/38281581?s=60&amp;v=4 - title: inkss url: https://github.com/inkss avatar: https://avatars.githubusercontent.com/u/31947043?s=60&amp;v=4 - title: Colsrch url: https://github.com/Colsrch avatar: https://avatars.githubusercontent.com/u/58458181?s=60&amp;v=4 - title: Drew233 url: https://github.com/Drew233 avatar: https://avatars.githubusercontent.com/u/47592224?s=60&amp;v=4 - title: Linhk1606 url: https://github.com/Linhk1606 avatar: https://avatars.githubusercontent.com/u/50829219?s=60&amp;v=4 - title: W4J1e url: https://github.com/W4J1e avatar: https://avatars.githubusercontent.com/u/74824162?s=60&amp;v=4community_builder: title: description: items: - title: xaoxuu url: https://github.com/xaoxuu avatar: https://avatars.githubusercontent.com/u/16400144?s=60&amp;v=4 - title: MHuiG url: https://github.com/MHuiG avatar: https://avatars.githubusercontent.com/u/38281581?s=60&amp;v=4 - title: Colsrch url: https://github.com/Colsrch avatar: https://avatars.githubusercontent.com/u/58458181?s=60&amp;v=4 - title: penndu url: https://github.com/penndu avatar: https://avatars.githubusercontent.com/u/46226528?s=60&amp;v=4 - title: heson525 url: https://github.com/heson525 avatar: https://avatars.githubusercontent.com/u/32234343?s=60&amp;v=4 - title: W4J1e url: https://github.com/W4J1e avatar: https://avatars.githubusercontent.com/u/74824162?s=60&amp;v=4 - title: luosiwei-cmd url: https://github.com/luosiwei-cmd avatar: https://avatars.githubusercontent.com/u/61175380?s=60&amp;v=4groupGitHub: title: 来自 GitHub 的朋友 description: &#x27;以下友链通过 [GitHub Issue](https://github.com/xaoxuu/friends/issues/) 提交，按 issue 最后更新时间排序：&#x27; api: https://issues-api.vercel.app repo: xaoxuu/friends 标题和描述都支持 md 格式，需要写在引号中。如果指定了 api 和 repo 字段，则从 issues 中取第一个 json 代码块数据作为友链。 写法如下1&#123;% friends %&#125; 数据按组筛选友链支持分组（白名单模式和黑名单模式）显示： 写法如下123456// 显示 volantis_developer&#123;% friends only:volantis_developer %&#125;// 显示 volantis_developer 和 community_builder&#123;% friends only:volantis_developer,community_builder %&#125;// 除了 community_builder 别的都显示&#123;% friends not:community_builder %&#125; friends only:volantis_developer 实现动态友链可以加载来自 issues 的友链数据，除了需要在 _data/friends.yml 中指定 api 和 repo 外，还需要做一下几件事： 从 xaoxuu/issues-api 作为模板克隆或者 fork 仓库，然后提交一个 issue 进行测试，不出意外的话，仓库中已经配置好了 issue 模板，只需要在模板中指定的位置填写信息就可以了。 提交完 issue 一分钟左右，如果仓库中出现了 output 分支提交，可以点击查看一下文件内容是否已经包含了刚刚提交的 issue 中的数据，如果包含，那么再次回到前端页面刷新就可以看到来自 issue 的友链数据了。 关于自建&nbsp;Vercel&nbsp;API 如果您想使用自己的 api，请把您刚创建的仓库导入到 Vercel 项目，详见 小冰博客 的教程。 特别感谢小冰博客通过 Vercel 进行加速的方案，解决了原本直接请求 GitHub API 速度过慢的问题。 只显示动态数据如果您不想创建 friends.yml 来设置任何静态数据，可以在标签中设置 repo 来只显示动态数据： 1&#123;% friends repo:xaoxuu/friends %&#125; 当然，如果您自己部署了 API 接口，可以指定： 1&#123;% friends repo:xaoxuu/friends api:https://issues-api.vercel.app %&#125; 网站卡片标签网站卡片可以显示网站截图、logo、标题、描述，使用方法和友链标签一模一样，唯一的区别是数据文件名称为 sites.yml，可以和友链数据混用，通过分组过滤实现不一样的效果。 示例写法1&#123;% sites only:test_demo %&#125; sites only:test_demo md在局部渲染外部md文件。 示例写法1&#123;% md https://cdn.jsdelivr.net/gh/volantis-x/hexo-theme-volantis/README.md %&#125; md (()=>{ volantis.css(\"https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.min.css\"); const contentEl = document.getElementById(\"md-3a4aa8da-d4b3-460e-9be6-690db591a9db\"); const loadMarkdown = (url) => { if (!window.fetch) { contentEl.innerHTML = 'Your browser outdated. Please use the latest version of Chrome or Firefox!您的浏览器版本过低，请使用最新版的 Chrome 或 Firefox 浏览器！'; } else { contentEl.innerHTML = 'Loading ... | 加载中。。。'; fetch(url, { method: \"GET\" }) .then((resp) => { return Promise.all([ resp.ok, resp.status, resp.text(), resp.headers, ]); }) .then(([ok, status, data, headers]) => { if (ok) { return { ok, status, data, headers, }; } else { throw new Error(JSON.stringify(json.error)); } }) .then((resp) => { let data = marked(resp.data); contentEl.innerHTML = data; }) .catch((error) => { console.log(error); contentEl.innerHTML = 'There was a problem loading the file!加载文件时出现问题！'; }); }; }; volantis.js(\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\").then(()=>{ loadMarkdown(\"https://cdn.jsdelivr.net/gh/volantis-x/hexo-theme-volantis/README.md?t=\" + new Date().getTime()); })})(); Hexo 通用标签在文章中使用 &lt;!-- more --&gt;，那么 &lt;!-- more --&gt; 之前的文字将会被视为摘要。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中。详见 Hexo 官方文档： Hexo 官方文档 #标签插件https://hexo.io/zh-cn/docs/tag-plugins","categories":[{"name":"教程","slug":"教程","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/"},{"name":"hexo","slug":"教程/hexo","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.pkubailu.cn/tags/hexo/"},{"name":"写作手册","slug":"写作手册","permalink":"https://www.pkubailu.cn/tags/%E5%86%99%E4%BD%9C%E6%89%8B%E5%86%8C/"},{"name":"参考资料","slug":"参考资料","permalink":"https://www.pkubailu.cn/tags/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"}]}],"categories":[{"name":"private","slug":"private","permalink":"https://www.pkubailu.cn/categories/private/"},{"name":"C++基础知识","slug":"C-基础知识","permalink":"https://www.pkubailu.cn/categories/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.pkubailu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"教程","slug":"教程","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/"},{"name":"图床","slug":"教程/图床","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/%E5%9B%BE%E5%BA%8A/"},{"name":"实践中的问题","slug":"实践中的问题","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"},{"name":"Git","slug":"实践中的问题/Git","permalink":"https://www.pkubailu.cn/categories/%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/Git/"},{"name":"Nginx图片服务器","slug":"教程/Nginx图片服务器","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/Nginx%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"同时配置github与gitlab","slug":"教程/同时配置github与gitlab","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEgithub%E4%B8%8Egitlab/"},{"name":"hexo","slug":"教程/hexo","permalink":"https://www.pkubailu.cn/categories/%E6%95%99%E7%A8%8B/hexo/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"https://www.pkubailu.cn/tags/C-%E5%9F%BA%E7%A1%80/"},{"name":"private","slug":"private","permalink":"https://www.pkubailu.cn/tags/private/"},{"name":"JS","slug":"JS","permalink":"https://www.pkubailu.cn/tags/JS/"},{"name":"数据类型","slug":"数据类型","permalink":"https://www.pkubailu.cn/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"跨域","slug":"跨域","permalink":"https://www.pkubailu.cn/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"CORS","slug":"CORS","permalink":"https://www.pkubailu.cn/tags/CORS/"},{"name":"图床","slug":"图床","permalink":"https://www.pkubailu.cn/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"git push","slug":"git-push","permalink":"https://www.pkubailu.cn/tags/git-push/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.pkubailu.cn/tags/Nginx/"},{"name":"图片服务器","slug":"图片服务器","permalink":"https://www.pkubailu.cn/tags/%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"github","slug":"github","permalink":"https://www.pkubailu.cn/tags/github/"},{"name":"gitlab","slug":"gitlab","permalink":"https://www.pkubailu.cn/tags/gitlab/"},{"name":"git commit 规范","slug":"git-commit-规范","permalink":"https://www.pkubailu.cn/tags/git-commit-%E8%A7%84%E8%8C%83/"},{"name":"git关联远程仓库","slug":"git关联远程仓库","permalink":"https://www.pkubailu.cn/tags/git%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"name":"git分支","slug":"git分支","permalink":"https://www.pkubailu.cn/tags/git%E5%88%86%E6%94%AF/"},{"name":"hexo","slug":"hexo","permalink":"https://www.pkubailu.cn/tags/hexo/"},{"name":"写作手册","slug":"写作手册","permalink":"https://www.pkubailu.cn/tags/%E5%86%99%E4%BD%9C%E6%89%8B%E5%86%8C/"},{"name":"参考资料","slug":"参考资料","permalink":"https://www.pkubailu.cn/tags/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"}]}